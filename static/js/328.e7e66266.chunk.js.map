{"version":3,"file":"static/js/328.e7e66266.chunk.js","mappings":"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","sources":["../node_modules/highcharts/highcharts-more.src.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"],"sourcesContent":["/**\n * @license Highcharts JS v10.3.3 (2023-01-20)\n *\n * (c) 2009-2021 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/highcharts-more', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/Pane.js', [_modules['Core/Chart/Chart.js'], _modules['Series/CenteredUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Pointer.js'], _modules['Core/Utilities.js']], function (Chart, CU, H, Pointer, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent,\n            correctFloat = U.correctFloat,\n            defined = U.defined,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick,\n            splat = U.splat;\n        /**\n         * @typedef {\"arc\"|\"circle\"|\"solid\"} Highcharts.PaneBackgroundShapeValue\n         */\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        Chart.prototype.collectionsWithUpdate.push('pane');\n        /**\n         * The Pane object allows options that are common to a set of X and Y axes.\n         *\n         * In the future, this can be extended to basic Highcharts and Highcharts Stock.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pane\n         * @param {Highcharts.PaneOptions} options\n         * @param {Highcharts.Chart} chart\n         */\n        var Pane = /** @class */ (function () {\n                function Pane(options, chart) {\n                    this.background = void 0;\n                this.center = void 0;\n                this.chart = void 0;\n                this.options = void 0;\n                this.coll = 'pane'; // Member of chart.pane\n                /**\n                 * The pane serves as a container for axes and backgrounds for circular\n                 * gauges and polar charts.\n                 *\n                 * @since        2.3.0\n                 * @product      highcharts\n                 * @requires     highcharts-more\n                 * @optionparent pane\n                 */\n                this.defaultOptions = {\n                    /**\n                     * The end angle of the polar X axis or gauge value axis, given in\n                     * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)\n                     * + 360.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         VU-meter with custom start and end angle\n                     *\n                     * @type      {number}\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption pane.endAngle\n                     */\n                    /**\n                     * The center of a polar chart or angular gauge, given as an array\n                     * of [x, y] positions. Positions can be given as integers that\n                     * transform to pixels, or as percentages of the plot area size.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         Two gauges with different center\n                     *\n                     * @type    {Array<string|number>}\n                     * @default [\"50%\", \"50%\"]\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    center: ['50%', '50%'],\n                    /**\n                     * The size of the pane, either as a number defining pixels, or a\n                     * percentage defining a percentage of the available plot area (the\n                     * smallest of the plot height or plot width).\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         Smaller size\n                     *\n                     * @type    {number|string}\n                     * @product highcharts\n                     */\n                    size: '85%',\n                    /**\n                     * The inner size of the pane, either as a number defining pixels, or a\n                     * percentage defining a percentage of the pane's size.\n                     *\n                     * @sample {highcharts} highcharts/series-polar/column-inverted-inner\n                     *         The inner size set to 20%\n                     *\n                     * @type    {number|string}\n                     * @product highcharts\n                     */\n                    innerSize: '0%',\n                    /**\n                     * The start angle of the polar X axis or gauge axis, given in degrees\n                     * where 0 is north. Defaults to 0.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         VU-meter with custom start and end angle\n                     *\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    startAngle: 0\n                };\n                /**\n                 * An array of background items for the pane.\n                 *\n                 * @sample {highcharts} highcharts/demo/gauge-speedometer/\n                 *         Speedometer gauge with multiple backgrounds\n                 *\n                 * @type         {Array<*>}\n                 * @optionparent pane.background\n                 */\n                this.defaultBackgroundOptions = {\n                    /**\n                     * The class name for this background.\n                     *\n                     * @sample {highcharts} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     * @sample {highstock} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     * @sample {highmaps} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     *\n                     * @type      {string}\n                     * @default   highcharts-pane\n                     * @since     5.0.0\n                     * @apioption pane.background.className\n                     */\n                    /**\n                     * The shape of the pane background. When `solid`, the background\n                     * is circular. When `arc`, the background extends only from the min\n                     * to the max of the value axis.\n                     *\n                     * @type    {Highcharts.PaneBackgroundShapeValue}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    shape: 'circle',\n                    /**\n                     * The pixel border width of the pane background.\n                     *\n                     * @since 2.3.0\n                     * @product highcharts\n                     */\n                    borderWidth: 1,\n                    /**\n                     * The pane background border color.\n                     *\n                     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The background color or gradient for the pane.\n                     *\n                     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    backgroundColor: {\n                        /** @ignore-option */\n                        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n                        /** @ignore-option */\n                        stops: [\n                            [0, \"#ffffff\" /* Palette.backgroundColor */],\n                            [1, \"#e6e6e6\" /* Palette.neutralColor10 */]\n                        ]\n                    },\n                    /** @ignore-option */\n                    from: -Number.MAX_VALUE,\n                    /**\n                     * The inner radius of the pane background. Can be either numeric\n                     * (pixels) or a percentage string.\n                     *\n                     * @type    {number|string}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    innerRadius: 0,\n                    /** @ignore-option */\n                    to: Number.MAX_VALUE,\n                    /**\n                     * The outer radius of the circular pane background. Can be either\n                     * numeric (pixels) or a percentage string.\n                     *\n                     * @type     {number|string}\n                     * @since    2.3.0\n                     * @product  highcharts\n                     */\n                    outerRadius: '105%'\n                };\n                this.init(options, chart);\n            }\n            /**\n             * Initialize the Pane object\n             *\n             * @private\n             * @function Highcharts.Pane#init\n             *\n             * @param {Highcharts.PaneOptions} options\n             *\n             * @param {Highcharts.Chart} chart\n             */\n            Pane.prototype.init = function (options, chart) {\n                this.chart = chart;\n                this.background = [];\n                chart.pane.push(this);\n                this.setOptions(options);\n            };\n            /**\n             * @private\n             * @function Highcharts.Pane#setOptions\n             *\n             * @param {Highcharts.PaneOptions} options\n             */\n            Pane.prototype.setOptions = function (options) {\n                // Set options. Angular charts have a default background (#3318)\n                this.options = options = merge(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);\n            };\n            /**\n             * Render the pane with its backgrounds.\n             *\n             * @private\n             * @function Highcharts.Pane#render\n             */\n            Pane.prototype.render = function () {\n                var options = this.options,\n                    backgroundOption = this.options.background,\n                    renderer = this.chart.renderer,\n                    len,\n                    i;\n                if (!this.group) {\n                    this.group = renderer.g('pane-group')\n                        .attr({ zIndex: options.zIndex || 0 })\n                        .add();\n                }\n                this.updateCenter();\n                // Render the backgrounds\n                if (backgroundOption) {\n                    backgroundOption = splat(backgroundOption);\n                    len = Math.max(backgroundOption.length, this.background.length || 0);\n                    for (i = 0; i < len; i++) {\n                        // #6641 - if axis exists, chart is circular and apply\n                        // background\n                        if (backgroundOption[i] && this.axis) {\n                            this.renderBackground(merge(this.defaultBackgroundOptions, backgroundOption[i]), i);\n                        }\n                        else if (this.background[i]) {\n                            this.background[i] = this.background[i].destroy();\n                            this.background.splice(i, 1);\n                        }\n                    }\n                }\n            };\n            /**\n             * Render an individual pane background.\n             *\n             * @private\n             * @function Highcharts.Pane#renderBackground\n             *\n             * @param {Highcharts.PaneBackgroundOptions} backgroundOptions\n             *        Background options\n             *\n             * @param {number} i\n             *        The index of the background in this.backgrounds\n             */\n            Pane.prototype.renderBackground = function (backgroundOptions, i) {\n                var method = 'animate',\n                    attribs = {\n                        'class': 'highcharts-pane ' + (backgroundOptions.className || '')\n                    };\n                if (!this.chart.styledMode) {\n                    extend(attribs, {\n                        'fill': backgroundOptions.backgroundColor,\n                        'stroke': backgroundOptions.borderColor,\n                        'stroke-width': backgroundOptions.borderWidth\n                    });\n                }\n                if (!this.background[i]) {\n                    this.background[i] = this.chart.renderer\n                        .path()\n                        .add(this.group);\n                    method = 'attr';\n                }\n                this.background[i][method]({\n                    'd': this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)\n                }).attr(attribs);\n            };\n            /**\n             * Gets the center for the pane and its axis.\n             *\n             * @private\n             * @function Highcharts.Pane#updateCenter\n             * @param {Highcharts.Axis} [axis]\n             */\n            Pane.prototype.updateCenter = function (axis) {\n                this.center = (axis ||\n                    this.axis ||\n                    {}).center = CU.getCenter.call(this);\n            };\n            /**\n             * Destroy the pane item\n             *\n             * @ignore\n             * @private\n             * @function Highcharts.Pane#destroy\n             * /\n            destroy: function () {\n                erase(this.chart.pane, this);\n                this.background.forEach(function (background) {\n                    background.destroy();\n                });\n                this.background.length = 0;\n                this.group = this.group.destroy();\n            },\n            */\n            /**\n             * Update the pane item with new options\n             *\n             * @private\n             * @function Highcharts.Pane#update\n             * @param {Highcharts.PaneOptions} options\n             *        New pane options\n             * @param {boolean} [redraw]\n             */\n            Pane.prototype.update = function (options, redraw) {\n                merge(true, this.options, options);\n                this.setOptions(this.options);\n                this.render();\n                this.chart.axes.forEach(function (axis) {\n                    if (axis.pane === this) {\n                        axis.pane = null;\n                        axis.update({}, redraw);\n                    }\n                }, this);\n            };\n            return Pane;\n        }());\n        /**\n         * Check whether element is inside or outside pane.\n         * @private\n         * @param  {number} x\n         * Element's x coordinate\n         * @param  {number} y\n         * Element's y coordinate\n         * @param  {Array<number>} inverted\n         * `Chart.inverted` param\n         * @param  {Array<number>} center\n         * Pane's center (x, y) and diameter\n         * @param  {number} startAngle\n         * Pane's normalized start angle in radians (<-PI, PI>)\n         * @param  {number} endAngle\n         * Pane's normalized end angle in radians (<-PI, PI>)\n         */\n        function isInsidePane(x, y, center, startAngle, endAngle) {\n            var insideSlice = true;\n            var cx = center[0],\n                cy = center[1];\n            var distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));\n            if (defined(startAngle) && defined(endAngle)) {\n                // Round angle to N-decimals to avoid numeric errors\n                var angle = Math.atan2(correctFloat(y - cy, 8),\n                    correctFloat(x - cx, 8));\n                // Ignore full circle panes:\n                if (endAngle !== startAngle) {\n                    // If normalized start angle is bigger than normalized end,\n                    // it means angles have different signs. In such situation we\n                    // check the <-PI, startAngle> and <endAngle, PI> ranges.\n                    if (startAngle > endAngle) {\n                        insideSlice = (angle >= startAngle &&\n                            angle <= Math.PI) || (angle <= endAngle &&\n                            angle >= -Math.PI);\n                    }\n                    else {\n                        // In this case, we simple check if angle is within the\n                        // <startAngle, endAngle> range\n                        insideSlice = angle >= startAngle &&\n                            angle <= correctFloat(endAngle, 8);\n                    }\n                }\n            }\n            // Round up radius because x and y values are rounded\n            return distance <= Math.ceil(center[2] / 2) && insideSlice;\n        }\n        Chart.prototype.getHoverPane = function (eventArgs) {\n            var chart = this;\n            var hoverPane;\n            if (eventArgs) {\n                chart.pane.forEach(function (pane) {\n                    var x = eventArgs.chartX - chart.plotLeft,\n                        y = eventArgs.chartY - chart.plotTop;\n                    if (isInsidePane(x, y, pane.center)) {\n                        hoverPane = pane;\n                    }\n                });\n            }\n            return hoverPane;\n        };\n        // Check if (x, y) position is within pane for polar\n        addEvent(Chart, 'afterIsInsidePlot', function (e) {\n            var _a;\n            var chart = this;\n            if (chart.polar) {\n                if (e.options.inverted) {\n                    _a = [e.y, e.x], e.x = _a[0], e.y = _a[1];\n                }\n                e.isInsidePlot = chart.pane.some(function (pane) { return isInsidePane(e.x, e.y, pane.center, pane.axis && pane.axis.normalizedStartAngleRad, pane.axis && pane.axis.normalizedEndAngleRad); });\n            }\n        });\n        addEvent(Pointer, 'beforeGetHoverData', function (eventArgs) {\n            var chart = this.chart;\n            if (chart.polar) {\n                // Find pane we are currently hovering over.\n                chart.hoverPane = chart.getHoverPane(eventArgs);\n                // Edit filter method to handle polar\n                eventArgs.filter = function (s) {\n                    return (s.visible &&\n                        !(!eventArgs.shared && s.directTouch) && // #3821\n                        pick(s.options.enableMouseTracking, true) &&\n                        (!chart.hoverPane || s.xAxis.pane === chart.hoverPane));\n                };\n            }\n            else {\n                chart.hoverPane = void 0;\n            }\n        });\n        addEvent(Pointer, 'afterGetHoverData', function (eventArgs) {\n            var chart = this.chart;\n            if (eventArgs.hoverPoint &&\n                eventArgs.hoverPoint.plotX &&\n                eventArgs.hoverPoint.plotY &&\n                chart.hoverPane &&\n                !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {\n                eventArgs.hoverPoint = void 0;\n            }\n        });\n        H.Pane = Pane;\n\n        return H.Pane;\n    });\n    _registerModule(_modules, 'Series/AreaRange/AreaRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes.area.prototype,\n            AreaPoint = _a.pointClass,\n            areaProto = _a.pointClass.prototype;\n        var defined = U.defined,\n            isNumber = U.isNumber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var AreaRangePoint = /** @class */ (function (_super) {\n                __extends(AreaRangePoint, _super);\n            function AreaRangePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /**\n                 * Range series only. The high or maximum value for each data point.\n                 * @name Highcharts.Point#high\n                 * @type {number|undefined}\n                 */\n                _this.high = void 0;\n                /**\n                 * Range series only. The low or minimum value for each data point.\n                 * @name Highcharts.Point#low\n                 * @type {number|undefined}\n                 */\n                _this.low = void 0;\n                _this.options = void 0;\n                _this.plotX = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            AreaRangePoint.prototype.setState = function () {\n                var prevState = this.state,\n                    series = this.series,\n                    isPolar = series.chart.polar;\n                if (!defined(this.plotHigh)) {\n                    // Boost doesn't calculate plotHigh\n                    this.plotHigh = series.yAxis.toPixels(this.high, true);\n                }\n                if (!defined(this.plotLow)) {\n                    // Boost doesn't calculate plotLow\n                    this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);\n                }\n                if (series.stateMarkerGraphic) {\n                    series.lowerStateMarkerGraphic = series.stateMarkerGraphic;\n                    series.stateMarkerGraphic = series.upperStateMarkerGraphic;\n                }\n                // Change state also for the top marker\n                this.graphic = this.graphics && this.graphics[1];\n                this.plotY = this.plotHigh;\n                if (isPolar && isNumber(this.plotHighX)) {\n                    this.plotX = this.plotHighX;\n                }\n                // Top state:\n                areaProto.setState.apply(this, arguments);\n                this.state = prevState;\n                // Now restore defaults\n                this.plotY = this.plotLow;\n                this.graphic = this.graphics && this.graphics[0];\n                if (isPolar && isNumber(this.plotLowX)) {\n                    this.plotX = this.plotLowX;\n                }\n                if (series.stateMarkerGraphic) {\n                    series.upperStateMarkerGraphic = series.stateMarkerGraphic;\n                    series.stateMarkerGraphic = series.lowerStateMarkerGraphic;\n                    // Lower marker is stored at stateMarkerGraphic\n                    // to avoid reference duplication (#7021)\n                    series.lowerStateMarkerGraphic = void 0;\n                }\n                areaProto.setState.apply(this, arguments);\n            };\n            AreaRangePoint.prototype.haloPath = function () {\n                var isPolar = this.series.chart.polar;\n                var path = [];\n                // Bottom halo\n                this.plotY = this.plotLow;\n                if (isPolar && isNumber(this.plotLowX)) {\n                    this.plotX = this.plotLowX;\n                }\n                if (this.isInside) {\n                    path = areaProto.haloPath.apply(this, arguments);\n                }\n                // Top halo\n                this.plotY = this.plotHigh;\n                if (isPolar && isNumber(this.plotHighX)) {\n                    this.plotX = this.plotHighX;\n                }\n                if (this.isTopInside) {\n                    path = path.concat(areaProto.haloPath.apply(this, arguments));\n                }\n                return path;\n            };\n            AreaRangePoint.prototype.isValid = function () {\n                return isNumber(this.low) && isNumber(this.high);\n            };\n            return AreaRangePoint;\n        }(AreaPoint));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AreaRangePoint;\n    });\n    _registerModule(_modules, 'Series/AreaRange/AreaRangeSeries.js', [_modules['Series/AreaRange/AreaRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (AreaRangePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var _a = SeriesRegistry.seriesTypes,\n            AreaSeries = _a.area,\n            areaProto = _a.area.prototype,\n            columnProto = _a.column.prototype;\n        var addEvent = U.addEvent,\n            defined = U.defined,\n            extend = U.extend,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            pick = U.pick,\n            merge = U.merge;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The area range series is a carteseian series with higher and lower values for\n         * each point along an X axis, where the area between the values is shaded.\n         *\n         * @sample {highcharts} highcharts/demo/arearange/\n         *         Area range chart\n         * @sample {highstock} stock/demo/arearange/\n         *         Area range chart\n         *\n         * @extends      plotOptions.area\n         * @product      highcharts highstock\n         * @excluding    stack, stacking\n         * @requires     highcharts-more\n         * @optionparent plotOptions.arearange\n         *\n         * @private\n         */\n        var areaRangeSeriesOptions = {\n                /**\n                 * @see [fillColor](#plotOptions.arearange.fillColor)\n                 * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n                 *\n                 * @apioption plotOptions.arearange.color\n                 */\n                /**\n                 * @default   low\n                 * @apioption plotOptions.arearange.colorKey\n                 */\n                /**\n                 * @see [color](#plotOptions.arearange.color)\n                 * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n                 *\n                 * @apioption plotOptions.arearange.fillColor\n                 */\n                /**\n                 * @see [color](#plotOptions.arearange.color)\n                 * @see [fillColor](#plotOptions.arearange.fillColor)\n                 *\n                 * @default   {highcharts} 0.75\n                 * @default   {highstock} 0.75\n                 * @apioption plotOptions.arearange.fillOpacity\n                 */\n                /**\n                 * Whether to apply a drop shadow to the graph line. Since 2.3 the\n                 * shadow can be an object configuration containing `color`,\n            `offsetX`,\n                 * `offsetY`,\n            `opacity` and `width`.\n                 *\n                 * @type      {boolean|Highcharts.ShadowOptionsObject}\n                 * @product   highcharts\n                 * @apioption plotOptions.arearange.shadow\n                 */\n                /**\n                 * Pixel width of the arearange graph line.\n                 *\n                 * @since 2.3.0\n                 *\n                 * @private\n                 */\n                lineWidth: 1,\n                /**\n                 * @type {number|null}\n                 */\n                threshold: null,\n                tooltip: {\n                    pointFormat: '<span style=\"color:{series.color}\">\\u25CF</span> ' +\n                        '{series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n                },\n                /**\n                 * Whether the whole area or just the line should respond to mouseover\n                 * tooltips and other mouse or touch events.\n                 *\n                 * @since 2.3.0\n                 *\n                 * @private\n                 */\n                trackByArea: true,\n                /**\n                 * Extended data labels for range series types. Range series data\n                 * labels use no `x` and `y` options. Instead,\n            they have `xLow`,\n                 * `xHigh`,\n            `yLow` and `yHigh` options to allow the higher and lower\n                 * data label sets individually.\n                 *\n                 * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n                 * @exclude x,\n            y\n                 * @since   2.3.0\n                 * @product highcharts highstock\n                 *\n                 * @private\n                 */\n                dataLabels: {\n                    align: void 0,\n                    verticalAlign: void 0,\n                    /**\n                     * X offset of the lower data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    xLow: 0,\n                    /**\n                     * X offset of the higher data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    xHigh: 0,\n                    /**\n                     * Y offset of the lower data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    yLow: 0,\n                    /**\n                     * Y offset of the higher data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    yHigh: 0\n                }\n            };\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The AreaRange series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.arearange\n         *\n         * @augments Highcharts.Series\n         */\n        var AreaRangeSeries = /** @class */ (function (_super) {\n                __extends(AreaRangeSeries, _super);\n            function AreaRangeSeries() {\n                /**\n                 *\n                 *  Static Properties\n                 *\n                 */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.lowerStateMarkerGraphic = void 0;\n                _this.xAxis = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            AreaRangeSeries.prototype.toYData = function (point) {\n                return [point.low, point.high];\n            };\n            /**\n             * Translate a point's plotHigh from the internal angle and radius measures\n             * to true plotHigh coordinates. This is an addition of the toXY method\n             * found in Polar.js, because it runs too early for arearanges to be\n             * considered (#3419).\n             * @private\n             */\n            AreaRangeSeries.prototype.highToXY = function (point) {\n                // Find the polar plotX and plotY\n                var chart = this.chart,\n                    xy = this.xAxis.postTranslate(point.rectPlotX || 0,\n                    this.yAxis.len - (point.plotHigh || 0));\n                point.plotHighX = xy.x - chart.plotLeft;\n                point.plotHigh = xy.y - chart.plotTop;\n                point.plotLowX = point.plotX;\n            };\n            /**\n             * Extend the line series' getSegmentPath method by applying the segment\n             * path to both lower and higher values of the range.\n             * @private\n             */\n            AreaRangeSeries.prototype.getGraphPath = function (points) {\n                var highPoints = [],\n                    highAreaPoints = [],\n                    getGraphPath = areaProto.getGraphPath,\n                    options = this.options,\n                    polar = this.chart.polar,\n                    connectEnds = polar && options.connectEnds !== false,\n                    connectNulls = options.connectNulls;\n                var i,\n                    point,\n                    pointShim,\n                    step = options.step;\n                points = points || this.points;\n                // Create the top line and the top part of the area fill. The area fill\n                // compensates for null points by drawing down to the lower graph,\n                // moving across the null gap and starting again at the lower graph.\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    // Support for polar\n                    var highAreaPoint = polar ? {\n                            plotX: point.rectPlotX,\n                            plotY: point.yBottom,\n                            doCurve: false // #5186, gaps in areasplinerange fill\n                        } : {\n                            plotX: point.plotX,\n                            plotY: point.plotY,\n                            doCurve: false // #5186, gaps in areasplinerange fill\n                        };\n                    if (!point.isNull &&\n                        !connectEnds &&\n                        !connectNulls &&\n                        (!points[i + 1] || points[i + 1].isNull)) {\n                        highAreaPoints.push(highAreaPoint);\n                    }\n                    pointShim = {\n                        polarPlotY: point.polarPlotY,\n                        rectPlotX: point.rectPlotX,\n                        yBottom: point.yBottom,\n                        // plotHighX is for polar charts\n                        plotX: pick(point.plotHighX, point.plotX),\n                        plotY: point.plotHigh,\n                        isNull: point.isNull\n                    };\n                    highAreaPoints.push(pointShim);\n                    highPoints.push(pointShim);\n                    if (!point.isNull &&\n                        !connectEnds &&\n                        !connectNulls &&\n                        (!points[i - 1] || points[i - 1].isNull)) {\n                        highAreaPoints.push(highAreaPoint);\n                    }\n                }\n                // Get the paths\n                var lowerPath = getGraphPath.call(this,\n                    points);\n                if (step) {\n                    if (step === true) {\n                        step = 'left';\n                    }\n                    options.step = {\n                        left: 'right',\n                        center: 'center',\n                        right: 'left'\n                    }[step]; // swap for reading in getGraphPath\n                }\n                var higherPath = getGraphPath.call(this,\n                    highPoints);\n                var higherAreaPath = getGraphPath.call(this,\n                    highAreaPoints);\n                options.step = step;\n                // Create a line on both top and bottom of the range\n                var linePath = [].concat(lowerPath,\n                    higherPath);\n                // For the area path, we need to change the 'move' statement into\n                // 'lineTo'\n                if (!this.chart.polar &&\n                    higherAreaPath[0] &&\n                    higherAreaPath[0][0] === 'M') {\n                    // This probably doesn't work for spline\n                    higherAreaPath[0] = [\n                        'L',\n                        higherAreaPath[0][1],\n                        higherAreaPath[0][2]\n                    ];\n                }\n                this.graphPath = linePath;\n                this.areaPath = lowerPath.concat(higherAreaPath);\n                // Prepare for sideways animation\n                linePath.isArea = true;\n                linePath.xMap = lowerPath.xMap;\n                this.areaPath.xMap = lowerPath.xMap;\n                return linePath;\n            };\n            /**\n             * Extend the basic drawDataLabels method by running it for both lower and\n             * higher values.\n             * @private\n             */\n            AreaRangeSeries.prototype.drawDataLabels = function () {\n                var data = this.points,\n                    length = data.length,\n                    originalDataLabels = [],\n                    dataLabelOptions = this.options.dataLabels,\n                    inverted = this.chart.inverted;\n                var i,\n                    point,\n                    up,\n                    upperDataLabelOptions,\n                    lowerDataLabelOptions;\n                if (dataLabelOptions) {\n                    // Split into upper and lower options. If data labels is an array,\n                    // the first element is the upper label, the second is the lower.\n                    //\n                    // TODO: We want to change this and allow multiple labels for both\n                    // upper and lower values in the future - introducing some options\n                    // for which point value to use as Y for the dataLabel, so that this\n                    // could be handled in Series.drawDataLabels. This would also\n                    // improve performance since we now have to loop over all the points\n                    // multiple times to work around the data label logic.\n                    if (isArray(dataLabelOptions)) {\n                        upperDataLabelOptions = dataLabelOptions[0] || {\n                            enabled: false\n                        };\n                        lowerDataLabelOptions = dataLabelOptions[1] || {\n                            enabled: false\n                        };\n                    }\n                    else {\n                        // Make copies\n                        upperDataLabelOptions = extend({}, dataLabelOptions);\n                        upperDataLabelOptions.x = dataLabelOptions.xHigh;\n                        upperDataLabelOptions.y = dataLabelOptions.yHigh;\n                        lowerDataLabelOptions = extend({}, dataLabelOptions);\n                        lowerDataLabelOptions.x = dataLabelOptions.xLow;\n                        lowerDataLabelOptions.y = dataLabelOptions.yLow;\n                    }\n                    // Draw upper labels\n                    if (upperDataLabelOptions.enabled || this._hasPointLabels) {\n                        // Set preliminary values for plotY and dataLabel\n                        // and draw the upper labels\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                var _a = point.plotHigh,\n                                    plotHigh = _a === void 0 ? 0 : _a,\n                                    _b = point.plotLow,\n                                    plotLow = _b === void 0 ? 0 : _b;\n                                up = upperDataLabelOptions.inside ?\n                                    plotHigh < plotLow :\n                                    plotHigh > plotLow;\n                                point.y = point.high;\n                                point._plotY = point.plotY;\n                                point.plotY = plotHigh;\n                                // Store original data labels and set preliminary label\n                                // objects to be picked up in the uber method\n                                originalDataLabels[i] = point.dataLabel;\n                                point.dataLabel = point.dataLabelUpper;\n                                // Set the default offset\n                                point.below = up;\n                                if (inverted) {\n                                    if (!upperDataLabelOptions.align) {\n                                        upperDataLabelOptions.align = up ?\n                                            'right' : 'left';\n                                    }\n                                }\n                                else {\n                                    if (!upperDataLabelOptions.verticalAlign) {\n                                        upperDataLabelOptions.verticalAlign = up ?\n                                            'top' :\n                                            'bottom';\n                                    }\n                                }\n                            }\n                        }\n                        this.options.dataLabels = upperDataLabelOptions;\n                        if (areaProto.drawDataLabels) {\n                            // #1209:\n                            areaProto.drawDataLabels.apply(this, arguments);\n                        }\n                        // Reset state after the upper labels were created. Move\n                        // it to point.dataLabelUpper and reassign the originals.\n                        // We do this here to support not drawing a lower label.\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                point.dataLabelUpper = point.dataLabel;\n                                point.dataLabel = originalDataLabels[i];\n                                delete point.dataLabels;\n                                point.y = point.low;\n                                point.plotY = point._plotY;\n                            }\n                        }\n                    }\n                    // Draw lower labels\n                    if (lowerDataLabelOptions.enabled || this._hasPointLabels) {\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                var _c = point.plotHigh,\n                                    plotHigh = _c === void 0 ? 0 : _c,\n                                    _d = point.plotLow,\n                                    plotLow = _d === void 0 ? 0 : _d;\n                                up = lowerDataLabelOptions.inside ?\n                                    plotHigh < plotLow :\n                                    plotHigh > plotLow;\n                                // Set the default offset\n                                point.below = !up;\n                                if (inverted) {\n                                    if (!lowerDataLabelOptions.align) {\n                                        lowerDataLabelOptions.align = up ?\n                                            'left' : 'right';\n                                    }\n                                }\n                                else {\n                                    if (!lowerDataLabelOptions.verticalAlign) {\n                                        lowerDataLabelOptions.verticalAlign = up ?\n                                            'bottom' :\n                                            'top';\n                                    }\n                                }\n                            }\n                        }\n                        this.options.dataLabels = lowerDataLabelOptions;\n                        if (areaProto.drawDataLabels) {\n                            areaProto.drawDataLabels.apply(this, arguments);\n                        }\n                    }\n                    // Merge upper and lower into point.dataLabels for later destroying\n                    if (upperDataLabelOptions.enabled) {\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                point.dataLabels = [\n                                    point.dataLabelUpper,\n                                    point.dataLabel\n                                ].filter(function (label) {\n                                    return !!label;\n                                });\n                            }\n                        }\n                    }\n                    // Reset options\n                    this.options.dataLabels = dataLabelOptions;\n                }\n            };\n            AreaRangeSeries.prototype.alignDataLabel = function () {\n                columnProto.alignDataLabel.apply(this, arguments);\n            };\n            AreaRangeSeries.prototype.drawPoints = function () {\n                var series = this,\n                    pointLength = series.points.length;\n                var i,\n                    point;\n                // Draw bottom points\n                areaProto.drawPoints.apply(series, arguments);\n                // Prepare drawing top points\n                i = 0;\n                while (i < pointLength) {\n                    point = series.points[i];\n                    /**\n                     * Array for multiple SVG graphics representing the point in the\n                     * chart. Only used in cases where the point can not be represented\n                     * by a single graphic.\n                     *\n                     * @see Highcharts.Point#graphic\n                     *\n                     * @name Highcharts.Point#graphics\n                     * @type {Array<Highcharts.SVGElement>|undefined}\n                     */\n                    point.graphics = point.graphics || [];\n                    // Save original props to be overridden by temporary props for top\n                    // points\n                    point.origProps = {\n                        plotY: point.plotY,\n                        plotX: point.plotX,\n                        isInside: point.isInside,\n                        negative: point.negative,\n                        zone: point.zone,\n                        y: point.y\n                    };\n                    if (point.graphic || point.graphics[0]) {\n                        point.graphics[0] = point.graphic;\n                    }\n                    point.graphic = point.graphics[1];\n                    point.plotY = point.plotHigh;\n                    if (defined(point.plotHighX)) {\n                        point.plotX = point.plotHighX;\n                    }\n                    point.y = pick(point.high, point.origProps.y); // #15523\n                    point.negative = point.y < (series.options.threshold || 0);\n                    if (series.zones.length) {\n                        point.zone = point.getZone();\n                    }\n                    if (!series.chart.polar) {\n                        point.isInside = point.isTopInside = (typeof point.plotY !== 'undefined' &&\n                            point.plotY >= 0 &&\n                            point.plotY <= series.yAxis.len && // #3519\n                            point.plotX >= 0 &&\n                            point.plotX <= series.xAxis.len);\n                    }\n                    i++;\n                }\n                // Draw top points\n                areaProto.drawPoints.apply(series, arguments);\n                // Reset top points preliminary modifications\n                i = 0;\n                while (i < pointLength) {\n                    point = series.points[i];\n                    point.graphics = point.graphics || [];\n                    if (point.graphic || point.graphics[1]) {\n                        point.graphics[1] = point.graphic;\n                    }\n                    point.graphic = point.graphics[0];\n                    if (point.origProps) {\n                        extend(point, point.origProps);\n                        delete point.origProps;\n                    }\n                    i++;\n                }\n            };\n            AreaRangeSeries.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);\n            return AreaRangeSeries;\n        }(AreaSeries));\n        addEvent(AreaRangeSeries, 'afterTranslate', function () {\n            // Set plotLow and plotHigh\n            var _this = this;\n            // Rules out lollipop, but lollipop should not inherit range series in the\n            // first place\n            if (this.pointArrayMap.join(',') === 'low,high') {\n                this.points.forEach(function (point) {\n                    var high = point.high,\n                        plotY = point.plotY;\n                    if (point.isNull) {\n                        point.plotY = void 0;\n                    }\n                    else {\n                        point.plotLow = plotY;\n                        // Calculate plotHigh value based on each yAxis scale (#15752)\n                        point.plotHigh = isNumber(high) ? _this.yAxis.translate(_this.dataModify ?\n                            _this.dataModify.modifyValue(high) : high, false, true, void 0, true) : void 0;\n                        if (_this.dataModify) {\n                            point.yBottom = point.plotHigh;\n                        }\n                    }\n                });\n            }\n        }, { order: 0 });\n        addEvent(AreaRangeSeries, 'afterTranslate', function () {\n            var _this = this;\n            var inverted = this.chart.inverted;\n            this.points.forEach(function (point) {\n                // Postprocessing after the PolarComposition's afterTranslate\n                if (_this.chart.polar) {\n                    _this.highToXY(point);\n                    point.plotLow = point.plotY;\n                    point.tooltipPos = [\n                        ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,\n                        ((point.plotHigh || 0) + (point.plotLow || 0)) / 2\n                    ];\n                    // Put the tooltip in the middle of the range\n                }\n                else {\n                    var tooltipPos = point.pos(false,\n                        point.plotLow),\n                        posHigh = point.pos(false,\n                        point.plotHigh);\n                    if (tooltipPos && posHigh) {\n                        tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;\n                        tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;\n                    }\n                    point.tooltipPos = tooltipPos;\n                }\n            });\n        }, { order: 3 });\n        extend(AreaRangeSeries.prototype, {\n            deferTranslatePolar: true,\n            pointArrayMap: ['low', 'high'],\n            pointClass: AreaRangePoint,\n            pointValKey: 'low',\n            setStackedPoints: noop\n        });\n        SeriesRegistry.registerSeriesType('arearange', AreaRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `arearange` series. If the [type](#series.arearange.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         *\n         * @extends   series,plotOptions.arearange\n         * @excluding dataParser, dataURL, stack, stacking\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.arearange\n         */\n        /**\n         * @see [fillColor](#series.arearange.fillColor)\n         * @see [fillOpacity](#series.arearange.fillOpacity)\n         *\n         * @apioption series.arearange.color\n         */\n        /**\n         * An array of data points for the series. For the `arearange` series type,\n         * points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 or 2 values. In this case, the values\n         *     correspond to `x,low,high`. If the first value is a string, it is\n         *     applied as the name of the point, and the `x` value is inferred.\n         *     The `x` value can also be omitted, in which case the inner arrays\n         *     should be of length 2\\. Then the `x` value is automatically calculated,\n         *     either starting at 0 and incremented by 1, or from `pointStart`\n         *     and `pointInterval` given in the series options.\n         *     ```js\n         *     data: [\n         *         [0, 8, 3],\n         *         [1, 1, 1],\n         *         [2, 6, 8]\n         *     ]\n         *     ```\n         *\n         * 2.  An array of objects with named values. The following snippet shows only a\n         *     few settings, see the complete options set below. If the total number of\n         *     data points exceeds the series'\n         *     [turboThreshold](#series.arearange.turboThreshold),\n         *     this option is not available.\n         *     ```js\n         *     data: [{\n         *         x: 1,\n         *         low: 9,\n         *         high: 0,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         x: 1,\n         *         low: 3,\n         *         high: 4,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *     ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.line.data\n         * @excluding marker, y\n         * @product   highcharts highstock\n         * @apioption series.arearange.data\n         */\n        /**\n         * @extends   series.arearange.dataLabels\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.dataLabels\n         */\n        /**\n         * @see [color](#series.arearange.color)\n         * @see [fillOpacity](#series.arearange.fillOpacity)\n         *\n         * @apioption series.arearange.fillColor\n         */\n        /**\n         * @see [color](#series.arearange.color)\n         * @see [fillColor](#series.arearange.fillColor)\n         *\n         * @default   {highcharts} 0.75\n         * @default   {highstock} 0.75\n         * @apioption series.arearange.fillOpacity\n         */\n        /**\n         * The high or maximum value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.high\n         */\n        /**\n         * The low or minimum value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.low\n         */\n        ''; // adds doclets above to tranpiled file\n\n        return AreaRangeSeries;\n    });\n    _registerModule(_modules, 'Series/AreaSplineRange/AreaSplineRangeSeries.js', [_modules['Series/AreaRange/AreaRangeSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (AreaRangeSeries, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var splineProto = SeriesRegistry.seriesTypes.spline.prototype;\n        var merge = U.merge,\n            extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The areasplinerange series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.areasplinerange\n         *\n         * @augments Highcharts.Series\n         */\n        var AreaSplineRangeSeries = /** @class */ (function (_super) {\n                __extends(AreaSplineRangeSeries, _super);\n            function AreaSplineRangeSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.options = void 0;\n                _this.data = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            AreaSplineRangeSeries.defaultOptions = merge(AreaRangeSeries.defaultOptions);\n            return AreaSplineRangeSeries;\n        }(AreaRangeSeries));\n        extend(AreaSplineRangeSeries.prototype, {\n            getPointSpline: splineProto.getPointSpline\n        });\n        SeriesRegistry.registerSeriesType('areasplinerange', AreaSplineRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The area spline range is a cartesian series type with higher and\n         * lower Y values along an X axis. The area inside the range is colored, and\n         * the graph outlining the area is a smoothed spline.\n         *\n         * @sample {highstock|highstock} stock/demo/areasplinerange/\n         *         Area spline range\n         *\n         * @extends   plotOptions.arearange\n         * @since     2.3.0\n         * @excluding step, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption plotOptions.areasplinerange\n         */\n        /**\n         * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n         * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n         *\n         * @apioption plotOptions.areasplinerange.color\n         */\n        /**\n         * @see [color](#plotOptions.areasplinerange.color)\n         * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n         *\n         * @apioption plotOptions.areasplinerange.fillColor\n         */\n        /**\n         * @see [color](#plotOptions.areasplinerange.color)\n         * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n         *\n         * @default   0.75\n         * @apioption plotOptions.areasplinerange.fillOpacity\n         */\n        /**\n         * A `areasplinerange` series. If the [type](#series.areasplinerange.type)\n         * option is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.areasplinerange\n         * @excluding dataParser, dataURL, stack, step, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.areasplinerange\n         */\n        /**\n         * @see [fillColor](#series.areasplinerange.fillColor)\n         * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n         *\n         * @apioption series.areasplinerange.color\n         */\n        /**\n         * An array of data points for the series. For the `areasplinerange`\n         * series type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 0, 5],\n         *        [1, 9, 1],\n         *        [2, 5, 2]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.areasplinerange.turboThreshold), this option is\n         *    not available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 5,\n         *        high: 0,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 4,\n         *        high: 1,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @product   highcharts highstock\n         * @apioption series.areasplinerange.data\n         */\n        /**\n         * @see [color](#series.areasplinerange.color)\n         * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n         *\n         * @apioption series.areasplinerange.fillColor\n         */\n        /**\n         * @see [color](#series.areasplinerange.color)\n         * @see [fillColor](#series.areasplinerange.fillColor)\n         *\n         * @default   0.75\n         * @apioption series.areasplinerange.fillOpacity\n         */\n        ''; // adds doclets above to transpiled file\n\n        return AreaSplineRangeSeries;\n    });\n    _registerModule(_modules, 'Series/BoxPlot/BoxPlotSeries.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnSeries, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var extend = U.extend,\n            merge = U.merge,\n            pick = U.pick;\n        /**\n         * The boxplot series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes#boxplot\n         *\n         * @augments Highcharts.Series\n         */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BoxPlotSeries = /** @class */ (function (_super) {\n                __extends(BoxPlotSeries, _super);\n            function BoxPlotSeries() {\n                /* *\n                 *\n                 * Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            // Get presentational attributes\n            BoxPlotSeries.prototype.pointAttribs = function () {\n                // No attributes should be set on point.graphic which is the group\n                return {};\n            };\n            // Translate data points from raw values x and y to plotX and plotY\n            BoxPlotSeries.prototype.translate = function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    pointArrayMap = series.pointArrayMap;\n                _super.prototype.translate.apply(series);\n                // do the translation on each point dimension\n                series.points.forEach(function (point) {\n                    pointArrayMap.forEach(function (key) {\n                        if (point[key] !== null) {\n                            point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n                        }\n                    });\n                    point.plotHigh = point.highPlot; // For data label validation\n                });\n            };\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Draw the data points\n             * @private\n             */\n            BoxPlotSeries.prototype.drawPoints = function () {\n                var series = this,\n                    points = series.points,\n                    options = series.options,\n                    chart = series.chart,\n                    renderer = chart.renderer,\n                    q1Plot,\n                    q3Plot,\n                    highPlot,\n                    lowPlot,\n                    medianPlot,\n                    medianPath,\n                    crispCorr,\n                    crispX = 0,\n                    boxPath,\n                    width,\n                    left,\n                    right,\n                    halfWidth, \n                    // error bar inherits this series type but doesn't do quartiles\n                    doQuartiles = series.doQuartiles !== false,\n                    pointWiskerLength,\n                    whiskerLength = series.options.whiskerLength;\n                points.forEach(function (point) {\n                    var graphic = point.graphic,\n                        verb = graphic ? 'animate' : 'attr',\n                        shapeArgs = point.shapeArgs,\n                        boxAttr = {},\n                        stemAttr = {},\n                        whiskersAttr = {},\n                        medianAttr = {},\n                        color = point.color || series.color;\n                    if (typeof point.plotY !== 'undefined') {\n                        // crisp vector coordinates\n                        width = Math.round(shapeArgs.width);\n                        left = Math.floor(shapeArgs.x);\n                        right = left + width;\n                        halfWidth = Math.round(width / 2);\n                        q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);\n                        q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);\n                        highPlot = Math.floor(point.highPlot);\n                        lowPlot = Math.floor(point.lowPlot);\n                        if (!graphic) {\n                            point.graphic = graphic = renderer.g('point')\n                                .add(series.group);\n                            point.stem = renderer.path()\n                                .addClass('highcharts-boxplot-stem')\n                                .add(graphic);\n                            if (whiskerLength) {\n                                point.whiskers = renderer.path()\n                                    .addClass('highcharts-boxplot-whisker')\n                                    .add(graphic);\n                            }\n                            if (doQuartiles) {\n                                point.box = renderer.path(boxPath)\n                                    .addClass('highcharts-boxplot-box')\n                                    .add(graphic);\n                            }\n                            point.medianShape = renderer.path(medianPath)\n                                .addClass('highcharts-boxplot-median')\n                                .add(graphic);\n                        }\n                        if (!chart.styledMode) {\n                            // Stem attributes\n                            stemAttr.stroke =\n                                point.stemColor || options.stemColor || color;\n                            stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n                            stemAttr.dashstyle = (point.stemDashStyle ||\n                                options.stemDashStyle ||\n                                options.dashStyle);\n                            point.stem.attr(stemAttr);\n                            // Whiskers attributes\n                            if (whiskerLength) {\n                                whiskersAttr.stroke = (point.whiskerColor ||\n                                    options.whiskerColor ||\n                                    color);\n                                whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n                                whiskersAttr.dashstyle = (point.whiskerDashStyle ||\n                                    options.whiskerDashStyle ||\n                                    options.dashStyle);\n                                point.whiskers.attr(whiskersAttr);\n                            }\n                            if (doQuartiles) {\n                                boxAttr.fill = (point.fillColor ||\n                                    options.fillColor ||\n                                    color);\n                                boxAttr.stroke = options.lineColor || color;\n                                boxAttr['stroke-width'] = options.lineWidth || 0;\n                                boxAttr.dashstyle = (point.boxDashStyle ||\n                                    options.boxDashStyle ||\n                                    options.dashStyle);\n                                point.box.attr(boxAttr);\n                            }\n                            // Median attributes\n                            medianAttr.stroke = (point.medianColor ||\n                                options.medianColor ||\n                                color);\n                            medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n                            medianAttr.dashstyle = (point.medianDashStyle ||\n                                options.medianDashStyle ||\n                                options.dashStyle);\n                            point.medianShape.attr(medianAttr);\n                        }\n                        var d = void 0;\n                        // The stem\n                        crispCorr = (point.stem.strokeWidth() % 2) / 2;\n                        crispX = left + halfWidth + crispCorr;\n                        d = [\n                            // stem up\n                            ['M', crispX, q3Plot],\n                            ['L', crispX, highPlot],\n                            // stem down\n                            ['M', crispX, q1Plot],\n                            ['L', crispX, lowPlot]\n                        ];\n                        point.stem[verb]({ d: d });\n                        // The box\n                        if (doQuartiles) {\n                            crispCorr = (point.box.strokeWidth() % 2) / 2;\n                            q1Plot = Math.floor(q1Plot) + crispCorr;\n                            q3Plot = Math.floor(q3Plot) + crispCorr;\n                            left += crispCorr;\n                            right += crispCorr;\n                            d = [\n                                ['M', left, q3Plot],\n                                ['L', left, q1Plot],\n                                ['L', right, q1Plot],\n                                ['L', right, q3Plot],\n                                ['L', left, q3Plot],\n                                ['Z']\n                            ];\n                            point.box[verb]({ d: d });\n                        }\n                        // The whiskers\n                        if (whiskerLength) {\n                            crispCorr = (point.whiskers.strokeWidth() % 2) / 2;\n                            highPlot = highPlot + crispCorr;\n                            lowPlot = lowPlot + crispCorr;\n                            pointWiskerLength = (/%$/).test(whiskerLength) ?\n                                halfWidth * parseFloat(whiskerLength) / 100 :\n                                whiskerLength / 2;\n                            d = [\n                                // High whisker\n                                ['M', crispX - pointWiskerLength, highPlot],\n                                ['L', crispX + pointWiskerLength, highPlot],\n                                // Low whisker\n                                ['M', crispX - pointWiskerLength, lowPlot],\n                                ['L', crispX + pointWiskerLength, lowPlot]\n                            ];\n                            point.whiskers[verb]({ d: d });\n                        }\n                        // The median\n                        medianPlot = Math.round(point.medianPlot);\n                        crispCorr = (point.medianShape.strokeWidth() % 2) / 2;\n                        medianPlot = medianPlot + crispCorr;\n                        d = [\n                            ['M', left, medianPlot],\n                            ['L', right, medianPlot]\n                        ];\n                        point.medianShape[verb]({ d: d });\n                    }\n                });\n            };\n            // return a plain array for speedy calculation\n            BoxPlotSeries.prototype.toYData = function (point) {\n                return [point.low, point.q1, point.median, point.q3, point.high];\n            };\n            /**\n             * A box plot is a convenient way of depicting groups of data through their\n             * five-number summaries: the smallest observation (sample minimum), lower\n             * quartile (Q1), median (Q2), upper quartile (Q3), and largest observation\n             * (sample maximum).\n             *\n             * @sample highcharts/demo/box-plot/\n             *         Box plot\n             *\n             * @extends      plotOptions.column\n             * @excluding    borderColor, borderRadius, borderWidth, groupZPadding,\n             *               states, boostThreshold, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.boxplot\n             */\n            BoxPlotSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n                /**\n                 * @type {number|null}\n                 */\n                threshold: null,\n                tooltip: {\n                    pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b>' +\n                        '{series.name}</b><br/>' +\n                        'Maximum: {point.high}<br/>' +\n                        'Upper quartile: {point.q3}<br/>' +\n                        'Median: {point.median}<br/>' +\n                        'Lower quartile: {point.q1}<br/>' +\n                        'Minimum: {point.low}<br/>'\n                },\n                /**\n                 * The length of the whiskers, the horizontal lines marking low and\n                 * high values. It can be a numerical pixel value, or a percentage\n                 * value of the box width. Set `0` to disable whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         True by default\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerLength: '50%',\n                /**\n                 * The fill color of the box.\n                 *\n                 * In styled mode, the fill color can be set with the\n                 * `.highcharts-boxplot-box` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @default #ffffff\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                fillColor: \"#ffffff\" /* Palette.backgroundColor */,\n                /**\n                 * The width of the line surrounding the box. If any of\n                 * [stemWidth](#plotOptions.boxplot.stemWidth),\n                 * [medianWidth](#plotOptions.boxplot.medianWidth)\n                 * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,\n                 * the lineWidth also applies to these lines.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                lineWidth: 1,\n                /**\n                 * The color of the median line. If `undefined`, the general series\n                 * color applies.\n                 *\n                 * In styled mode, the median stroke width can be set with the\n                 * `.highcharts-boxplot-median` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.medianColor\n                 */\n                /**\n                 * The pixel width of the median line. If `null`, the\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) is used.\n                 *\n                 * In styled mode, the median stroke width can be set with the\n                 * `.highcharts-boxplot-median` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type    {number|null}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                medianWidth: 2,\n                /*\n                // States are not working and are removed from docs.\n                // Refer to: #2340\n                states: {\n                    hover: {\n                        brightness: -0.3\n                    }\n                },\n                */\n                /**\n                 * The color of the stem, the vertical line extending from the box to\n                 * the whiskers. If `undefined`, the series color is used.\n                 *\n                 * In styled mode, the stem stroke can be set with the\n                 * `.highcharts-boxplot-stem` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemColor\n                 */\n                /**\n                 * The dash style of the box.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.boxDashStyle\n                 */\n                /**\n                 * The dash style of the median.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.medianDashStyle\n                 */\n                /**\n                 * The dash style of the stem, the vertical line extending from the\n                 * box to the whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemDashStyle\n                 */\n                /**\n                 * The dash style of the whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.whiskerDashStyle\n                 */\n                /**\n                 * The width of the stem, the vertical line extending from the box to\n                 * the whiskers. If `undefined`, the width is inherited from the\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) option.\n                 *\n                 * In styled mode, the stem stroke width can be set with the\n                 * `.highcharts-boxplot-stem` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {number}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemWidth\n                 */\n                /**\n                 * @default   high\n                 * @apioption plotOptions.boxplot.colorKey\n                 */\n                /**\n                 * The color of the whiskers, the horizontal lines marking low and high\n                 * values. When `undefined`, the general series color is used.\n                 *\n                 * In styled mode, the whisker stroke can be set with the\n                 * `.highcharts-boxplot-whisker` class .\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.whiskerColor\n                 */\n                /**\n                 * The line width of the whiskers, the horizontal lines marking low and\n                 * high values. When `undefined`, the general\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) applies.\n                 *\n                 * In styled mode, the whisker stroke width can be set with the\n                 * `.highcharts-boxplot-whisker` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerWidth: 2\n            });\n            return BoxPlotSeries;\n        }(ColumnSeries));\n        extend(BoxPlotSeries.prototype, {\n            // array point configs are mapped to this\n            pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],\n            // defines the top of the tracker\n            pointValKey: 'high',\n            // Disable data labels for box plot\n            drawDataLabels: noop,\n            setStackedPoints: noop // #3890\n        });\n        /* *\n         *\n         * Registry\n         *\n         * */\n        SeriesRegistry.registerSeriesType('boxplot', BoxPlotSeries);\n        /* *\n         *\n         * Default Export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `boxplot` series. If the [type](#series.boxplot.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.boxplot\n         * @excluding dataParser, dataURL, marker, stack, stacking, states,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.boxplot\n         */\n        /**\n         * An array of data points for the series. For the `boxplot` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 6 or 5 values. In this case, the values correspond\n         *    to `x,low,q1,median,q3,high`. If the first value is a string, it is\n         *    applied as the name of the point, and the `x` value is inferred. The `x`\n         *    value can also be omitted, in which case the inner arrays should be of\n         *    length 5. Then the `x` value is automatically calculated, either starting\n         *    at 0 and incremented by 1, or from `pointStart` and `pointInterval` given\n         *    in the series options.\n         *    ```js\n         *    data: [\n         *        [0, 3, 0, 10, 3, 5],\n         *        [1, 7, 8, 7, 2, 9],\n         *        [2, 6, 9, 5, 1, 3]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.boxplot.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 4,\n         *        q1: 9,\n         *        median: 9,\n         *        q3: 1,\n         *        high: 10,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        q1: 7,\n         *        median: 3,\n         *        q3: 6,\n         *        high: 2,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number,number,number,number>|Array<(number|string),number,number,number,number,number>|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts\n         * @apioption series.boxplot.data\n         */\n        /**\n         * The `high` value for each data point, signifying the highest value\n         * in the sample set. The top whisker is drawn here.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.high\n         */\n        /**\n         * The `low` value for each data point, signifying the lowest value\n         * in the sample set. The bottom whisker is drawn here.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.low\n         */\n        /**\n         * The median for each data point. This is drawn as a line through the\n         * middle area of the box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.median\n         */\n        /**\n         * The lower quartile for each data point. This is the bottom of the\n         * box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.q1\n         */\n        /**\n         * The higher quartile for each data point. This is the top of the box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.q3\n         */\n        /**\n         * The dash style of the box.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.boxDashStyle\n         */\n        /**\n         * The dash style of the median.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.medianDashStyle\n         */\n        /**\n         * The dash style of the stem.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.stemDashStyle\n         */\n        /**\n         * The dash style of the whiskers.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.whiskerDashStyle\n         */\n        ''; // adds doclets above to transpiled file\n\n        return BoxPlotSeries;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The bubble legend is an additional element in legend which\n         * presents the scale of the bubble series. Individual bubble ranges\n         * can be defined by user or calculated from series. In the case of\n         * automatically calculated ranges, a 1px margin of error is\n         * permitted.\n         *\n         * @since        7.0.0\n         * @product      highcharts highstock highmaps\n         * @requires     highcharts-more\n         * @optionparent legend.bubbleLegend\n         */\n        var BubbleLegendDefaults = {\n                /**\n                 * The color of the ranges borders,\n            can be also defined for an\n                 * individual range.\n                 *\n                 * @sample highcharts/bubble-legend/similartoseries/\n                 *         Similar look to the bubble series\n                 * @sample highcharts/bubble-legend/bordercolor/\n                 *         Individual bubble border color\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                borderColor: void 0,\n                /**\n                 * The width of the ranges borders in pixels,\n            can be also\n                 * defined for an individual range.\n                 */\n                borderWidth: 2,\n                /**\n                 * An additional class name to apply to the bubble legend'\n                 * circle graphical elements. This option does not replace\n                 * default class names of the graphical element.\n                 *\n                 * @sample {highcharts} highcharts/css/bubble-legend/\n                 *         Styling by CSS\n                 *\n                 * @type {string}\n                 */\n                className: void 0,\n                /**\n                 * The main color of the bubble legend. Applies to ranges,\n            if\n                 * individual color is not defined.\n                 *\n                 * @sample highcharts/bubble-legend/similartoseries/\n                 *         Similar look to the bubble series\n                 * @sample highcharts/bubble-legend/color/\n                 *         Individual bubble color\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                color: void 0,\n                /**\n                 * An additional class name to apply to the bubble legend's\n                 * connector graphical elements. This option does not replace\n                 * default class names of the graphical element.\n                 *\n                 * @sample {highcharts} highcharts/css/bubble-legend/\n                 *         Styling by CSS\n                 *\n                 * @type {string}\n                 */\n                connectorClassName: void 0,\n                /**\n                 * The color of the connector,\n            can be also defined\n                 * for an individual range.\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                connectorColor: void 0,\n                /**\n                 * The length of the connectors in pixels. If labels are\n                 * centered,\n            the distance is reduced to 0.\n                 *\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Increased connector length\n                 */\n                connectorDistance: 60,\n                /**\n                 * The width of the connectors in pixels.\n                 *\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Increased connector width\n                 */\n                connectorWidth: 1,\n                /**\n                 * Enable or disable the bubble legend.\n                 */\n                enabled: false,\n                /**\n                 * Options for the bubble legend labels.\n                 */\n                labels: {\n                    /**\n                     * An additional class name to apply to the bubble legend\n                     * label graphical elements. This option does not replace\n                     * default class names of the graphical element.\n                     *\n                     * @sample {highcharts} highcharts/css/bubble-legend/\n                     *         Styling by CSS\n                     *\n                     * @type {string}\n                     */\n                    className: void 0,\n                    /**\n                     * Whether to allow data labels to overlap.\n                     */\n                    allowOverlap: false,\n                    /**\n                     * A format string for the bubble legend labels. Available\n                     * variables are the same as for `formatter`.\n                     *\n                     * @sample highcharts/bubble-legend/format/\n                     *         Add a unit\n                     *\n                     * @type {string}\n                     */\n                    format: '',\n                    /**\n                     * Available `this` properties are:\n                     *\n                     * - `this.value`: The bubble value.\n                     *\n                     * - `this.radius`: The radius of the bubble range.\n                     *\n                     * - `this.center`: The center y position of the range.\n                     *\n                     * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}\n                     */\n                    formatter: void 0,\n                    /**\n                     * The alignment of the labels compared to the bubble\n                     * legend. Can be one of `left`,\n            `center` or `right`.\n                     *\n                     * @sample highcharts/bubble-legend/connectorandlabels/\n                     *         Labels on left\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'right',\n                    /**\n                     * CSS styles for the labels.\n                     *\n                     * @type {Highcharts.CSSObject}\n                     */\n                    style: {\n                        /** @ignore-option */\n                        fontSize: '10px',\n                        /** @ignore-option */\n                        color: \"#000000\" /* Palette.neutralColor100 */\n                    },\n                    /**\n                     * The x position offset of the label relative to the\n                     * connector.\n                     */\n                    x: 0,\n                    /**\n                     * The y position offset of the label relative to the\n                     * connector.\n                     */\n                    y: 0\n                },\n                /**\n                 * Miximum bubble legend range size. If values for ranges are\n                 * not specified,\n            the `minSize` and the `maxSize` are calculated\n                 * from bubble series.\n                 */\n                maxSize: 60,\n                /**\n                 * Minimum bubble legend range size. If values for ranges are\n                 * not specified,\n            the `minSize` and the `maxSize` are calculated\n                 * from bubble series.\n                 */\n                minSize: 10,\n                /**\n                 * The position of the bubble legend in the legend.\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Bubble legend as last item in legend\n                 */\n                legendIndex: 0,\n                /**\n                 * Options for specific range. One range consists of bubble,\n                 * label and connector.\n                 *\n                 * @sample highcharts/bubble-legend/ranges/\n                 *         Manually defined ranges\n                 * @sample highcharts/bubble-legend/autoranges/\n                 *         Auto calculated ranges\n                 *\n                 * @type {Array<*>}\n                 */\n                ranges: {\n                    /**\n                     * Range size value,\n            similar to bubble Z data.\n                     * @type {number}\n                     */\n                    value: void 0,\n                    /**\n                     * The color of the border for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    borderColor: void 0,\n                    /**\n                     * The color of the bubble for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    color: void 0,\n                    /**\n                     * The color of the connector for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    connectorColor: void 0\n                },\n                /**\n                 * Whether the bubble legend range value should be represented\n                 * by the area or the width of the bubble. The default,\n            area,\n                 * corresponds best to the human perception of the size of each\n                 * bubble.\n                 *\n                 * @sample highcharts/bubble-legend/ranges/\n                 *         Size by width\n                 *\n                 * @type {Highcharts.BubbleSizeByValue}\n                 */\n                sizeBy: 'area',\n                /**\n                 * When this is true,\n            the absolute value of z determines the\n                 * size of the bubble. This means that with the default\n                 * zThreshold of 0,\n            a bubble of value -1 will have the same size\n                 * as a bubble of value 1,\n            while a bubble of value 0 will have a\n                 * smaller size according to minSize.\n                 */\n                sizeByAbsoluteValue: false,\n                /**\n                 * Define the visual z index of the bubble legend.\n                 */\n                zIndex: 1,\n                /**\n                 * Ranges with with lower value than zThreshold,\n            are skipped.\n                 */\n                zThreshold: 0\n            };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BubbleLegendDefaults;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendItem.js', [_modules['Core/Color/Color.js'], _modules['Core/FormatUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Color, F, H, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var color = Color.parse;\n        var noop = H.noop;\n        var arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick,\n            stableSort = U.stableSort;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * BubbleLegend class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.BubbleLegend\n         * @param {Highcharts.LegendBubbleLegendOptions} options\n         * Options of BubbleLegendItem.\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend of item.\n         */\n        var BubbleLegendItem = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function BubbleLegendItem(options, legend) {\n                    /* *\n                     *\n                     *  Properties\n                     *\n                     * */\n                    this.chart = void 0;\n                this.fontMetrics = void 0;\n                this.legend = void 0;\n                this.maxLabel = void 0;\n                this.movementX = void 0;\n                this.ranges = void 0;\n                this.selected = void 0;\n                this.visible = void 0;\n                this.symbols = void 0;\n                this.options = void 0;\n                this.setState = noop;\n                this.init(options, legend);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Create basic bubbleLegend properties similar to item in legend.\n             * @private\n             */\n            BubbleLegendItem.prototype.init = function (options, legend) {\n                this.options = options;\n                this.visible = true;\n                this.chart = legend.chart;\n                this.legend = legend;\n            };\n            /**\n             * Depending on the position option, add bubbleLegend to legend items.\n             *\n             * @private\n             *\n             * @param {Array<(Highcharts.Point|Highcharts.Series)>} items\n             *        All legend items\n             */\n            BubbleLegendItem.prototype.addToLegend = function (items) {\n                // Insert bubbleLegend into legend items\n                items.splice(this.options.legendIndex, 0, this);\n            };\n            /**\n             * Calculate ranges, sizes and call the next steps of bubbleLegend\n             * creation.\n             *\n             * @private\n             *\n             * @param {Highcharts.Legend} legend\n             *        Legend instance\n             */\n            BubbleLegendItem.prototype.drawLegendSymbol = function (legend) {\n                var chart = this.chart,\n                    itemDistance = pick(legend.options.itemDistance, 20),\n                    legendItem = this.legendItem || {},\n                    options = this.options,\n                    ranges = options.ranges,\n                    connectorDistance = options.connectorDistance;\n                var connectorSpace;\n                // Predict label dimensions\n                this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);\n                // Do not create bubbleLegend now if ranges or ranges valeus are not\n                // specified or if are empty array.\n                if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {\n                    legend.options.bubbleLegend.autoRanges = true;\n                    return;\n                }\n                // Sort ranges to right render order\n                stableSort(ranges, function (a, b) {\n                    return b.value - a.value;\n                });\n                this.ranges = ranges;\n                this.setOptions();\n                this.render();\n                // Get max label size\n                var maxLabel = this.getMaxLabelSize(),\n                    radius = this.ranges[0].radius,\n                    size = radius * 2;\n                // Space for connectors and labels.\n                connectorSpace =\n                    connectorDistance - radius + maxLabel.width;\n                connectorSpace = connectorSpace > 0 ? connectorSpace : 0;\n                this.maxLabel = maxLabel;\n                this.movementX = options.labels.align === 'left' ?\n                    connectorSpace : 0;\n                legendItem.labelWidth = size + connectorSpace + itemDistance;\n                legendItem.labelHeight = size + this.fontMetrics.h / 2;\n            };\n            /**\n             * Set style options for each bubbleLegend range.\n             * @private\n             */\n            BubbleLegendItem.prototype.setOptions = function () {\n                var ranges = this.ranges,\n                    options = this.options,\n                    series = this.chart.series[options.seriesIndex],\n                    baseline = this.legend.baseline,\n                    bubbleAttribs = {\n                        zIndex: options.zIndex,\n                        'stroke-width': options.borderWidth\n                    },\n                    connectorAttribs = {\n                        zIndex: options.zIndex,\n                        'stroke-width': options.connectorWidth\n                    },\n                    labelAttribs = {\n                        align: (this.legend.options.rtl ||\n                            options.labels.align === 'left') ? 'right' : 'left',\n                        zIndex: options.zIndex\n                    },\n                    fillOpacity = series.options.marker.fillOpacity,\n                    styledMode = this.chart.styledMode;\n                // Allow to parts of styles be used individually for range\n                ranges.forEach(function (range, i) {\n                    if (!styledMode) {\n                        bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);\n                        bubbleAttribs.fill = pick(range.color, options.color, fillOpacity !== 1 ?\n                            color(series.color).setOpacity(fillOpacity)\n                                .get('rgba') :\n                            series.color);\n                        connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color);\n                    }\n                    // Set options needed for rendering each range\n                    ranges[i].radius = this.getRangeRadius(range.value);\n                    ranges[i] = merge(ranges[i], {\n                        center: (ranges[0].radius - ranges[i].radius +\n                            baseline)\n                    });\n                    if (!styledMode) {\n                        merge(true, ranges[i], {\n                            bubbleAttribs: merge(bubbleAttribs),\n                            connectorAttribs: merge(connectorAttribs),\n                            labelAttribs: labelAttribs\n                        });\n                    }\n                }, this);\n            };\n            /**\n             * Calculate radius for each bubble range,\n             * used code from BubbleSeries.js 'getRadius' method.\n             *\n             * @private\n             *\n             * @param {number} value\n             *        Range value\n             *\n             * @return {number|null}\n             *         Radius for one range\n             */\n            BubbleLegendItem.prototype.getRangeRadius = function (value) {\n                var options = this.options,\n                    seriesIndex = this.options.seriesIndex,\n                    bubbleSeries = this.chart.series[seriesIndex],\n                    zMax = options.ranges[0].value,\n                    zMin = options.ranges[options.ranges.length - 1].value,\n                    minSize = options.minSize,\n                    maxSize = options.maxSize;\n                return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);\n            };\n            /**\n             * Render the legendItem group.\n             * @private\n             */\n            BubbleLegendItem.prototype.render = function () {\n                var legendItem = this.legendItem || {},\n                    renderer = this.chart.renderer,\n                    zThreshold = this.options.zThreshold;\n                if (!this.symbols) {\n                    this.symbols = {\n                        connectors: [],\n                        bubbleItems: [],\n                        labels: []\n                    };\n                }\n                // Nesting SVG groups to enable handleOverflow\n                legendItem.symbol = renderer.g('bubble-legend');\n                legendItem.label = renderer.g('bubble-legend-item');\n                // To enable default 'hideOverlappingLabels' method\n                legendItem.symbol.translateX = 0;\n                legendItem.symbol.translateY = 0;\n                for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n                    var range = _a[_i];\n                    if (range.value >= zThreshold) {\n                        this.renderRange(range);\n                    }\n                }\n                // To use handleOverflow method\n                legendItem.symbol.add(legendItem.label);\n                legendItem.label.add(legendItem.group);\n                this.hideOverlappingLabels();\n            };\n            /**\n             * Render one range, consisting of bubble symbol, connector and label.\n             *\n             * @private\n             *\n             * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n             *        Range options\n             */\n            BubbleLegendItem.prototype.renderRange = function (range) {\n                var mainRange = this.ranges[0],\n                    legend = this.legend,\n                    options = this.options,\n                    labelsOptions = options.labels,\n                    chart = this.chart,\n                    bubbleSeries = chart.series[options.seriesIndex],\n                    renderer = chart.renderer,\n                    symbols = this.symbols,\n                    labels = symbols.labels,\n                    elementCenter = range.center,\n                    absoluteRadius = Math.abs(range.radius),\n                    connectorDistance = options.connectorDistance || 0,\n                    labelsAlign = labelsOptions.align,\n                    rtl = legend.options.rtl,\n                    borderWidth = options.borderWidth,\n                    connectorWidth = options.connectorWidth,\n                    posX = mainRange.radius || 0,\n                    posY = elementCenter - absoluteRadius -\n                        borderWidth / 2 + connectorWidth / 2,\n                    fontMetrics = this.fontMetrics,\n                    labelMovement = fontMetrics.f / 2 -\n                        (fontMetrics.h - fontMetrics.f) / 2,\n                    crispMovement = (posY % 1 ? 1 : 0.5) -\n                        (connectorWidth % 2 ? 0 : 0.5),\n                    styledMode = renderer.styledMode;\n                var connectorLength = rtl || labelsAlign === 'left' ?\n                        -connectorDistance : connectorDistance;\n                // Set options for centered labels\n                if (labelsAlign === 'center') {\n                    connectorLength = 0; // do not use connector\n                    options.connectorDistance = 0;\n                    range.labelAttribs.align = 'center';\n                }\n                var labelY = posY + options.labels.y,\n                    labelX = posX + connectorLength + options.labels.x;\n                // Render bubble symbol\n                symbols.bubbleItems.push(renderer\n                    .circle(posX, elementCenter + crispMovement, absoluteRadius)\n                    .attr(styledMode ? {} : range.bubbleAttribs)\n                    .addClass((styledMode ?\n                    'highcharts-color-' +\n                        bubbleSeries.colorIndex + ' ' :\n                    '') +\n                    'highcharts-bubble-legend-symbol ' +\n                    (options.className || '')).add(this.legendItem.symbol));\n                // Render connector\n                symbols.connectors.push(renderer\n                    .path(renderer.crispLine([\n                    ['M', posX, posY],\n                    ['L', posX + connectorLength, posY]\n                ], options.connectorWidth))\n                    .attr((styledMode ? {} : range.connectorAttribs))\n                    .addClass((styledMode ?\n                    'highcharts-color-' +\n                        this.options.seriesIndex + ' ' : '') +\n                    'highcharts-bubble-legend-connectors ' +\n                    (options.connectorClassName || '')).add(this.legendItem.symbol));\n                // Render label\n                var label = renderer\n                        .text(this.formatLabel(range),\n                    labelX,\n                    labelY + labelMovement)\n                        .attr((styledMode ? {} : range.labelAttribs))\n                        .css(styledMode ? {} : labelsOptions.style)\n                        .addClass('highcharts-bubble-legend-labels ' +\n                        (options.labels.className || '')).add(this.legendItem.symbol);\n                labels.push(label);\n                // To enable default 'hideOverlappingLabels' method\n                label.placed = true;\n                label.alignAttr = {\n                    x: labelX,\n                    y: labelY + labelMovement\n                };\n            };\n            /**\n             * Get the label which takes up the most space.\n             * @private\n             */\n            BubbleLegendItem.prototype.getMaxLabelSize = function () {\n                var labels = this.symbols.labels;\n                var maxLabel,\n                    labelSize;\n                labels.forEach(function (label) {\n                    labelSize = label.getBBox(true);\n                    if (maxLabel) {\n                        maxLabel = labelSize.width > maxLabel.width ?\n                            labelSize : maxLabel;\n                    }\n                    else {\n                        maxLabel = labelSize;\n                    }\n                });\n                return maxLabel || {};\n            };\n            /**\n             * Get formatted label for range.\n             *\n             * @private\n             *\n             * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n             *        Range options\n             *\n             * @return {string}\n             *         Range label text\n             */\n            BubbleLegendItem.prototype.formatLabel = function (range) {\n                var options = this.options,\n                    formatter = options.labels.formatter,\n                    format = options.labels.format;\n                var numberFormatter = this.chart.numberFormatter;\n                return format ? F.format(format, range) :\n                    formatter ? formatter.call(range) :\n                        numberFormatter(range.value, 1);\n            };\n            /**\n             * By using default chart 'hideOverlappingLabels' method, hide or show\n             * labels and connectors.\n             * @private\n             */\n            BubbleLegendItem.prototype.hideOverlappingLabels = function () {\n                var chart = this.chart,\n                    allowOverlap = this.options.labels.allowOverlap,\n                    symbols = this.symbols;\n                if (!allowOverlap && symbols) {\n                    chart.hideOverlappingLabels(symbols.labels);\n                    // Hide or show connectors\n                    symbols.labels.forEach(function (label, index) {\n                        if (!label.newOpacity) {\n                            symbols.connectors[index].hide();\n                        }\n                        else if (label.newOpacity !== label.oldOpacity) {\n                            symbols.connectors[index].show();\n                        }\n                    });\n                }\n            };\n            /**\n             * Calculate ranges from created series.\n             *\n             * @private\n             *\n             * @return {Array<Highcharts.LegendBubbleLegendRangesOptions>}\n             *         Array of range objects\n             */\n            BubbleLegendItem.prototype.getRanges = function () {\n                var bubbleLegend = this.legend.bubbleLegend,\n                    series = bubbleLegend.chart.series,\n                    rangesOptions = bubbleLegend.options.ranges;\n                var ranges,\n                    zData,\n                    minZ = Number.MAX_VALUE,\n                    maxZ = -Number.MAX_VALUE;\n                series.forEach(function (s) {\n                    // Find the min and max Z, like in bubble series\n                    if (s.isBubble && !s.ignoreSeries) {\n                        zData = s.zData.filter(isNumber);\n                        if (zData.length) {\n                            minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === false ?\n                                s.options.zThreshold :\n                                -Number.MAX_VALUE)));\n                            maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)));\n                        }\n                    }\n                });\n                // Set values for ranges\n                if (minZ === maxZ) {\n                    // Only one range if min and max values are the same.\n                    ranges = [{ value: maxZ }];\n                }\n                else {\n                    ranges = [\n                        { value: minZ },\n                        { value: (minZ + maxZ) / 2 },\n                        { value: maxZ, autoRanges: true }\n                    ];\n                }\n                // Prevent reverse order of ranges after redraw\n                if (rangesOptions.length && rangesOptions[0].radius) {\n                    ranges.reverse();\n                }\n                // Merge ranges values with user options\n                ranges.forEach(function (range, i) {\n                    if (rangesOptions && rangesOptions[i]) {\n                        ranges[i] = merge(rangesOptions[i], range);\n                    }\n                });\n                return ranges;\n            };\n            /**\n             * Calculate bubble legend sizes from rendered series.\n             *\n             * @private\n             *\n             * @return {Array<number,number>}\n             *         Calculated min and max bubble sizes\n             */\n            BubbleLegendItem.prototype.predictBubbleSizes = function () {\n                var chart = this.chart,\n                    fontMetrics = this.fontMetrics,\n                    legendOptions = chart.legend.options,\n                    floating = legendOptions.floating,\n                    horizontal = legendOptions.layout === 'horizontal',\n                    lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0,\n                    plotSizeX = chart.plotSizeX,\n                    plotSizeY = chart.plotSizeY,\n                    bubbleSeries = chart.series[this.options.seriesIndex],\n                    pxSizes = bubbleSeries.getPxExtremes(),\n                    minSize = Math.ceil(pxSizes.minPxSize),\n                    maxPxSize = Math.ceil(pxSizes.maxPxSize),\n                    plotSize = Math.min(plotSizeY,\n                    plotSizeX);\n                var calculatedSize,\n                    maxSize = bubbleSeries.options.maxSize;\n                // Calculate prediceted max size of bubble\n                if (floating || !(/%$/.test(maxSize))) {\n                    calculatedSize = maxPxSize;\n                }\n                else {\n                    maxSize = parseFloat(maxSize);\n                    calculatedSize = ((plotSize + lastLineHeight -\n                        fontMetrics.h / 2) * maxSize / 100) / (maxSize / 100 + 1);\n                    // Get maxPxSize from bubble series if calculated bubble legend\n                    // size will not affect to bubbles series.\n                    if ((horizontal && plotSizeY - calculatedSize >=\n                        plotSizeX) || (!horizontal && plotSizeX -\n                        calculatedSize >= plotSizeY)) {\n                        calculatedSize = maxPxSize;\n                    }\n                }\n                return [minSize, Math.ceil(calculatedSize)];\n            };\n            /**\n             * Correct ranges with calculated sizes.\n             * @private\n             */\n            BubbleLegendItem.prototype.updateRanges = function (min, max) {\n                var bubbleLegendOptions = this.legend.options.bubbleLegend;\n                bubbleLegendOptions.minSize = min;\n                bubbleLegendOptions.maxSize = max;\n                bubbleLegendOptions.ranges = this.getRanges();\n            };\n            /**\n             * Because of the possibility of creating another legend line, predicted\n             * bubble legend sizes may differ by a few pixels, so it is necessary to\n             * correct them.\n             * @private\n             */\n            BubbleLegendItem.prototype.correctSizes = function () {\n                var legend = this.legend,\n                    chart = this.chart,\n                    bubbleSeries = chart.series[this.options.seriesIndex],\n                    pxSizes = bubbleSeries.getPxExtremes(),\n                    bubbleSeriesSize = pxSizes.maxPxSize,\n                    bubbleLegendSize = this.options.maxSize;\n                if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) >\n                    1) {\n                    this.updateRanges(this.options.minSize, pxSizes.maxPxSize);\n                    legend.render();\n                }\n            };\n            return BubbleLegendItem;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @interface Highcharts.BubbleLegendFormatterContextObject\n         */ /**\n        * The center y position of the range.\n        * @name Highcharts.BubbleLegendFormatterContextObject#center\n        * @type {number}\n        */ /**\n        * The radius of the bubble range.\n        * @name Highcharts.BubbleLegendFormatterContextObject#radius\n        * @type {number}\n        */ /**\n        * The bubble value.\n        * @name Highcharts.BubbleLegendFormatterContextObject#value\n        * @type {number}\n        */\n        ''; // detach doclets above\n\n        return BubbleLegendItem;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendComposition.js', [_modules['Series/Bubble/BubbleLegendDefaults.js'], _modules['Series/Bubble/BubbleLegendItem.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (BubbleLegendDefaults, BubbleLegendItem, D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setOptions = D.setOptions;\n        var addEvent = U.addEvent,\n            objectEach = U.objectEach,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * If ranges are not specified, determine ranges from rendered bubble series\n         * and render legend again.\n         */\n        function chartDrawChartBox(proceed, options, callback) {\n            var chart = this,\n                legend = chart.legend,\n                bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;\n            var bubbleLegendOptions,\n                bubbleSizes,\n                legendItem;\n            if (legend && legend.options.enabled && legend.bubbleLegend &&\n                legend.options.bubbleLegend.autoRanges && bubbleSeries) {\n                bubbleLegendOptions = legend.bubbleLegend.options;\n                bubbleSizes = legend.bubbleLegend.predictBubbleSizes();\n                legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);\n                // Disable animation on init\n                if (!bubbleLegendOptions.placed) {\n                    legend.group.placed = false;\n                    legend.allItems.forEach(function (item) {\n                        legendItem = item.legendItem || {};\n                        if (legendItem.group) {\n                            legendItem.group.translateY = null;\n                        }\n                    });\n                }\n                // Create legend with bubbleLegend\n                legend.render();\n                chart.getMargins();\n                chart.axes.forEach(function (axis) {\n                    if (axis.visible) { // #11448\n                        axis.render();\n                    }\n                    if (!bubbleLegendOptions.placed) {\n                        axis.setScale();\n                        axis.updateNames();\n                        // Disable axis animation on init\n                        objectEach(axis.ticks, function (tick) {\n                            tick.isNew = true;\n                            tick.isNewLabel = true;\n                        });\n                    }\n                });\n                bubbleLegendOptions.placed = true;\n                // After recalculate axes, calculate margins again.\n                chart.getMargins();\n                // Call default 'drawChartBox' method.\n                proceed.call(chart, options, callback);\n                // Check bubble legend sizes and correct them if necessary.\n                legend.bubbleLegend.correctSizes();\n                // Correct items positions with different dimensions in legend.\n                retranslateItems(legend, getLinesHeights(legend));\n            }\n            else {\n                proceed.call(chart, options, callback);\n                // Allow color change on static bubble legend after click on legend\n                if (legend && legend.options.enabled && legend.bubbleLegend) {\n                    legend.render();\n                    retranslateItems(legend, getLinesHeights(legend));\n                }\n            }\n        }\n        /**\n         * Compose classes for use with Bubble series.\n         * @private\n         *\n         * @param {Highcharts.Chart} ChartClass\n         * Core chart class to use with Bubble series.\n         *\n         * @param {Highcharts.Legend} LegendClass\n         * Core legend class to use with Bubble series.\n         *\n         * @param {Highcharts.Series} SeriesClass\n         * Core series class to use with Bubble series.\n         */\n        function compose(ChartClass, LegendClass, SeriesClass) {\n            if (composedClasses.indexOf(ChartClass) === -1) {\n                composedClasses.push(ChartClass);\n                setOptions({\n                    // Set default bubble legend options\n                    legend: {\n                        bubbleLegend: BubbleLegendDefaults\n                    }\n                });\n                wrap(ChartClass.prototype, 'drawChartBox', chartDrawChartBox);\n            }\n            if (composedClasses.indexOf(LegendClass) === -1) {\n                composedClasses.push(LegendClass);\n                addEvent(LegendClass, 'afterGetAllItems', onLegendAfterGetAllItems);\n            }\n            if (composedClasses.indexOf(SeriesClass) === -1) {\n                composedClasses.push(SeriesClass);\n                addEvent(SeriesClass, 'legendItemClick', onSeriesLegendItemClick);\n            }\n        }\n        /**\n         * Check if there is at least one visible bubble series.\n         *\n         * @private\n         * @function getVisibleBubbleSeriesIndex\n         * @param {Highcharts.Chart} chart\n         * Chart to check.\n         * @return {number}\n         * First visible bubble series index\n         */\n        function getVisibleBubbleSeriesIndex(chart) {\n            var series = chart.series;\n            var i = 0;\n            while (i < series.length) {\n                if (series[i] &&\n                    series[i].isBubble &&\n                    series[i].visible &&\n                    series[i].zData.length) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n        /**\n         * Calculate height for each row in legend.\n         *\n         * @private\n         * @function getLinesHeights\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend to calculate from.\n         *\n         * @return {Array<Highcharts.Dictionary<number>>}\n         * Informations about line height and items amount\n         */\n        function getLinesHeights(legend) {\n            var items = legend.allItems,\n                lines = [],\n                length = items.length;\n            var lastLine,\n                legendItem,\n                legendItem2,\n                i = 0,\n                j = 0;\n            for (i = 0; i < length; i++) {\n                legendItem = items[i].legendItem || {};\n                legendItem2 = (items[i + 1] || {}).legendItem || {};\n                if (legendItem.labelHeight) {\n                    // for bubbleLegend\n                    items[i].itemHeight = legendItem.labelHeight;\n                }\n                if ( // Line break\n                items[i] === items[length - 1] ||\n                    legendItem.y !== legendItem2.y) {\n                    lines.push({ height: 0 });\n                    lastLine = lines[lines.length - 1];\n                    // Find the highest item in line\n                    for (j; j <= i; j++) {\n                        if (items[j].itemHeight > lastLine.height) {\n                            lastLine.height = items[j].itemHeight;\n                        }\n                    }\n                    lastLine.step = i;\n                }\n            }\n            return lines;\n        }\n        /**\n         * Start the bubble legend creation process.\n         */\n        function onLegendAfterGetAllItems(e) {\n            var legend = this,\n                bubbleLegend = legend.bubbleLegend,\n                legendOptions = legend.options,\n                options = legendOptions.bubbleLegend,\n                bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);\n            // Remove unnecessary element\n            if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {\n                // Allow change the way of calculating ranges in update\n                if (options.ranges.length) {\n                    options.autoRanges =\n                        !!options.ranges[0].autoRanges;\n                }\n                // Update bubbleLegend dimensions in each redraw\n                legend.destroyItem(bubbleLegend);\n            }\n            // Create bubble legend\n            if (bubbleSeriesIndex >= 0 &&\n                legendOptions.enabled &&\n                options.enabled) {\n                options.seriesIndex = bubbleSeriesIndex;\n                legend.bubbleLegend = new BubbleLegendItem(options, legend);\n                legend.bubbleLegend.addToLegend(e.allItems);\n            }\n        }\n        /**\n         * Toggle bubble legend depending on the visible status of bubble series.\n         */\n        function onSeriesLegendItemClick() {\n            var series = this,\n                chart = series.chart,\n                visible = series.visible,\n                legend = series.chart.legend;\n            var status;\n            if (legend && legend.bubbleLegend) {\n                // Temporary correct 'visible' property\n                series.visible = !visible;\n                // Save future status for getRanges method\n                series.ignoreSeries = visible;\n                // Check if at lest one bubble series is visible\n                status = getVisibleBubbleSeriesIndex(chart) >= 0;\n                // Hide bubble legend if all bubble series are disabled\n                if (legend.bubbleLegend.visible !== status) {\n                    // Show or hide bubble legend\n                    legend.update({\n                        bubbleLegend: { enabled: status }\n                    });\n                    legend.bubbleLegend.visible = status; // Restore default status\n                }\n                series.visible = visible;\n            }\n        }\n        /**\n         * Correct legend items translation in case of different elements heights.\n         *\n         * @private\n         * @function Highcharts.Legend#retranslateItems\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend to translate in.\n         *\n         * @param {Array<Highcharts.Dictionary<number>>} lines\n         * Informations about line height and items amount\n         */\n        function retranslateItems(legend, lines) {\n            var items = legend.allItems,\n                rtl = legend.options.rtl;\n            var orgTranslateX,\n                orgTranslateY,\n                movementX,\n                legendItem,\n                actualLine = 0;\n            items.forEach(function (item, index) {\n                legendItem = item.legendItem || {};\n                if (!legendItem.group) {\n                    return;\n                }\n                orgTranslateX = legendItem.group.translateX || 0;\n                orgTranslateY = legendItem.y || 0;\n                movementX = item.movementX;\n                if (movementX || (rtl && item.ranges)) {\n                    movementX = rtl ?\n                        orgTranslateX - item.options.maxSize / 2 :\n                        orgTranslateX + movementX;\n                    legendItem.group.attr({ translateX: movementX });\n                }\n                if (index > lines[actualLine].step) {\n                    actualLine++;\n                }\n                legendItem.group.attr({\n                    translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)\n                });\n                legendItem.y = orgTranslateY + lines[actualLine].height / 2;\n            });\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var BubbleLegendComposition = {\n                compose: compose\n            };\n\n        return BubbleLegendComposition;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubblePoint.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Point, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var ScatterPoint = SeriesRegistry.seriesTypes.scatter.prototype.pointClass;\n        var extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BubblePoint = /** @class */ (function (_super) {\n                __extends(BubblePoint, _super);\n            function BubblePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            BubblePoint.prototype.haloPath = function (size) {\n                return Point.prototype.haloPath.call(this, \n                // #6067\n                size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size);\n            };\n            return BubblePoint;\n        }(ScatterPoint));\n        /* *\n         *\n         *  Class Prototype\n         *\n         * */\n        extend(BubblePoint.prototype, {\n            ttBelow: false\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BubblePoint;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleSeries.js', [_modules['Series/Bubble/BubbleLegendComposition.js'], _modules['Series/Bubble/BubblePoint.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (BubbleLegendComposition, BubblePoint, Color, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var color = Color.parse;\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            _a = SeriesRegistry.seriesTypes,\n            columnProto = _a.column.prototype,\n            ScatterSeries = _a.scatter;\n        var addEvent = U.addEvent,\n            arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            clamp = U.clamp,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Add logic to pad each axis with the amount of pixels necessary to avoid the\n         * bubbles to overflow.\n         */\n        function axisBeforePadding() {\n            var _this = this;\n            var axisLength = this.len,\n                chart = this.chart,\n                isXAxis = this.isXAxis,\n                dataKey = isXAxis ? 'xData' : 'yData',\n                min = this.min,\n                range = this.max - min;\n            var pxMin = 0,\n                pxMax = axisLength,\n                transA = axisLength / range,\n                hasActiveSeries;\n            // Handle padding on the second pass, or on redraw\n            this.series.forEach(function (series) {\n                if (series.bubblePadding &&\n                    (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n                    // Correction for #1673\n                    _this.allowZoomOutside = true;\n                    hasActiveSeries = true;\n                    var data = series[dataKey];\n                    if (isXAxis) {\n                        (series.onPoint || series).getRadii(0, 0, series);\n                        if (series.onPoint) {\n                            series.radii = series.onPoint.radii;\n                        }\n                    }\n                    if (range > 0) {\n                        var i = data.length;\n                        while (i--) {\n                            if (isNumber(data[i]) &&\n                                _this.dataMin <= data[i] &&\n                                data[i] <= _this.max) {\n                                var radius = series.radii && series.radii[i] || 0;\n                                pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                                pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                            }\n                        }\n                    }\n                }\n            });\n            // Apply the padding to the min and max properties\n            if (hasActiveSeries && range > 0 && !this.logarithmic) {\n                pxMax -= axisLength;\n                transA *= (axisLength +\n                    Math.max(0, pxMin) - // #8901\n                    Math.min(pxMax, axisLength)) / axisLength;\n                [\n                    ['min', 'userMin', pxMin],\n                    ['max', 'userMax', pxMax]\n                ].forEach(function (keys) {\n                    if (typeof pick(_this.options[keys[0]], _this[keys[1]]) === 'undefined') {\n                        _this[keys[0]] += keys[2] / transA;\n                    }\n                });\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BubbleSeries = /** @class */ (function (_super) {\n                __extends(BubbleSeries, _super);\n            function BubbleSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.maxPxSize = void 0;\n                _this.minPxSize = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.radii = void 0;\n                _this.yData = void 0;\n                _this.zData = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            BubbleSeries.compose = function (AxisClass, ChartClass, LegendClass, SeriesClass) {\n                BubbleLegendComposition.compose(ChartClass, LegendClass, SeriesClass);\n                if (composedClasses.indexOf(AxisClass) === -1) {\n                    composedClasses.push(AxisClass);\n                    AxisClass.prototype.beforePadding = axisBeforePadding;\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Perform animation on the bubbles\n             * @private\n             */\n            BubbleSeries.prototype.animate = function (init) {\n                if (!init &&\n                    this.points.length < this.options.animationLimit // #8099\n                ) {\n                    this.points.forEach(function (point) {\n                        var graphic = point.graphic;\n                        if (graphic && graphic.width) { // URL symbols don't have width\n                            // Start values\n                            if (!this.hasRendered) {\n                                graphic.attr({\n                                    x: point.plotX,\n                                    y: point.plotY,\n                                    width: 1,\n                                    height: 1\n                                });\n                            }\n                            // Run animation\n                            graphic.animate(this.markerAttribs(point), this.options.animation);\n                        }\n                    }, this);\n                }\n            };\n            /**\n             * Get the radius for each point based on the minSize, maxSize and each\n             * point's Z value. This must be done prior to Series.translate because\n             * the axis needs to add padding in accordance with the point sizes.\n             * @private\n             */\n            BubbleSeries.prototype.getRadii = function () {\n                var _this = this;\n                var zData = this.zData,\n                    yData = this.yData,\n                    radii = [];\n                var len,\n                    i,\n                    value,\n                    zExtremes = this.chart.bubbleZExtremes;\n                var _a = this.getPxExtremes(),\n                    minPxSize = _a.minPxSize,\n                    maxPxSize = _a.maxPxSize;\n                // Get the collective Z extremes of all bubblish series. The chart-level\n                // `bubbleZExtremes` are only computed once, and reset on `updatedData`\n                // in any member series.\n                if (!zExtremes) {\n                    var zMin_1 = Number.MAX_VALUE;\n                    var zMax_1 = -Number.MAX_VALUE;\n                    var valid_1;\n                    this.chart.series.forEach(function (otherSeries) {\n                        if (otherSeries.bubblePadding && (otherSeries.visible ||\n                            !_this.chart.options.chart.ignoreHiddenSeries)) {\n                            var zExtremes_1 = (otherSeries.onPoint || otherSeries).getZExtremes();\n                            if (zExtremes_1) {\n                                zMin_1 = Math.min(zMin_1 || zExtremes_1.zMin, zExtremes_1.zMin);\n                                zMax_1 = Math.max(zMax_1 || zExtremes_1.zMax, zExtremes_1.zMax);\n                                valid_1 = true;\n                            }\n                        }\n                    });\n                    if (valid_1) {\n                        zExtremes = { zMin: zMin_1, zMax: zMax_1 };\n                        this.chart.bubbleZExtremes = zExtremes;\n                    }\n                    else {\n                        zExtremes = { zMin: 0, zMax: 0 };\n                    }\n                }\n                // Set the shape type and arguments to be picked up in drawPoints\n                for (i = 0, len = zData.length; i < len; i++) {\n                    value = zData[i];\n                    // Separate method to get individual radius for bubbleLegend\n                    radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));\n                }\n                this.radii = radii;\n            };\n            /**\n             * Get the individual radius for one point.\n             * @private\n             */\n            BubbleSeries.prototype.getRadius = function (zMin, zMax, minSize, maxSize, value, yValue) {\n                var options = this.options,\n                    sizeByArea = options.sizeBy !== 'width',\n                    zThreshold = options.zThreshold;\n                var zRange = zMax - zMin,\n                    pos = 0.5;\n                // #8608 - bubble should be visible when z is undefined\n                if (yValue === null || value === null) {\n                    return null;\n                }\n                if (isNumber(value)) {\n                    // When sizing by threshold, the absolute value of z determines\n                    // the size of the bubble.\n                    if (options.sizeByAbsoluteValue) {\n                        value = Math.abs(value - zThreshold);\n                        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                        zMin = 0;\n                    }\n                    // Issue #4419 - if value is less than zMin, push a radius that's\n                    // always smaller than the minimum size\n                    if (value < zMin) {\n                        return minSize / 2 - 1;\n                    }\n                    // Relative size, a number between 0 and 1\n                    if (zRange > 0) {\n                        pos = (value - zMin) / zRange;\n                    }\n                }\n                if (sizeByArea && pos >= 0) {\n                    pos = Math.sqrt(pos);\n                }\n                return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n            };\n            /**\n             * Define hasData function for non-cartesian series.\n             * Returns true if the series has points at all.\n             * @private\n             */\n            BubbleSeries.prototype.hasData = function () {\n                return !!this.processedXData.length; // != 0\n            };\n            /**\n             * @private\n             */\n            BubbleSeries.prototype.pointAttribs = function (point, state) {\n                var markerOptions = this.options.marker,\n                    fillOpacity = markerOptions.fillOpacity,\n                    attr = Series.prototype.pointAttribs.call(this,\n                    point,\n                    state);\n                if (fillOpacity !== 1) {\n                    attr.fill = color(attr.fill)\n                        .setOpacity(fillOpacity)\n                        .get('rgba');\n                }\n                return attr;\n            };\n            /**\n             * Extend the base translate method to handle bubble size\n             * @private\n             */\n            BubbleSeries.prototype.translate = function () {\n                // Run the parent method\n                _super.prototype.translate.call(this);\n                this.getRadii();\n                this.translateBubble();\n            };\n            BubbleSeries.prototype.translateBubble = function () {\n                var _a = this,\n                    data = _a.data,\n                    radii = _a.radii;\n                var minPxSize = this.getPxExtremes().minPxSize;\n                // Set the shape type and arguments to be picked up in drawPoints\n                var i = data.length;\n                while (i--) {\n                    var point = data[i];\n                    var radius = radii ? radii[i] : 0; // #1737\n                        if (isNumber(radius) && radius >= minPxSize / 2) {\n                            // Shape arguments\n                            point.marker = extend(point.marker, {\n                                radius: radius,\n                                width: 2 * radius,\n                                height: 2 * radius\n                            });\n                        // Alignment box for the data label\n                        point.dlBox = {\n                            x: point.plotX - radius,\n                            y: point.plotY - radius,\n                            width: 2 * radius,\n                            height: 2 * radius\n                        };\n                    }\n                    else { // below zThreshold\n                        // #1691\n                        point.shapeArgs = point.plotY = point.dlBox = void 0;\n                        point.isInside = false; // #17281\n                    }\n                }\n            };\n            BubbleSeries.prototype.getPxExtremes = function () {\n                var smallestSize = Math.min(this.chart.plotWidth,\n                    this.chart.plotHeight);\n                var getPxSize = function (length) {\n                        var isPercent;\n                    if (typeof length === 'string') {\n                        isPercent = /%$/.test(length);\n                        length = parseInt(length, 10);\n                    }\n                    return isPercent ? smallestSize * length / 100 : length;\n                };\n                var minPxSize = getPxSize(pick(this.options.minSize, 8));\n                // Prioritize min size if conflict to make sure bubbles are\n                // always visible. #5873\n                var maxPxSize = Math.max(getPxSize(pick(this.options.maxSize, '20%')),\n                    minPxSize);\n                return { minPxSize: minPxSize, maxPxSize: maxPxSize };\n            };\n            BubbleSeries.prototype.getZExtremes = function () {\n                var options = this.options,\n                    zData = (this.zData || []).filter(isNumber);\n                if (zData.length) {\n                    var zMin = pick(options.zMin,\n                        clamp(arrayMin(zData),\n                        options.displayNegative === false ?\n                            (options.zThreshold || 0) :\n                            -Number.MAX_VALUE,\n                        Number.MAX_VALUE));\n                    var zMax = pick(options.zMax,\n                        arrayMax(zData));\n                    if (isNumber(zMin) && isNumber(zMax)) {\n                        return { zMin: zMin, zMax: zMax };\n                    }\n                }\n            };\n            /**\n             * A bubble series is a three dimensional series type where each point\n             * renders an X, Y and Z value. Each points is drawn as a bubble where the\n             * position along the X and Y axes mark the X and Y values, and the size of\n             * the bubble relates to the Z value.\n             *\n             * @sample {highcharts} highcharts/demo/bubble/\n             *         Bubble chart\n             *\n             * @extends      plotOptions.scatter\n             * @excluding    cluster\n             * @product      highcharts highstock\n             * @requires     highcharts-more\n             * @optionparent plotOptions.bubble\n             */\n            BubbleSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n                dataLabels: {\n                    formatter: function () {\n                        var numberFormatter = this.series.chart.numberFormatter;\n                        var z = this.point.z;\n                        return isNumber(z) ? numberFormatter(z, -1) : '';\n                    },\n                    inside: true,\n                    verticalAlign: 'middle'\n                },\n                /**\n                 * If there are more points in the series than the `animationLimit`, the\n                 * animation won't run. Animation affects overall performance and\n                 * doesn't work well with heavy data series.\n                 *\n                 * @since 6.1.0\n                 */\n                animationLimit: 250,\n                /**\n                 * Whether to display negative sized bubbles. The threshold is given\n                 * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative\n                 * bubbles can be visualized by setting\n                 * [negativeColor](#plotOptions.bubble.negativeColor).\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     3.0\n                 * @apioption plotOptions.bubble.displayNegative\n                 */\n                /**\n                 * @extends   plotOptions.series.marker\n                 * @excluding enabled, enabledThreshold, height, radius, width\n                 */\n                marker: {\n                    lineColor: null,\n                    lineWidth: 1,\n                    /**\n                     * The fill opacity of the bubble markers.\n                     */\n                    fillOpacity: 0.5,\n                    /**\n                     * In bubble charts, the radius is overridden and determined based\n                     * on the point's data value.\n                     *\n                     * @ignore-option\n                     */\n                    radius: null,\n                    states: {\n                        hover: {\n                            radiusPlus: 0\n                        }\n                    },\n                    /**\n                     * A predefined shape or symbol for the marker. Possible values are\n                     * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n                     *\n                     * Additionally, the URL to a graphic can be given on the form\n                     * `url(graphic.png)`. Note that for the image to be applied to\n                     * exported charts, its URL needs to be accessible by the export\n                     * server.\n                     *\n                     * Custom callbacks for symbol path generation can also be added to\n                     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n                     * used by its method name, as shown in the demo.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/bubble-symbol/\n                     *         Bubble chart with various symbols\n                     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n                     *         General chart with predefined, graphic and custom markers\n                     *\n                     * @type  {Highcharts.SymbolKeyValue|string}\n                     * @since 5.0.11\n                     */\n                    symbol: 'circle'\n                },\n                /**\n                 * Minimum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n                 * Can be either pixels (when no unit is given), or a percentage of\n                 * the smallest one of the plot width and height.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts highstock\n                 */\n                minSize: 8,\n                /**\n                 * Maximum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n                 * Can be either pixels (when no unit is given), or a percentage of\n                 * the smallest one of the plot width and height.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts highstock\n                 */\n                maxSize: '20%',\n                /**\n                 * When a point's Z value is below the\n                 * [zThreshold](#plotOptions.bubble.zThreshold)\n                 * setting, this color is used.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.negativeColor\n                 */\n                /**\n                 * Whether the bubble's value should be represented by the area or the\n                 * width of the bubble. The default, `area`, corresponds best to the\n                 * human perception of the size of each bubble.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/\n                 *         Comparison of area and size\n                 *\n                 * @type       {Highcharts.BubbleSizeByValue}\n                 * @default    area\n                 * @since      3.0.7\n                 * @apioption  plotOptions.bubble.sizeBy\n                 */\n                /**\n                 * When this is true, the absolute value of z determines the size of\n                 * the bubble. This means that with the default `zThreshold` of 0, a\n                 * bubble of value -1 will have the same size as a bubble of value 1,\n                 * while a bubble of value 0 will have a smaller size according to\n                 * `minSize`.\n                 *\n                 * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/\n                 *            Size by absolute value, various thresholds\n                 *\n                 * @type      {boolean}\n                 * @default   false\n                 * @since     4.1.9\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.sizeByAbsoluteValue\n                 */\n                /**\n                 * When this is true, the series will not cause the Y axis to cross\n                 * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n                 * unless the data actually crosses the plane.\n                 *\n                 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n                 * 3 will make the Y axis show negative values according to the\n                 * `minPadding` option. If `softThreshold` is `true`, the Y axis starts\n                 * at 0.\n                 *\n                 * @since   4.1.9\n                 * @product highcharts\n                 */\n                softThreshold: false,\n                states: {\n                    hover: {\n                        halo: {\n                            size: 5\n                        }\n                    }\n                },\n                tooltip: {\n                    pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n                },\n                turboThreshold: 0,\n                /**\n                 * The minimum for the Z value range. Defaults to the highest Z value\n                 * in the data.\n                 *\n                 * @see [zMin](#plotOptions.bubble.zMin)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n                 *         Z has a possible range of 0-100\n                 *\n                 * @type      {number}\n                 * @since     4.0.3\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.zMax\n                 */\n                /**\n                 * @default   z\n                 * @apioption plotOptions.bubble.colorKey\n                 */\n                /**\n                 * The minimum for the Z value range. Defaults to the lowest Z value\n                 * in the data.\n                 *\n                 * @see [zMax](#plotOptions.bubble.zMax)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n                 *         Z has a possible range of 0-100\n                 *\n                 * @type      {number}\n                 * @since     4.0.3\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.zMin\n                 */\n                /**\n                 * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,\n                 * bubbles with lower Z values are skipped. When `displayNegative`\n                 * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)\n                 * is given, points with lower Z is colored.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                zThreshold: 0,\n                zoneAxis: 'z'\n            });\n            return BubbleSeries;\n        }(ScatterSeries));\n        extend(BubbleSeries.prototype, {\n            alignDataLabel: columnProto.alignDataLabel,\n            applyZones: noop,\n            bubblePadding: true,\n            buildKDTree: noop,\n            directTouch: true,\n            isBubble: true,\n            pointArrayMap: ['y', 'z'],\n            pointClass: BubblePoint,\n            parallelArrays: ['x', 'y', 'z'],\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            specialGroup: 'group',\n            zoneAxis: 'z'\n        });\n        // On updated data in any series, delete the chart-level Z extremes cache\n        addEvent(BubbleSeries, 'updatedData', function (e) {\n            delete e.target.chart.bubbleZExtremes;\n        });\n        // After removing series, delete the chart-level Z extremes cache, #17502.\n        addEvent(BubbleSeries, 'remove', function (e) {\n            delete e.target.chart.bubbleZExtremes;\n        });\n        SeriesRegistry.registerSeriesType('bubble', BubbleSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @typedef {\"area\"|\"width\"} Highcharts.BubbleSizeByValue\n         */\n        ''; // detach doclets above\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `bubble` series. If the [type](#series.bubble.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.bubble\n         * @excluding dataParser, dataURL, stack\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.bubble\n         */\n        /**\n         * An array of data points for the series. For the `bubble` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,y,z`. If the first value is a string, it is applied as the name of\n         *    the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 1, 2],\n         *        [1, 5, 5],\n         *        [2, 0, 2]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.bubble.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 1,\n         *        z: 1,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 5,\n         *        z: 4,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.line.data\n         * @product   highcharts\n         * @apioption series.bubble.data\n         */\n        /**\n         * @extends     series.line.data.marker\n         * @excluding   enabledThreshold, height, radius, width\n         * @product     highcharts\n         * @apioption   series.bubble.data.marker\n         */\n        /**\n         * The size value for each bubble. The bubbles' diameters are computed\n         * based on the `z`, and controlled by series options like `minSize`,\n         * `maxSize`, `sizeBy`, `zMin` and `zMax`.\n         *\n         * @type      {number|null}\n         * @product   highcharts\n         * @apioption series.bubble.data.z\n         */\n        /**\n         * @excluding enabled, enabledThreshold, height, radius, width\n         * @apioption series.bubble.marker\n         */\n        ''; // adds doclets above to transpiled file\n\n        return BubbleSeries;\n    });\n    _registerModule(_modules, 'Series/ColumnRange/ColumnRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes,\n            columnProto = _a.column.prototype.pointClass.prototype,\n            AreaRangePoint = _a.arearange.prototype.pointClass;\n        var extend = U.extend,\n            isNumber = U.isNumber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var ColumnRangePoint = /** @class */ (function (_super) {\n                __extends(ColumnRangePoint, _super);\n            function ColumnRangePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ColumnRangePoint.prototype.isValid = function () {\n                return isNumber(this.low);\n            };\n            return ColumnRangePoint;\n        }(AreaRangePoint));\n        extend(ColumnRangePoint.prototype, {\n            setState: columnProto.setState\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ColumnRangePoint;\n    });\n    _registerModule(_modules, 'Series/ColumnRange/ColumnRangeSeries.js', [_modules['Series/ColumnRange/ColumnRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnRangePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var _a = SeriesRegistry.seriesTypes,\n            AreaRangeSeries = _a.arearange,\n            ColumnSeries = _a.column,\n            columnProto = _a.column.prototype;\n        var clamp = U.clamp,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The column range is a cartesian series type with higher and lower\n         * Y values along an X axis. To display horizontal bars, set\n         * [chart.inverted](#chart.inverted) to `true`.\n         *\n         * @sample {highcharts|highstock} highcharts/demo/columnrange/\n         *         Inverted column range\n         *\n         * @extends      plotOptions.column\n         * @since        2.3.0\n         * @excluding    negativeColor, stacking, softThreshold, threshold\n         * @product      highcharts highstock\n         * @requires     highcharts-more\n         * @optionparent plotOptions.columnrange\n         */\n        var columnRangeOptions = {\n                /**\n                 * Extended data labels for range series types. Range series data labels\n                 * have no `x` and `y` options. Instead,\n            they have `xLow`,\n            `xHigh`,\n                 * `yLow` and `yHigh` options to allow the higher and lower data label\n                 * sets individually.\n                 *\n                 * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n                 * @extends   plotOptions.arearange.dataLabels\n                 * @since     2.3.0\n                 * @product   highcharts highstock\n                 * @apioption plotOptions.columnrange.dataLabels\n                 */\n                pointRange: null,\n                /** @ignore-option */\n                marker: null,\n                states: {\n                    hover: {\n                        /** @ignore-option */\n                        halo: false\n                    }\n                }\n            };\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The ColumnRangeSeries class\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.columnrange\n         *\n         * @augments Highcharts.Series\n         */\n        var ColumnRangeSeries = /** @class */ (function (_super) {\n                __extends(ColumnRangeSeries, _super);\n            function ColumnRangeSeries() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ColumnRangeSeries.prototype.setOptions = function () {\n                // #14359 Prevent side-effect from stacking.\n                merge(true, arguments[0], { stacking: void 0 });\n                return AreaRangeSeries.prototype.setOptions.apply(this, arguments);\n            };\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Translate data points from raw values x and y to plotX and plotY\n             * @private\n             */\n            ColumnRangeSeries.prototype.translate = function () {\n                var _this = this;\n                var yAxis = this.yAxis,\n                    xAxis = this.xAxis,\n                    startAngleRad = xAxis.startAngleRad,\n                    chart = this.chart,\n                    isRadial = this.xAxis.isRadial,\n                    safeDistance = Math.max(chart.chartWidth,\n                    chart.chartHeight) + 999;\n                var height,\n                    heightDifference,\n                    start,\n                    plotHigh,\n                    y;\n                // eslint-disable-next-line valid-jsdoc\n                /**\n                 * Don't draw too far outside plot area (#6835)\n                 * @private\n                 */\n                function safeBounds(pixelPos) {\n                    return clamp(pixelPos, -safeDistance, safeDistance);\n                }\n                columnProto.translate.apply(this);\n                // Set plotLow and plotHigh\n                this.points.forEach(function (point) {\n                    var shapeArgs = point.shapeArgs || {},\n                        minPointLength = _this.options.minPointLength,\n                        plotY = point.plotY,\n                        plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n                    if (isNumber(plotHigh) && isNumber(plotY)) {\n                        point.plotHigh = safeBounds(plotHigh);\n                        point.plotLow = safeBounds(plotY);\n                        // adjust shape\n                        y = point.plotHigh;\n                        height = pick(point.rectPlotY, point.plotY) - point.plotHigh;\n                        // Adjust for minPointLength\n                        if (Math.abs(height) < minPointLength) {\n                            heightDifference = (minPointLength - height);\n                            height += heightDifference;\n                            y -= heightDifference / 2;\n                            // Adjust for negative ranges or reversed Y axis (#1457)\n                        }\n                        else if (height < 0) {\n                            height *= -1;\n                            y -= height;\n                        }\n                        if (isRadial && _this.polar) {\n                            start = point.barX + startAngleRad;\n                            point.shapeType = 'arc';\n                            point.shapeArgs = _this.polar.arc(y + height, y, start, start + point.pointWidth);\n                        }\n                        else {\n                            shapeArgs.height = height;\n                            shapeArgs.y = y;\n                            var _a = shapeArgs.x,\n                                x = _a === void 0 ? 0 : _a,\n                                _b = shapeArgs.width,\n                                width = _b === void 0 ? 0 : _b;\n                            point.tooltipPos = chart.inverted ?\n                                [\n                                    yAxis.len + yAxis.pos - chart.plotLeft - y -\n                                        height / 2,\n                                    xAxis.len + xAxis.pos - chart.plotTop - x -\n                                        width / 2,\n                                    height\n                                ] : [\n                                xAxis.left - chart.plotLeft + x + width / 2,\n                                yAxis.pos - chart.plotTop + y + height / 2,\n                                height\n                            ]; // don't inherit from column tooltip position - #3372\n                        }\n                    }\n                });\n            };\n            // Overrides from modules that may be loaded after this module\n            // @todo move to compositions\n            // public crispCol(): BBoxObject {\n            //     return columnProto.crispCol.apply(this, arguments as any);\n            // }\n            // public drawPoints(): void {\n            //     return columnProto.drawPoints.apply(this, arguments as any);\n            // }\n            // public drawTracker(): void {\n            //     return columnProto.drawTracker.apply(this, arguments as any);\n            // }\n            // public getColumnMetrics(): ColumnMetricsObject {\n            //     return columnProto.getColumnMetrics.apply(this, arguments as any);\n            // }\n            ColumnRangeSeries.prototype.pointAttribs = function () {\n                return columnProto.pointAttribs.apply(this, arguments);\n            };\n            // public adjustForMissingColumns(): number {\n            //     return columnProto.adjustForMissingColumns.apply(this, arguments);\n            // }\n            // public animate(): void {\n            //     return columnProto.animate.apply(this, arguments as any);\n            // }\n            ColumnRangeSeries.prototype.translate3dPoints = function () {\n                return columnProto.translate3dPoints.apply(this, arguments);\n            };\n            ColumnRangeSeries.prototype.translate3dShapes = function () {\n                return columnProto.translate3dShapes.apply(this, arguments);\n            };\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            ColumnRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, AreaRangeSeries.defaultOptions, columnRangeOptions);\n            return ColumnRangeSeries;\n        }(AreaRangeSeries));\n        extend(ColumnRangeSeries.prototype, {\n            directTouch: true,\n            pointClass: ColumnRangePoint,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            adjustForMissingColumns: columnProto.adjustForMissingColumns,\n            animate: columnProto.animate,\n            crispCol: columnProto.crispCol,\n            drawGraph: noop,\n            drawPoints: columnProto.drawPoints,\n            getSymbol: noop,\n            drawTracker: columnProto.drawTracker,\n            getColumnMetrics: columnProto.getColumnMetrics\n            // pointAttribs: columnProto.pointAttribs,\n            // polarArc: columnProto.polarArc\n            // translate3dPoints: columnProto.translate3dPoints,\n            // translate3dShapes: columnProto.translate3dShapes\n        });\n        SeriesRegistry.registerSeriesType('columnrange', ColumnRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `columnrange` series. If the [type](#series.columnrange.type)\n         * option is not specified, it is inherited from\n         * [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.columnrange\n         * @excluding dataParser, dataURL, stack, stacking\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.columnrange\n         */\n        /**\n         * An array of data points for the series. For the `columnrange` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 4, 2],\n         *        [1, 2, 1],\n         *        [2, 9, 10]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.columnrange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 0,\n         *        high: 4,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        high: 3,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @excluding marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.data\n         */\n        /**\n         * @extends   series.columnrange.dataLabels\n         * @product   highcharts highstock\n         * @apioption series.columnrange.data.dataLabels\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.states.hover\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.states.select\n         */\n        ''; // adds doclets above into transpiled\n\n        return ColumnRangeSeries;\n    });\n    _registerModule(_modules, 'Series/ColumnPyramid/ColumnPyramidSeries.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnSeries, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var colProto = ColumnSeries.prototype;\n        var clamp = U.clamp,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick;\n        /**\n         * The ColumnPyramidSeries class\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.columnpyramid\n         *\n         * @augments Highcharts.Series\n         */\n        var ColumnPyramidSeries = /** @class */ (function (_super) {\n                __extends(ColumnPyramidSeries, _super);\n            function ColumnPyramidSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            /* eslint-disable-next-line valid-jsdoc */\n            /**\n             * Overrides the column translate method\n             * @private\n             */\n            ColumnPyramidSeries.prototype.translate = function () {\n                var series = this,\n                    chart = series.chart,\n                    options = series.options,\n                    dense = series.dense =\n                        series.closestPointRange * series.xAxis.transA < 2,\n                    borderWidth = series.borderWidth = pick(options.borderWidth,\n                    dense ? 0 : 1 // #3635\n                    ),\n                    yAxis = series.yAxis,\n                    threshold = options.threshold,\n                    translatedThreshold = series.translatedThreshold =\n                        yAxis.getThreshold(threshold),\n                    minPointLength = pick(options.minPointLength, 5),\n                    metrics = series.getColumnMetrics(),\n                    pointWidth = metrics.width, \n                    // postprocessed for border width\n                    seriesBarW = series.barW =\n                        Math.max(pointWidth, 1 + 2 * borderWidth),\n                    pointXOffset = series.pointXOffset = metrics.offset;\n                if (chart.inverted) {\n                    translatedThreshold -= 0.5; // #3355\n                }\n                // When the pointPadding is 0,\n                // we want the pyramids to be packed tightly,\n                // so we allow individual pyramids to have individual sizes.\n                // When pointPadding is greater,\n                // we strive for equal-width columns (#2694).\n                if (options.pointPadding) {\n                    seriesBarW = Math.ceil(seriesBarW);\n                }\n                colProto.translate.apply(series);\n                // Record the new values\n                series.points.forEach(function (point) {\n                    var yBottom = pick(point.yBottom,\n                        translatedThreshold),\n                        safeDistance = 999 + Math.abs(yBottom),\n                        plotY = clamp(point.plotY, -safeDistance,\n                        yAxis.len + safeDistance), \n                        // Don't draw too far outside plot area\n                        // (#1303, #2241, #4264)\n                        barX = point.plotX + pointXOffset,\n                        barW = seriesBarW / 2,\n                        barY = Math.min(plotY,\n                        yBottom),\n                        barH = Math.max(plotY,\n                        yBottom) - barY,\n                        stackTotal,\n                        stackHeight,\n                        topPointY,\n                        topXwidth,\n                        bottomXwidth,\n                        invBarPos,\n                        x1,\n                        x2,\n                        x3,\n                        x4,\n                        y1,\n                        y2;\n                    point.barX = barX;\n                    point.pointWidth = pointWidth;\n                    // Fix the tooltip on center of grouped pyramids\n                    // (#1216, #424, #3648)\n                    point.tooltipPos = chart.inverted ?\n                        [\n                            yAxis.len + yAxis.pos - chart.plotLeft - plotY,\n                            series.xAxis.len - barX - barW,\n                            barH\n                        ] :\n                        [\n                            barX + barW,\n                            plotY + yAxis.pos - chart.plotTop,\n                            barH\n                        ];\n                    stackTotal =\n                        threshold + (point.total || point.y);\n                    // overwrite stacktotal (always 100 / -100)\n                    if (options.stacking === 'percent') {\n                        stackTotal =\n                            threshold + (point.y < 0) ?\n                                -100 :\n                                100;\n                    }\n                    // get the highest point (if stack, extract from total)\n                    topPointY = yAxis.toPixels((stackTotal), true);\n                    // calculate height of stack (in pixels)\n                    stackHeight =\n                        chart.plotHeight - topPointY -\n                            (chart.plotHeight - translatedThreshold);\n                    // topXwidth and bottomXwidth = width of lines from the center\n                    // calculated from tanges proportion.\n                    // Cannot be a NaN #12514\n                    topXwidth = stackHeight ?\n                        (barW * (barY - topPointY)) / stackHeight : 0;\n                    // like topXwidth, but with height of point\n                    bottomXwidth = stackHeight ?\n                        (barW * (barY + barH - topPointY)) / stackHeight :\n                        0;\n                    /*\n                            /\\\n                           /  \\\n                    x1,y1,------ x2,y1\n                        /      \\\n                       ----------\n                    x4,y2        x3,y2\n                    */\n                    x1 = barX - topXwidth + barW;\n                    x2 = barX + topXwidth + barW;\n                    x3 = barX + bottomXwidth + barW;\n                    x4 = barX - bottomXwidth + barW;\n                    y1 = barY - minPointLength;\n                    y2 = barY + barH;\n                    if (point.y < 0) {\n                        y1 = barY;\n                        y2 = barY + barH + minPointLength;\n                    }\n                    // inverted chart\n                    if (chart.inverted) {\n                        invBarPos = yAxis.width - barY;\n                        stackHeight =\n                            topPointY - (yAxis.width - translatedThreshold);\n                        // proportion tanges\n                        topXwidth = (barW *\n                            (topPointY - invBarPos)) / stackHeight;\n                        bottomXwidth = (barW *\n                            (topPointY - (invBarPos - barH))) / stackHeight;\n                        x1 = barX + barW + topXwidth; // top bottom\n                        x2 = x1 - 2 * topXwidth; // top top\n                        x3 = barX - bottomXwidth + barW; // bottom top\n                        x4 = barX + bottomXwidth + barW; // bottom bottom\n                        y1 = barY;\n                        y2 = barY + barH - minPointLength;\n                        if (point.y < 0) {\n                            y2 = barY + barH + minPointLength;\n                        }\n                    }\n                    // Register shape type and arguments to be used in drawPoints\n                    point.shapeType = 'path';\n                    point.shapeArgs = {\n                        // args for datalabels positioning\n                        x: x1,\n                        y: y1,\n                        width: x2 - x1,\n                        height: barH,\n                        // path of pyramid\n                        d: [\n                            ['M', x1, y1],\n                            ['L', x2, y1],\n                            ['L', x3, y2],\n                            ['L', x4, y2],\n                            ['Z']\n                        ]\n                    };\n                });\n            };\n            /**\n             * Column pyramid series display one pyramid per value along an X axis.\n             * To display horizontal pyramids, set [chart.inverted](#chart.inverted) to\n             * `true`.\n             *\n             * @sample {highcharts|highstock} highcharts/demo/column-pyramid/\n             *         Column pyramid\n             * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-stacked/\n             *         Column pyramid stacked\n             * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-inverted/\n             *         Column pyramid inverted\n             *\n             * @extends      plotOptions.column\n             * @since        7.0.0\n             * @product      highcharts highstock\n             * @excluding    boostThreshold, borderRadius, crisp, depth, edgeColor,\n             *               edgeWidth, groupZPadding, negativeColor, softThreshold,\n             *               threshold, zoneAxis, zones, boostBlending\n             * @requires     highcharts-more\n             * @optionparent plotOptions.columnpyramid\n             */\n            ColumnPyramidSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n            // Nothing here\n            });\n            return ColumnPyramidSeries;\n        }(ColumnSeries));\n        SeriesRegistry.registerSeriesType('columnpyramid', ColumnPyramidSeries);\n        /* *\n         *\n         * Default export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `columnpyramid` series. If the [type](#series.columnpyramid.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.columnpyramid\n         * @excluding connectEnds, connectNulls, dashStyle, dataParser, dataURL,\n         *            gapSize, gapUnit, linecap, lineWidth, marker, step,\n         *            boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.columnpyramid\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.states.hover\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.states.select\n         */\n        /**\n         * An array of data points for the series. For the `columnpyramid` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 6],\n         *        [1, 2],\n         *        [2, 6]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The objects are point configuration\n         *    objects as seen below. If the total number of data points exceeds the\n         *    series' [turboThreshold](#series.columnpyramid.turboThreshold), this\n         *    option is not available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 9,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 6,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.data\n         */\n        ''; // adds doclets above to transpiled file;\n\n        return ColumnPyramidSeries;\n    });\n    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Error bars are a graphical representation of the variability of data and\n         * are used on graphs to indicate the error, or uncertainty in a reported\n         * measurement.\n         *\n         * @sample highcharts/demo/error-bar/\n         *         Error bars on a column series\n         * @sample highcharts/series-errorbar/on-scatter/\n         *         Error bars on a scatter series\n         * @sample highcharts/series-errorbar/datalabels/\n         *         Error bars with data labels\n         *\n         * @extends      plotOptions.boxplot\n         * @excluding    boostBlending, boostThreshold\n         * @product      highcharts\n         * @requires     highcharts-more\n         * @optionparent plotOptions.errorbar\n         */\n        var ErrorBarSeriesDefaults = {\n                /**\n                 * The main color of the bars. This can be overridden by\n                 * [stemColor](#plotOptions.errorbar.stemColor) and\n                 * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @default #000000\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                color: \"#000000\" /* Palette.neutralColor100 */,\n                grouping: false,\n                /**\n                 * The parent series of the error bar. The default value links it to\n                 * the previous series. Otherwise,\n            use the id of the parent series.\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                linkedTo: ':previous',\n                tooltip: {\n                    pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n                },\n                /**\n                 * The line width of the whiskers,\n            the horizontal lines marking\n                 * low and high values. When `null`,\n            the general\n                 * [lineWidth](#plotOptions.errorbar.lineWidth) applies.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type    {number}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerWidth: null\n            };\n        /**\n         * A `errorbar` series. If the [type](#series.errorbar.type) option\n         * is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.errorbar\n         * @excluding dataParser, dataURL, stack, stacking, boostThreshold,\n         *            boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.errorbar\n         */\n        /**\n         * An array of data points for the series. For the `errorbar` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 10, 2],\n         *        [1, 1, 8],\n         *        [2, 4, 5]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.errorbar.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 0,\n         *        high: 0,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        high: 5,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @excluding dataLabels, drilldown, marker, states\n         * @product   highcharts\n         * @apioption series.errorbar.data\n         */\n        ''; // adds doclets above to transpiled file\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ErrorBarSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeries.js', [_modules['Series/BoxPlot/BoxPlotSeries.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Series/ErrorBar/ErrorBarSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (BoxPlotSeries, ColumnSeries, ErrorBarSeriesDefaults, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var AreaRangeSeries = SeriesRegistry.seriesTypes.arearange;\n        var addEvent = U.addEvent,\n            merge = U.merge,\n            extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Errorbar series type\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.errorbar\n         *\n         * @augments Highcharts.Series\n         *\n         */\n        var ErrorBarSeries = /** @class */ (function (_super) {\n                __extends(ErrorBarSeries, _super);\n            function ErrorBarSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ErrorBarSeries.prototype.getColumnMetrics = function () {\n                // Get the width and X offset, either on top of the linked series\n                // column or standalone\n                return ((this.linkedParent && this.linkedParent.columnMetrics) ||\n                    ColumnSeries.prototype.getColumnMetrics.call(this));\n            };\n            ErrorBarSeries.prototype.drawDataLabels = function () {\n                var valKey = this.pointValKey;\n                if (AreaRangeSeries) {\n                    AreaRangeSeries.prototype.drawDataLabels.call(this);\n                    // Arearange drawDataLabels does not reset point.y to high,\n                    // but to low after drawing (#4133)\n                    this.data.forEach(function (point) {\n                        point.y = point[valKey];\n                    });\n                }\n            };\n            ErrorBarSeries.prototype.toYData = function (point) {\n                // return a plain array for speedy calculation\n                return [point.low, point.high];\n            };\n            ErrorBarSeries.defaultOptions = merge(BoxPlotSeries.defaultOptions, ErrorBarSeriesDefaults);\n            return ErrorBarSeries;\n        }(BoxPlotSeries));\n        addEvent(ErrorBarSeries, 'afterTranslate', function () {\n            this.points.forEach(function (point) {\n                point.plotLow = point.plotY;\n            });\n        }, { order: 0 });\n        extend(ErrorBarSeries.prototype, {\n            // pointClass: ErrorBarPoint, // just a declaration\n            pointArrayMap: ['low', 'high'],\n            pointValKey: 'high',\n            doQuartiles: false\n        });\n        SeriesRegistry.registerSeriesType('errorbar', ErrorBarSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ErrorBarSeries;\n    });\n    _registerModule(_modules, 'Series/Gauge/GaugePoint.js', [_modules['Core/Series/SeriesRegistry.js']], function (SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var Point = SeriesRegistry.series.prototype.pointClass;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var GaugePoint = /** @class */ (function (_super) {\n                __extends(GaugePoint, _super);\n            function GaugePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                _this.shapeArgs = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Don't do any hover colors or anything\n             * @private\n             */\n            GaugePoint.prototype.setState = function (state) {\n                this.state = state;\n            };\n            return GaugePoint;\n        }(Point));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GaugePoint;\n    });\n    _registerModule(_modules, 'Series/Gauge/GaugeSeries.js', [_modules['Series/Gauge/GaugePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (GaugePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            ColumnSeries = SeriesRegistry.seriesTypes.column;\n        var clamp = U.clamp,\n            isNumber = U.isNumber,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick,\n            pInt = U.pInt;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         *\n         * The `gauge` series type\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.map\n         *\n         * @augments Highcharts.Series\n         */\n        var GaugeSeries = /** @class */ (function (_super) {\n                __extends(GaugeSeries, _super);\n            function GaugeSeries() {\n                /* *\n                 *\n                 *  Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.points = void 0;\n                _this.options = void 0;\n                _this.yAxis = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Calculate paths etc\n             * @private\n             */\n            GaugeSeries.prototype.translate = function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    options = series.options,\n                    center = yAxis.center;\n                series.generatePoints();\n                series.points.forEach(function (point) {\n                    var dialOptions = merge(options.dial,\n                        point.dial),\n                        radius = (pInt(dialOptions.radius) * center[2]) / 200,\n                        baseLength = (pInt(dialOptions.baseLength) * radius) / 100,\n                        rearLength = (pInt(dialOptions.rearLength) * radius) / 100,\n                        baseWidth = dialOptions.baseWidth,\n                        topWidth = dialOptions.topWidth;\n                    var overshoot = options.overshoot,\n                        rotation = yAxis.startAngleRad + yAxis.translate(point.y,\n                        void 0,\n                        void 0,\n                        void 0,\n                        true);\n                    // Handle the wrap and overshoot options\n                    if (isNumber(overshoot) || options.wrap === false) {\n                        overshoot = isNumber(overshoot) ?\n                            (overshoot / 180 * Math.PI) : 0;\n                        rotation = clamp(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);\n                    }\n                    rotation = rotation * 180 / Math.PI;\n                    point.shapeType = 'path';\n                    var d = dialOptions.path || [\n                            ['M', -rearLength, -baseWidth / 2],\n                            ['L',\n                        baseLength, -baseWidth / 2],\n                            ['L',\n                        radius, -topWidth / 2],\n                            ['L',\n                        radius,\n                        topWidth / 2],\n                            ['L',\n                        baseLength,\n                        baseWidth / 2],\n                            ['L', -rearLength,\n                        baseWidth / 2],\n                            ['Z']\n                        ];\n                    point.shapeArgs = {\n                        d: d,\n                        translateX: center[0],\n                        translateY: center[1],\n                        rotation: rotation\n                    };\n                    // Positions for data label\n                    point.plotX = center[0];\n                    point.plotY = center[1];\n                });\n            };\n            /**\n             * Draw the points where each point is one needle\n             * @private\n             */\n            GaugeSeries.prototype.drawPoints = function () {\n                var series = this,\n                    chart = series.chart,\n                    center = series.yAxis.center,\n                    pivot = series.pivot,\n                    options = series.options,\n                    pivotOptions = options.pivot,\n                    renderer = chart.renderer;\n                series.points.forEach(function (point) {\n                    var graphic = point.graphic,\n                        shapeArgs = point.shapeArgs,\n                        d = shapeArgs.d,\n                        dialOptions = merge(options.dial,\n                        point.dial); // #1233\n                        if (graphic) {\n                            graphic.animate(shapeArgs);\n                        shapeArgs.d = d; // animate alters it\n                    }\n                    else {\n                        point.graphic =\n                            renderer[point.shapeType](shapeArgs)\n                                .attr({\n                                // required by VML when animation is false\n                                rotation: shapeArgs.rotation,\n                                zIndex: 1\n                            })\n                                .addClass('highcharts-dial')\n                                .add(series.group);\n                    }\n                    // Presentational attributes\n                    if (!chart.styledMode) {\n                        point.graphic[graphic ? 'animate' : 'attr']({\n                            stroke: dialOptions.borderColor,\n                            'stroke-width': dialOptions.borderWidth,\n                            fill: dialOptions.backgroundColor\n                        });\n                    }\n                });\n                // Add or move the pivot\n                if (pivot) {\n                    pivot.animate({\n                        translateX: center[0],\n                        translateY: center[1]\n                    });\n                }\n                else if (pivotOptions) {\n                    series.pivot =\n                        renderer.circle(0, 0, pivotOptions.radius)\n                            .attr({\n                            zIndex: 2\n                        })\n                            .addClass('highcharts-pivot')\n                            .translate(center[0], center[1])\n                            .add(series.group);\n                    // Presentational attributes\n                    if (!chart.styledMode) {\n                        series.pivot.attr({\n                            fill: pivotOptions.backgroundColor,\n                            stroke: pivotOptions.borderColor,\n                            'stroke-width': pivotOptions.borderWidth\n                        });\n                    }\n                }\n            };\n            /**\n             * Animate the arrow up from startAngle\n             * @private\n             */\n            GaugeSeries.prototype.animate = function (init) {\n                var series = this;\n                if (!init) {\n                    series.points.forEach(function (point) {\n                        var graphic = point.graphic;\n                        if (graphic) {\n                            // start value\n                            graphic.attr({\n                                rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                            });\n                            // animate\n                            graphic.animate({\n                                rotation: point.shapeArgs.rotation\n                            }, series.options.animation);\n                        }\n                    });\n                }\n            };\n            /**\n             * @private\n             */\n            GaugeSeries.prototype.render = function () {\n                this.group = this.plotGroup('group', 'series', this.visible ? 'inherit' : 'hidden', this.options.zIndex, this.chart.seriesGroup);\n                Series.prototype.render.call(this);\n                this.group.clip(this.chart.clipRect);\n            };\n            /**\n             * Extend the basic setData method by running processData and generatePoints\n             * immediately, in order to access the points from the legend.\n             * @private\n             */\n            GaugeSeries.prototype.setData = function (data, redraw) {\n                Series.prototype.setData.call(this, data, false);\n                this.processData();\n                this.generatePoints();\n                if (pick(redraw, true)) {\n                    this.chart.redraw();\n                }\n            };\n            /**\n             * Define hasData function for non-cartesian series.\n             * Returns true if the series has points at all.\n             * @private\n             */\n            GaugeSeries.prototype.hasData = function () {\n                return !!this.points.length; // != 0\n            };\n            /**\n             * Gauges are circular plots displaying one or more values with a dial\n             * pointing to values along the perimeter.\n             *\n             * @sample highcharts/demo/gauge-speedometer/\n             *         Gauge chart\n             *\n             * @extends      plotOptions.line\n             * @excluding    animationLimit, boostThreshold, colorAxis, colorKey,\n             *               connectEnds, connectNulls, cropThreshold, dashStyle,\n             *               dragDrop, findNearestPointBy, getExtremesFromAll, marker,\n             *               negativeColor, pointPlacement, shadow, softThreshold,\n             *               stacking, states, step, threshold, turboThreshold, xAxis,\n             *               zoneAxis, zones, dataSorting, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.gauge\n             */\n            GaugeSeries.defaultOptions = merge(Series.defaultOptions, {\n                /**\n                 * When this option is `true`, the dial will wrap around the axes.\n                 * For instance, in a full-range gauge going from 0 to 360, a value\n                 * of 400 will point to 40\\. When `wrap` is `false`, the dial stops\n                 * at 360.\n                 *\n                 * @see [overshoot](#plotOptions.gauge.overshoot)\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.gauge.wrap\n                 */\n                /**\n                 * Data labels for the gauge. For gauges, the data labels are\n                 * enabled by default and shown in a bordered box below the point.\n                 *\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                dataLabels: {\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    borderRadius: 3,\n                    borderWidth: 1,\n                    crop: false,\n                    defer: false,\n                    enabled: true,\n                    verticalAlign: 'top',\n                    y: 15,\n                    zIndex: 2\n                },\n                /**\n                 * Options for the dial or arrow pointer of the gauge.\n                 *\n                 * In styled mode, the dial is styled with the\n                 * `.highcharts-gauge-series .highcharts-dial` rule.\n                 *\n                 * @sample {highcharts} highcharts/css/gauge/\n                 *         Styled mode\n                 *\n                 * @type    {*}\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                dial: {\n                    /**\n                     * The background or fill color of the gauge's dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #000000\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.backgroundColor\n                     */\n                    backgroundColor: \"#000000\" /* Palette.neutralColor100 */,\n                    /**\n                     * The length of the dial's base part, relative to the total\n                     * radius or length of the dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   70%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.baseLength\n                     */\n                    baseLength: '70%',\n                    /**\n                     * The pixel width of the base of the gauge dial. The base is\n                     * the part closest to the pivot, defined by baseLength.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   3\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.baseWidth\n                     */\n                    baseWidth: 3,\n                    /**\n                     * The border color or stroke of the gauge's dial. By default,\n                     * the borderWidth is 0, so this must be set in addition to a\n                     * custom border color.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #cccccc\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.borderColor\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The width of the gauge dial border in pixels.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.borderWidth\n                     */\n                    borderWidth: 0,\n                    /**\n                     * An array with an SVG path for the custom dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-path/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.SVGPathArray}\n                     * @since 10.2.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.path\n                     */\n                    /**\n                     * The radius or length of the dial, in percentages relative to\n                     * the radius of the gauge itself.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   80%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.radius\n                     */\n                    radius: '80%',\n                    /**\n                     * The length of the dial's rear end, the part that extends out\n                     * on the other side of the pivot. Relative to the dial's\n                     * length.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   10%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.rearLength\n                     */\n                    rearLength: '10%',\n                    /**\n                     * The width of the top of the dial, closest to the perimeter.\n                     * The pivot narrows in from the base to the top.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   1\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.topWidth\n                     */\n                    topWidth: 1\n                },\n                /**\n                 * Allow the dial to overshoot the end of the perimeter axis by\n                 * this many degrees. Say if the gauge axis goes from 0 to 60, a\n                 * value of 100, or 1000, will show 5 degrees beyond the end of the\n                 * axis when this option is set to 5.\n                 *\n                 * @see [wrap](#plotOptions.gauge.wrap)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/\n                 *         Allow 5 degrees overshoot\n                 *\n                 * @type      {number}\n                 * @since     3.0.10\n                 * @product   highcharts\n                 * @apioption plotOptions.gauge.overshoot\n                 */\n                /**\n                 * Options for the pivot or the center point of the gauge.\n                 *\n                 * In styled mode, the pivot is styled with the\n                 * `.highcharts-gauge-series .highcharts-pivot` rule.\n                 *\n                 * @sample {highcharts} highcharts/css/gauge/\n                 *         Styled mode\n                 *\n                 * @type    {*}\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                pivot: {\n                    /**\n                     * The pixel radius of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   5\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.radius\n                     */\n                    radius: 5,\n                    /**\n                     * The border or stroke width of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.borderWidth\n                     */\n                    borderWidth: 0,\n                    /**\n                     * The border or stroke color of the pivot. In able to change\n                     * this, the borderWidth must also be set to something other\n                     * than the default 0.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #cccccc\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.borderColor\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The background color or fill of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #000000\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.backgroundColor\n                     */\n                    backgroundColor: \"#000000\" /* Palette.neutralColor100 */\n                },\n                tooltip: {\n                    headerFormat: ''\n                },\n                /**\n                 * Whether to display this particular series or series type in the\n                 * legend. Defaults to false for gauge series.\n                 *\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                showInLegend: false\n                // Prototype members\n            });\n            return GaugeSeries;\n        }(Series));\n        extend(GaugeSeries.prototype, {\n            // chart.angular will be set to true when a gauge series is present,\n            // and this will be used on the axes\n            angular: true,\n            directTouch: true,\n            drawGraph: noop,\n            drawTracker: ColumnSeries.prototype.drawTracker,\n            fixedBox: true,\n            forceDL: true,\n            noSharedTooltip: true,\n            pointClass: GaugePoint,\n            trackerGroups: ['group', 'dataLabelsGroup']\n        });\n        SeriesRegistry.registerSeriesType('gauge', GaugeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API options\n         *\n         * */\n        /**\n         * A `gauge` series. If the [type](#series.gauge.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.gauge\n         * @excluding animationLimit, boostThreshold, connectEnds, connectNulls,\n         *            cropThreshold, dashStyle, dataParser, dataURL, findNearestPointBy,\n         *            getExtremesFromAll, marker, negativeColor, pointPlacement, shadow,\n         *            softThreshold, stack, stacking, states, step, threshold,\n         *            turboThreshold, zoneAxis, zones, dataSorting, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.gauge\n         */\n        /**\n         * An array of data points for the series. For the `gauge` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.gauge.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        y: 6,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        y: 8,\n         *        name: \"Point1\",\n         *       color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * The typical gauge only contains a single data value.\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|null|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x\n         * @product   highcharts\n         * @apioption series.gauge.data\n         */\n        ''; // adds the doclets above in the transpiled file\n\n        return GaugeSeries;\n    });\n    _registerModule(_modules, 'Series/DragNodesComposition.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass) {\n            if (composedClasses.indexOf(ChartClass) === -1) {\n                composedClasses.push(ChartClass);\n                addEvent(ChartClass, 'load', onChartLoad);\n            }\n        }\n        /**\n         * Draggable mode:\n         * @private\n         */\n        function onChartLoad() {\n            var chart = this;\n            var mousedownUnbinder,\n                mousemoveUnbinder,\n                mouseupUnbinder;\n            if (chart.container) {\n                mousedownUnbinder = addEvent(chart.container, 'mousedown', function (event) {\n                    var point = chart.hoverPoint;\n                    if (point &&\n                        point.series &&\n                        point.series.hasDraggableNodes &&\n                        point.series.options.draggable) {\n                        point.series.onMouseDown(point, event);\n                        mousemoveUnbinder = addEvent(chart.container, 'mousemove', function (e) { return (point &&\n                            point.series &&\n                            point.series.onMouseMove(point, e)); });\n                        mouseupUnbinder = addEvent(chart.container.ownerDocument, 'mouseup', function (e) {\n                            mousemoveUnbinder();\n                            mouseupUnbinder();\n                            return point &&\n                                point.series &&\n                                point.series.onMouseUp(point, e);\n                        });\n                    }\n                });\n            }\n            addEvent(chart, 'destroy', function () {\n                mousedownUnbinder();\n            });\n        }\n        /**\n         * Mouse down action, initializing drag&drop mode.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         * @param {Highcharts.PointerEventObject} event\n         *        Browser event, before normalization.\n         */\n        function onMouseDown(point, event) {\n            var normalizedEvent = this.chart.pointer.normalize(event);\n            point.fixedPosition = {\n                chartX: normalizedEvent.chartX,\n                chartY: normalizedEvent.chartY,\n                plotX: point.plotX,\n                plotY: point.plotY\n            };\n            point.inDragMode = true;\n        }\n        /**\n         * Mouse move action during drag&drop.\n         *\n         * @private\n         *\n         * @param {global.Event} event\n         *        Browser event, before normalization.\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         *\n         */\n        function onMouseMove(point, event) {\n            if (point.fixedPosition && point.inDragMode) {\n                var series = this,\n                    chart = series.chart,\n                    normalizedEvent = chart.pointer.normalize(event),\n                    diffX = point.fixedPosition.chartX - normalizedEvent.chartX,\n                    diffY = point.fixedPosition.chartY - normalizedEvent.chartY,\n                    graphLayoutsLookup = chart.graphLayoutsLookup;\n                var newPlotX = void 0,\n                    newPlotY = void 0;\n                // At least 5px to apply change (avoids simple click):\n                if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {\n                    newPlotX = point.fixedPosition.plotX - diffX;\n                    newPlotY = point.fixedPosition.plotY - diffY;\n                    if (chart.isInsidePlot(newPlotX, newPlotY)) {\n                        point.plotX = newPlotX;\n                        point.plotY = newPlotY;\n                        point.hasDragged = true;\n                        this.redrawHalo(point);\n                        graphLayoutsLookup.forEach(function (layout) {\n                            layout.restartSimulation();\n                        });\n                    }\n                }\n            }\n        }\n        /**\n         * Mouse up action, finalizing drag&drop.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         */\n        function onMouseUp(point, _event) {\n            if (point.fixedPosition) {\n                if (point.hasDragged) {\n                    if (this.layout.enableSimulation) {\n                        this.layout.start();\n                    }\n                    else {\n                        this.chart.redraw();\n                    }\n                }\n                point.inDragMode = point.hasDragged = false;\n                if (!this.options.fixedDraggable) {\n                    delete point.fixedPosition;\n                }\n            }\n        }\n        /**\n         * Redraw halo on mousemove during the drag&drop action.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that should show halo.\n         */\n        function redrawHalo(point) {\n            if (point && this.halo) {\n                this.halo.attr({\n                    d: point.haloPath(this.options.states.hover.halo.size)\n                });\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var DragNodesComposition = {\n                compose: compose,\n                onMouseDown: onMouseDown,\n                onMouseMove: onMouseMove,\n                onMouseUp: onMouseUp,\n                redrawHalo: redrawHalo\n            };\n\n        return DragNodesComposition;\n    });\n    _registerModule(_modules, 'Series/GraphLayoutComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Utilities.js']], function (A, U) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setAnimation = A.setAnimation;\n        var addEvent = U.addEvent;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        var integrations = {};\n        var layouts = {};\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass) {\n            if (composedClasses.indexOf(ChartClass)) {\n                composedClasses.push(ChartClass);\n                addEvent(ChartClass, 'afterPrint', onChartAfterPrint);\n                addEvent(ChartClass, 'beforePrint', onChartBeforePrint);\n                addEvent(ChartClass, 'predraw', onChartPredraw);\n                addEvent(ChartClass, 'render', onChartRender);\n            }\n        }\n        /**\n         * Re-enable simulation after print.\n         * @private\n         */\n        function onChartAfterPrint() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    // return to default simulation\n                    layout.updateSimulation();\n                });\n                this.redraw();\n            }\n        }\n        /**\n         * Disable simulation before print if enabled.\n         * @private\n         */\n        function onChartBeforePrint() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    layout.updateSimulation(false);\n                });\n                this.redraw();\n            }\n        }\n        /**\n         * Clear previous layouts.\n         * @private\n         */\n        function onChartPredraw() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    layout.stop();\n                });\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartRender() {\n            var systemsStable,\n                afterRender = false;\n            var layoutStep = function (layout) {\n                    if (layout.maxIterations-- &&\n                        isFinite(layout.temperature) &&\n                        !layout.isStable() &&\n                        !layout.enableSimulation) {\n                        // Hook similar to build-in addEvent, but instead of\n                        // creating whole events logic, use just a function.\n                        // It's faster which is important for rAF code.\n                        // Used e.g. in packed-bubble series for bubble radius\n                        // calculations\n                        if (layout.beforeStep) {\n                            layout.beforeStep();\n                    }\n                    layout.step();\n                    systemsStable = false;\n                    afterRender = true;\n                }\n            };\n            if (this.graphLayoutsLookup) {\n                setAnimation(false, this);\n                // Start simulation\n                this.graphLayoutsLookup.forEach(function (layout) { return layout.start(); });\n                // Just one sync step, to run different layouts similar to\n                // async mode.\n                while (!systemsStable) {\n                    systemsStable = true;\n                    this.graphLayoutsLookup.forEach(layoutStep);\n                }\n                if (afterRender) {\n                    this.series.forEach(function (series) {\n                        if (series && series.layout) {\n                            series.render();\n                        }\n                    });\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var GraphLayoutComposition = {\n                compose: compose,\n                integrations: integrations,\n                layouts: layouts\n            };\n\n        return GraphLayoutComposition;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubblePoint.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js']], function (Chart, Point, SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var BubblePoint = SeriesRegistry.seriesTypes.bubble.prototype.pointClass;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var PackedBubblePoint = /** @class */ (function (_super) {\n                __extends(PackedBubblePoint, _super);\n            function PackedBubblePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.degree = NaN;\n                _this.mass = NaN;\n                _this.radius = NaN;\n                _this.options = void 0;\n                _this.series = void 0;\n                _this.value = null;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Destroy point.\n             * Then remove point from the layout.\n             * @private\n             */\n            PackedBubblePoint.prototype.destroy = function () {\n                if (this.series.layout) {\n                    this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n                }\n                return Point.prototype.destroy.apply(this, arguments);\n            };\n            PackedBubblePoint.prototype.firePointEvent = function () {\n                var point = this,\n                    series = this.series,\n                    seriesOptions = series.options;\n                if (this.isParentNode && seriesOptions.parentNode) {\n                    var temp = seriesOptions.allowPointSelect;\n                    seriesOptions.allowPointSelect = (seriesOptions.parentNode.allowPointSelect);\n                    Point.prototype.firePointEvent.apply(this, arguments);\n                    seriesOptions.allowPointSelect = temp;\n                }\n                else {\n                    Point.prototype.firePointEvent.apply(this, arguments);\n                }\n            };\n            PackedBubblePoint.prototype.select = function () {\n                var point = this,\n                    series = this.series,\n                    chart = series.chart;\n                if (point.isParentNode) {\n                    chart.getSelectedPoints = chart.getSelectedParentNodes;\n                    Point.prototype.select.apply(this, arguments);\n                    chart.getSelectedPoints = Chart.prototype.getSelectedPoints;\n                }\n                else {\n                    Point.prototype.select.apply(this, arguments);\n                }\n            };\n            return PackedBubblePoint;\n        }(BubblePoint));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PackedBubblePoint;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        var isNumber = U.isNumber;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * A packed bubble series is a two dimensional series type, where each point\n         * renders a value in X, Y position. Each point is drawn as a bubble\n         * where the bubbles don't overlap with each other and the radius\n         * of the bubble relates to the value.\n         *\n         * @sample highcharts/demo/packed-bubble/\n         *         Packed bubble chart\n         * @sample highcharts/demo/packed-bubble-split/\n         *         Split packed bubble chart\n         *\n         * @extends      plotOptions.bubble\n         * @excluding    connectEnds, connectNulls, cropThreshold, dragDrop, jitter,\n         *               keys, pointPlacement, sizeByAbsoluteValue, step, xAxis,\n         *               yAxis, zMax, zMin, dataSorting, boostThreshold,\n         *               boostBlending\n         * @product      highcharts\n         * @since        7.0.0\n         * @requires     highcharts-more\n         * @optionparent plotOptions.packedbubble\n         *\n         * @private\n         */\n        var PackedBubbleSeriesDefaults = {\n                /**\n                 * Minimum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the value of each bubble.\n                 * Can be either pixels (when no unit is given),\n            or a percentage of\n                 * the smallest one of the plot width and height,\n            divided by the square\n                 * root of total number of points.\n                 *\n                 * @sample highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type {number|string}\n                 *\n                 * @private\n                 */\n                minSize: '10%',\n                /**\n                 * Maximum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the value of each bubble.\n                 * Can be either pixels (when no unit is given),\n            or a percentage of\n                 * the smallest one of the plot width and height,\n            divided by the square\n                 * root of total number of points.\n                 *\n                 * @sample highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type {number|string}\n                 *\n                 * @private\n                 */\n                maxSize: '50%',\n                sizeBy: 'area',\n                zoneAxis: 'y',\n                crisp: false,\n                tooltip: {\n                    pointFormat: 'Value: {point.value}'\n                },\n                /**\n                 * Flag to determine if nodes are draggable or not. Available for\n                 * graph with useSimulation set to true only.\n                 *\n                 * @since 7.1.0\n                 *\n                 * @private\n                 */\n                draggable: true,\n                /**\n                 * An option is giving a possibility to choose between using simulation\n                 * for calculating bubble positions. These reflects in both animation\n                 * and final position of bubbles. Simulation is also adding options to\n                 * the series graph based on used layout. In case of big data sets,\n            with\n                 * any performance issues,\n            it is possible to disable animation and pack\n                 * bubble in a simple circular way.\n                 *\n                 * @sample highcharts/series-packedbubble/spiral/\n                 *         useSimulation set to false\n                 *\n                 * @since 7.1.0\n                 *\n                 * @private\n                 */\n                useSimulation: true,\n                /**\n                 * Series options for parent nodes.\n                 *\n                 * @since 8.1.1\n                 *\n                 * @private\n                 */\n                parentNode: {\n                    /**\n                     * Allow this series' parent nodes to be selected\n                     * by clicking on the graph.\n                     *\n                     * @since 8.1.1\n                     */\n                    allowPointSelect: false\n                },\n                /**\n                /**\n                 *\n                 * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject\n                 *\n                 * @private\n                 */\n                dataLabels: {\n                    /**\n                     * The\n                     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n                     * specifying what to show for _node_ in the networkgraph. In v7.0\n                     * defaults to `{key}`,\n            since v7.1 defaults to `undefined` and\n                     * `formatter` is used instead.\n                     *\n                     * @type      {string}\n                     * @since     7.0.0\n                     * @apioption plotOptions.packedbubble.dataLabels.format\n                     */\n                    // eslint-disable-next-line valid-jsdoc\n                    /**\n                     * Callback JavaScript function to format the data label for a node.\n                     * Note that if a `format` is defined,\n            the format takes precedence\n                     * and the formatter is ignored.\n                     *\n                     * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}\n                     * @since 7.0.0\n                     */\n                    formatter: function () {\n                        var numberFormatter = this.series.chart.numberFormatter;\n                    var value = this.point.value;\n                    return isNumber(value) ? numberFormatter(value, -1) : '';\n                },\n                /**\n                 * @type      {string}\n                 * @since     7.1.0\n                 * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat\n                 */\n                // eslint-disable-next-line valid-jsdoc\n                /**\n                 * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}\n                 * @since 7.1.0\n                 */\n                parentNodeFormatter: function () {\n                    return this.name;\n                },\n                /**\n                 * @sample {highcharts} highcharts/series-packedbubble/packed-dashboard\n                 *         Dashboard with dataLabels on parentNodes\n                 *\n                 * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject\n                 * @since   7.1.0\n                 */\n                parentNodeTextPath: {\n                    /**\n                     * Presentation attributes for the text path.\n                     *\n                     * @type      {Highcharts.SVGAttributes}\n                     * @since     7.1.0\n                     * @apioption plotOptions.packedbubble.dataLabels.attributes\n                     */\n                    /**\n                     * Enable or disable `textPath` option for link's or marker's\n                     * data labels.\n                     *\n                     * @since 7.1.0\n                     */\n                    enabled: true\n                },\n                /**\n                 * Options for a _node_ label text which should follow marker's\n                 * shape.\n                 *\n                 * **Note:** Only SVG-based renderer supports this option.\n                 *\n                 * @extends   plotOptions.series.dataLabels.textPath\n                 * @apioption plotOptions.packedbubble.dataLabels.textPath\n                 */\n                padding: 0,\n                style: {\n                    transition: 'opacity 2000ms'\n                }\n            },\n            /**\n             * Options for layout algorithm when simulation is enabled. Inside there\n             * are options to change the speed, padding, initial bubbles positions\n             * and more.\n             *\n             * @extends   plotOptions.networkgraph.layoutAlgorithm\n             * @excluding approximation, attractiveForce, repulsiveForce, theta\n             * @since     7.1.0\n             *\n             * @private\n             */\n            layoutAlgorithm: {\n                /**\n                 * Initial layout algorithm for positioning nodes. Can be one of\n                 * the built-in options (\"circle\", \"random\") or a function where\n                 * positions should be set on each node (`this.nodes`) as\n                 * `node.plotX` and `node.plotY`.\n                 *\n                 * @sample highcharts/series-networkgraph/initial-positions/\n                 *         Initial positions with callback\n                 *\n                 * @type {\"circle\"|\"random\"|Function}\n                 */\n                initialPositions: 'circle',\n                /**\n                 * @sample highcharts/series-packedbubble/initial-radius/\n                 *         Initial radius set to 200\n                 *\n                 * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius\n                 * @excluding states\n                 */\n                initialPositionRadius: 20,\n                /**\n                 * The distance between two bubbles, when the algorithm starts to\n                 * treat two bubbles as overlapping. The `bubblePadding` is also the\n                 * expected distance between all the bubbles on simulation end.\n                 */\n                bubblePadding: 5,\n                /**\n                 * Whether bubbles should interact with their parentNode to keep\n                 * them inside.\n                 */\n                parentNodeLimit: false,\n                /**\n                 * Whether series should interact with each other or not. When\n                 * `parentNodeLimit` is set to true, thi option should be set to\n                 * false to avoid sticking points in wrong series parentNode.\n                 */\n                seriesInteraction: true,\n                /**\n                 * In case of split series, this option allows user to drag and\n                 * drop points between series, for changing point related series.\n                 *\n                 * @sample highcharts/series-packedbubble/packed-dashboard/\n                 *         Example of drag'n drop bubbles for bubble kanban\n                 */\n                dragBetweenSeries: false,\n                /**\n                 * Layout algorithm options for parent nodes.\n                 *\n                 * @extends   plotOptions.networkgraph.layoutAlgorithm\n                 * @excluding approximation, attractiveForce, enableSimulation,\n                 *            repulsiveForce, theta\n                 */\n                parentNodeOptions: {\n                    maxIterations: 400,\n                    gravitationalConstant: 0.03,\n                    maxSpeed: 50,\n                    initialPositionRadius: 100,\n                    seriesInteraction: true,\n                    /**\n                     * Styling options for parentNodes markers. Similar to\n                     * line.marker options.\n                     *\n                     * @sample highcharts/series-packedbubble/parentnode-style/\n                     *         Bubble size\n                     *\n                     * @extends   plotOptions.series.marker\n                     * @excluding states\n                     */\n                    marker: {\n                        fillColor: null,\n                        fillOpacity: 1,\n                        lineWidth: null,\n                        lineColor: null,\n                        symbol: 'circle'\n                    }\n                },\n                enableSimulation: true,\n                /**\n                 * Type of the algorithm used when positioning bubbles.\n                 * @ignore-option\n                 */\n                type: 'packedbubble',\n                /**\n                 * Integration type. Integration determines how forces are applied\n                 * on particles. The `packedbubble` integration is based on\n                 * the networkgraph `verlet` integration, where the new position\n                 * is based on a previous position without velocity:\n                 * `newPosition += previousPosition - newPosition`.\n                 *\n                 * @sample highcharts/series-networkgraph/forces/\n                 *\n                 * @ignore-option\n                 */\n                integration: 'packedbubble',\n                maxIterations: 1000,\n                /**\n                 * Whether to split series into individual groups or to mix all\n                 * series together.\n                 *\n                 * @since   7.1.0\n                 * @default false\n                 */\n                splitSeries: false,\n                /**\n                 * Max speed that node can get in one iteration. In terms of\n                 * simulation, it's a maximum translation (in pixels) that a node\n                 * can move (in both, x and y, dimensions). While `friction` is\n                 * applied on all nodes, max speed is applied only for nodes that\n                 * move very fast, for example small or disconnected ones.\n                 *\n                 * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)\n                 *\n                 * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)\n                 */\n                maxSpeed: 5,\n                gravitationalConstant: 0.01,\n                friction: -0.981\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `packedbubble` series. If the [type](#series.packedbubble.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @type      {Object}\n         * @extends   series,plotOptions.packedbubble\n         * @excluding cropThreshold, dataParser, dataSorting, dataURL, dragDrop, stack,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.packedbubble\n         */\n        /**\n         * An array of data points for the series. For the `packedbubble` series type,\n         * points can be given in the following ways:\n         *\n         * 1.  An array of `values`.\n         *\n         *  ```js\n         *     data: [5, 1, 20]\n         *  ```\n         *\n         * 2.  An array of objects with named values. The objects are point\n         * configuration objects as seen below. If the total number of data points\n         * exceeds the series' [turboThreshold](#series.packedbubble.turboThreshold),\n         * this option is not available.\n         *\n         *  ```js\n         *     data: [{\n         *         value: 1,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         value: 5,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *  ```\n         *\n         * @type      {Array<Object|Array>}\n         * @extends   series.line.data\n         * @excluding marker, x, y\n         * @sample    {highcharts} highcharts/series/data-array-of-objects/\n         *            Config objects\n         * @product   highcharts\n         * @apioption series.packedbubble.data\n         */\n        /**\n         * @type      {Highcharts.SeriesPackedBubbleDataLabelsOptionsObject|Array<Highcharts.SeriesPackedBubbleDataLabelsOptionsObject>}\n         * @product   highcharts\n         * @apioption series.packedbubble.data.dataLabels\n         */\n        /**\n         * @excluding enabled,enabledThreshold,height,radius,width\n         * @product   highcharts\n         * @apioption series.packedbubble.marker\n         */\n        ''; // adds doclets above to transpiled file\n\n        return PackedBubbleSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/VerletIntegration.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Attractive force.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         * @param {Highcharts.Point} link\n         *        Link that connects two nodes\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distance\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function attractive(link, force, distanceXY) {\n            var massFactor = link.getMass(),\n                translatedX = -distanceXY.x * force * this.diffTemperature,\n                translatedY = -distanceXY.y * force * this.diffTemperature;\n            if (!link.fromNode.fixedPosition) {\n                link.fromNode.plotX -=\n                    translatedX * massFactor.fromNode / link.fromNode.degree;\n                link.fromNode.plotY -=\n                    translatedY * massFactor.fromNode / link.fromNode.degree;\n            }\n            if (!link.toNode.fixedPosition) {\n                link.toNode.plotX +=\n                    translatedX * massFactor.toNode / link.toNode.degree;\n                link.toNode.plotY +=\n                    translatedY * massFactor.toNode / link.toNode.degree;\n            }\n        }\n        /**\n         * Attractive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.attractiveForce`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function attractiveForceFunction(d, k) {\n            // Used in API:\n            return (k - d) / d;\n        }\n        /**\n         * Barycenter force. Calculate and applys barycenter forces on the\n         * nodes. Making them closer to the center of their barycenter point.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         */\n        function barycenter() {\n            var gravitationalConstant = this.options.gravitationalConstant,\n                xFactor = this.barycenter.xFactor,\n                yFactor = this.barycenter.yFactor;\n            // To consider:\n            xFactor = (xFactor - (this.box.left + this.box.width) / 2) *\n                gravitationalConstant;\n            yFactor = (yFactor - (this.box.top + this.box.height) / 2) *\n                gravitationalConstant;\n            this.nodes.forEach(function (node) {\n                if (!node.fixedPosition) {\n                    node.plotX -=\n                        xFactor / node.mass / node.degree;\n                    node.plotY -=\n                        yFactor / node.mass / node.degree;\n                }\n            });\n        }\n        /**\n         * Estiamte the best possible distance between two nodes, making graph\n         * readable.\n         * @private\n         */\n        function getK(layout) {\n            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);\n        }\n        /**\n         * Integration method.\n         *\n         * In Verlet integration, forces are applied on node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * Verlet without velocity:\n         *\n         *    x(n+1) = 2 * x(n) - x(n-1) + A(T) * deltaT ^ 2\n         *\n         * where:\n         *     - x(n+1) - new position\n         *     - x(n) - current position\n         *     - x(n-1) - previous position\n         *\n         * Assuming A(t) = 0 (no acceleration) and (deltaT = 1) we get:\n         *\n         *     x(n+1) = x(n) + (x(n) - x(n-1))\n         *\n         * where:\n         *     - (x(n) - x(n-1)) - position change\n         *\n         * TO DO:\n         * Consider Verlet with velocity to support additional\n         * forces. Or even Time-Corrected Verlet by Jonathan\n         * \"lonesock\" Dummer\n         *\n         * @private\n         * @param {Highcharts.NetworkgraphLayout} layout layout object\n         * @param {Highcharts.Point} node node that should be translated\n         */\n        function integrate(layout, node) {\n            var friction = -layout.options.friction,\n                maxSpeed = layout.options.maxSpeed,\n                prevX = node.prevX,\n                prevY = node.prevY, \n                // Apply friciton:\n                diffX = ((node.plotX + node.dispX -\n                    prevX) * friction),\n                diffY = ((node.plotY + node.dispY -\n                    prevY) * friction),\n                abs = Math.abs,\n                signX = abs(diffX) / (diffX || 1), // need to deal with 0\n                signY = abs(diffY) / (diffY || 1);\n            // Apply max speed:\n            diffX = signX * Math.min(maxSpeed, Math.abs(diffX));\n            diffY = signY * Math.min(maxSpeed, Math.abs(diffY));\n            // Store for the next iteration:\n            node.prevX = node.plotX + node.dispX;\n            node.prevY = node.plotY + node.dispY;\n            // Update positions:\n            node.plotX += diffX;\n            node.plotY += diffY;\n            node.temperature = layout.vectorLength({\n                x: diffX,\n                y: diffY\n            });\n        }\n        /**\n         * Repulsive force.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         * @param {Highcharts.Point} node\n         *        Node that should be translated by force.\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distance\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function repulsive(node, force, distanceXY) {\n            var factor = force * this.diffTemperature / node.mass / node.degree;\n            if (!node.fixedPosition) {\n                node.plotX += distanceXY.x * factor;\n                node.plotY += distanceXY.y * factor;\n            }\n        }\n        /**\n         * Repulsive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.repulsiveForce`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function repulsiveForceFunction(d, k) {\n            // Used in API:\n            return (k - d) / d * (k > d ? 1 : 0); // Force only for close nodes\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var VerletIntegration = {\n                attractive: attractive,\n                attractiveForceFunction: attractiveForceFunction,\n                barycenter: barycenter,\n                getK: getK,\n                integrate: integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return VerletIntegration;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleIntegration.js', [_modules['Core/Globals.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function (H, VerletIntegration) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var noop = H.noop;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function barycenter() {\n            var layout = this,\n                gravitationalConstant = layout.options.gravitationalConstant,\n                box = layout.box,\n                nodes = layout.nodes;\n            var centerX,\n                centerY;\n            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                var node = nodes_1[_i];\n                if (layout.options.splitSeries && !node.isParentNode) {\n                    centerX = node.series.parentNode.plotX;\n                    centerY = node.series.parentNode.plotY;\n                }\n                else {\n                    centerX = box.width / 2;\n                    centerY = box.height / 2;\n                }\n                if (!node.fixedPosition) {\n                    node.plotX -=\n                        (node.plotX - centerX) *\n                            gravitationalConstant /\n                            (node.mass * Math.sqrt(nodes.length));\n                    node.plotY -=\n                        (node.plotY - centerY) *\n                            gravitationalConstant /\n                            (node.mass * Math.sqrt(nodes.length));\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function repulsive(node, force, distanceXY, repNode) {\n            var factor = (force * this.diffTemperature / node.mass /\n                    node.degree),\n                x = distanceXY.x * factor,\n                y = distanceXY.y * factor;\n            if (!node.fixedPosition) {\n                node.plotX += x;\n                node.plotY += y;\n            }\n            if (!repNode.fixedPosition) {\n                repNode.plotX -= x;\n                repNode.plotY -= y;\n            }\n        }\n        /**\n         * @private\n         */\n        function repulsiveForceFunction(d, k, node, repNode) {\n            return Math.min(d, (node.marker.radius +\n                repNode.marker.radius) / 2);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var PackedBubbleIntegration = {\n                barycenter: barycenter,\n                getK: noop,\n                integrate: VerletIntegration.integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return PackedBubbleIntegration;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/EulerIntegration.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Attractive force.\n         *\n         * In Euler integration, force is stored in a node, not changing it's\n         * position. Later, in `integrate()` forces are applied on nodes.\n         *\n         * @private\n         * @param {Highcharts.Point} link\n         *        Link that connects two nodes\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distanceXY\n         *        Distance between two nodes e.g. `{x, y}`\n         * @param {number} distanceR\n             */\n        function attractive(link, force, distanceXY, distanceR) {\n            var massFactor = link.getMass(),\n                translatedX = (distanceXY.x / distanceR) * force,\n                translatedY = (distanceXY.y / distanceR) * force;\n            if (!link.fromNode.fixedPosition) {\n                link.fromNode.dispX -=\n                    translatedX * massFactor.fromNode / link.fromNode.degree;\n                link.fromNode.dispY -=\n                    translatedY * massFactor.fromNode / link.fromNode.degree;\n            }\n            if (!link.toNode.fixedPosition) {\n                link.toNode.dispX +=\n                    translatedX * massFactor.toNode / link.toNode.degree;\n                link.toNode.dispY +=\n                    translatedY * massFactor.toNode / link.toNode.degree;\n            }\n        }\n        /**\n         * Attractive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.attractiveForce`\n         *\n         * Other forces that can be used:\n         *\n         * basic, not recommended:\n         *    `function (d, k) { return d / k }`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function attractiveForceFunction(d, k) {\n            return d * d / k;\n        }\n        /**\n         * Barycenter force. Calculate and applys barycenter forces on the\n         * nodes. Making them closer to the center of their barycenter point.\n         *\n         * In Euler integration, force is stored in a node, not changing it's\n         * position. Later, in `integrate()` forces are applied on nodes.\n         *\n         * @private\n         */\n        function barycenter() {\n            var gravitationalConstant = this.options.gravitationalConstant,\n                xFactor = this.barycenter.xFactor,\n                yFactor = this.barycenter.yFactor;\n            this.nodes.forEach(function (node) {\n                if (!node.fixedPosition) {\n                    var degree = node.getDegree(),\n                        phi = degree * (1 + degree / 2);\n                    node.dispX += ((xFactor - node.plotX) *\n                        gravitationalConstant *\n                        phi / node.degree);\n                    node.dispY += ((yFactor - node.plotY) *\n                        gravitationalConstant *\n                        phi / node.degree);\n                }\n            });\n        }\n        /**\n         * Estiamte the best possible distance between two nodes, making graph\n         * readable.\n         * @private\n         */\n        function getK(layout) {\n            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);\n        }\n        /**\n         * Integration method.\n         *\n         * In Euler integration, force were stored in a node, not changing it's\n         * position. Now, in the integrator method, we apply changes.\n         *\n         * Euler:\n         *\n         * Basic form: `x(n+1) = x(n) + v(n)`\n         *\n         * With Rengoild-Fruchterman we get:\n         * `x(n+1) = x(n) + v(n) / length(v(n)) * min(v(n), temperature(n))`\n         * where:\n         * - `x(n+1)`: next position\n         * - `x(n)`: current position\n         * - `v(n)`: velocity (comes from net force)\n         * - `temperature(n)`: current temperature\n         *\n         * Known issues:\n         * Oscillations when force vector has the same magnitude but opposite\n         * direction in the next step. Potentially solved by decreasing force by\n         * `v * (1 / node.degree)`\n         *\n         * Note:\n         * Actually `min(v(n), temperature(n))` replaces simulated annealing.\n         *\n         * @private\n         * @param {Highcharts.NetworkgraphLayout} layout\n         *        Layout object\n         * @param {Highcharts.Point} node\n         *        Node that should be translated\n         */\n        function integrate(layout, node) {\n            var distanceR;\n            node.dispX +=\n                node.dispX * layout.options.friction;\n            node.dispY +=\n                node.dispY * layout.options.friction;\n            distanceR = node.temperature = layout.vectorLength({\n                x: node.dispX,\n                y: node.dispY\n            });\n            if (distanceR !== 0) {\n                node.plotX += (node.dispX / distanceR *\n                    Math.min(Math.abs(node.dispX), layout.temperature));\n                node.plotY += (node.dispY / distanceR *\n                    Math.min(Math.abs(node.dispY), layout.temperature));\n            }\n        }\n        /**\n         * Repulsive force.\n         *\n         * @private\n         * @param {Highcharts.Point} node\n         *        Node that should be translated by force.\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distanceXY\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function repulsive(node, force, distanceXY, distanceR) {\n            node.dispX +=\n                (distanceXY.x / distanceR) * force / node.degree;\n            node.dispY +=\n                (distanceXY.y / distanceR) * force / node.degree;\n        }\n        /**\n         * Repulsive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.repulsiveForce`.\n         *\n         * Other forces that can be used:\n         *\n         * basic, not recommended:\n         *    `function (d, k) { return k / d }`\n         *\n         * standard:\n         *    `function (d, k) { return k * k / d }`\n         *\n         * grid-variant:\n         *    `function (d, k) { return k * k / d * (2 * k - d > 0 ? 1 : 0) }`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function repulsiveForceFunction(d, k) {\n            return k * k / d;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var EulerIntegration = {\n                attractive: attractive,\n                attractiveForceFunction: attractiveForceFunction,\n                barycenter: barycenter,\n                getK: getK,\n                integrate: integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return EulerIntegration;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/QuadTreeNode.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The QuadTree node class. Used in Networkgraph chart as a base for Barnes-Hut\n         * approximation.\n         *\n         * @private\n         * @class\n         * @name Highcharts.QuadTreeNode\n         *\n         * @param {Highcharts.Dictionary<number>} box\n         *        Available space for the node\n         */\n        var QuadTreeNode = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function QuadTreeNode(box) {\n                    /* *\n                     *\n                     *  Properties\n                     *\n                     * */\n                    /**\n                     * Read only. If QuadTreeNode is an external node, Point is stored in\n                     * `this.body`.\n                     *\n                     * @name Highcharts.QuadTreeNode#body\n                     * @type {boolean|Highcharts.Point}\n                     */\n                    this.body = false;\n                /**\n                 * Read only. Internal nodes when created are empty to reserve the\n                 * space. If Point is added to this QuadTreeNode, QuadTreeNode is no\n                 * longer empty.\n                 *\n                 * @name Highcharts.QuadTreeNode#isEmpty\n                 * @type {boolean}\n                 */\n                this.isEmpty = false;\n                /**\n                 * Read only. Flag to determine if QuadTreeNode is internal (and has\n                 * subnodes with mass and central position) or external (bound to\n                 * Point).\n                 *\n                 * @name Highcharts.QuadTreeNode#isInternal\n                 * @type {boolean}\n                 */\n                this.isInternal = false;\n                /**\n                 * Read only. Array of subnodes. Empty if QuadTreeNode has just one\n                 * Point. When added another Point to this QuadTreeNode, array is\n                 * filled with four subnodes.\n                 *\n                 * @name Highcharts.QuadTreeNode#nodes\n                 * @type {Array<Highcharts.QuadTreeNode>}\n                 */\n                this.nodes = [];\n                /**\n                 * Read only. The available space for node.\n                 *\n                 * @name Highcharts.QuadTreeNode#box\n                 * @type {Highcharts.Dictionary<number>}\n                 */\n                this.box = box;\n                /**\n                 * Read only. The minium of width and height values.\n                 *\n                 * @name Highcharts.QuadTreeNode#boxSize\n                 * @type {number}\n                 */\n                this.boxSize = Math.min(box.width, box.height);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * When inserting another node into the box, that already hove one node,\n             * divide the available space into another four quadrants.\n             *\n             * Indexes of quadrants are:\n             * ```\n             * -------------               -------------\n             * |           |               |     |     |\n             * |           |               |  0  |  1  |\n             * |           |   divide()    |     |     |\n             * |     1     | ----------->  -------------\n             * |           |               |     |     |\n             * |           |               |  3  |  2  |\n             * |           |               |     |     |\n             * -------------               -------------\n             * ```\n             */\n            QuadTreeNode.prototype.divideBox = function () {\n                var halfWidth = this.box.width / 2,\n                    halfHeight = this.box.height / 2;\n                // Top left\n                this.nodes[0] = new QuadTreeNode({\n                    left: this.box.left,\n                    top: this.box.top,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Top right\n                this.nodes[1] = new QuadTreeNode({\n                    left: this.box.left + halfWidth,\n                    top: this.box.top,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Bottom right\n                this.nodes[2] = new QuadTreeNode({\n                    left: this.box.left + halfWidth,\n                    top: this.box.top + halfHeight,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Bottom left\n                this.nodes[3] = new QuadTreeNode({\n                    left: this.box.left,\n                    top: this.box.top + halfHeight,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n            };\n            /**\n             * Determine which of the quadrants should be used when placing node in\n             * the QuadTree. Returned index is always in range `< 0 , 3 >`.\n             * @private\n             */\n            QuadTreeNode.prototype.getBoxPosition = function (point) {\n                var left = point.plotX < this.box.left + this.box.width / 2,\n                    top = point.plotY < this.box.top + this.box.height / 2;\n                var index;\n                if (left) {\n                    if (top) {\n                        // Top left\n                        index = 0;\n                    }\n                    else {\n                        // Bottom left\n                        index = 3;\n                    }\n                }\n                else {\n                    if (top) {\n                        // Top right\n                        index = 1;\n                    }\n                    else {\n                        // Bottom right\n                        index = 2;\n                    }\n                }\n                return index;\n            };\n            /**\n             * Insert recursively point(node) into the QuadTree. If the given\n             * quadrant is already occupied, divide it into smaller quadrants.\n             *\n             * @param {Highcharts.Point} point\n             *        Point/node to be inserted\n             * @param {number} depth\n             *        Max depth of the QuadTree\n             */\n            QuadTreeNode.prototype.insert = function (point, depth) {\n                var newQuadTreeNode;\n                if (this.isInternal) {\n                    // Internal node:\n                    this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);\n                }\n                else {\n                    this.isEmpty = false;\n                    if (!this.body) {\n                        // First body in a quadrant:\n                        this.isInternal = false;\n                        this.body = point;\n                    }\n                    else {\n                        if (depth) {\n                            // Every other body in a quadrant:\n                            this.isInternal = true;\n                            this.divideBox();\n                            // Reinsert main body only once:\n                            if (this.body !== true) {\n                                this.nodes[this.getBoxPosition(this.body)]\n                                    .insert(this.body, depth - 1);\n                                this.body = true;\n                            }\n                            // Add second body:\n                            this.nodes[this.getBoxPosition(point)]\n                                .insert(point, depth - 1);\n                        }\n                        else {\n                            // We are below max allowed depth. That means either:\n                            // - really huge number of points\n                            // - falling two points into exactly the same position\n                            // In this case, create another node in the QuadTree.\n                            //\n                            // Alternatively we could add some noise to the\n                            // position, but that could result in different\n                            // rendered chart in exporting.\n                            newQuadTreeNode = new QuadTreeNode({\n                                top: point.plotX || NaN,\n                                left: point.plotY || NaN,\n                                // Width/height below 1px\n                                width: 0.1,\n                                height: 0.1\n                            });\n                            newQuadTreeNode.body = point;\n                            newQuadTreeNode.isInternal = false;\n                            this.nodes.push(newQuadTreeNode);\n                        }\n                    }\n                }\n            };\n            /**\n             * Each quad node requires it's mass and center position. That mass and\n             * position is used to imitate real node in the layout by approximation.\n             */\n            QuadTreeNode.prototype.updateMassAndCenter = function () {\n                var mass = 0,\n                    plotX = 0,\n                    plotY = 0;\n                if (this.isInternal) {\n                    // Calcualte weightened mass of the quad node:\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var pointMass = _a[_i];\n                        if (!pointMass.isEmpty) {\n                            mass += pointMass.mass;\n                            plotX += pointMass.plotX * pointMass.mass;\n                            plotY += pointMass.plotY * pointMass.mass;\n                        }\n                    }\n                    plotX /= mass;\n                    plotY /= mass;\n                }\n                else if (this.body) {\n                    // Just one node, use coordinates directly:\n                    mass = this.body.mass;\n                    plotX = this.body.plotX;\n                    plotY = this.body.plotY;\n                }\n                // Store details:\n                this.mass = mass;\n                this.plotX = plotX;\n                this.plotY = plotY;\n            };\n            return QuadTreeNode;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return QuadTreeNode;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/QuadTree.js', [_modules['Series/Networkgraph/QuadTreeNode.js']], function (QuadTreeNode) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The QuadTree class. Used in Networkgraph chart as a base for Barnes-Hut\n         * approximation.\n         *\n         * @private\n         * @class\n         * @name Highcharts.QuadTree\n         *\n         * @param {number} x\n         *        Left position of the plotting area\n         * @param {number} y\n         *        Top position of the plotting area\n         * @param {number} width\n         *        Width of the plotting area\n         * @param {number} height\n         *        Height of the plotting area\n         */\n        var QuadTree = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function QuadTree(x, y, width, height) {\n                    // Boundary rectangle:\n                    this.box = {\n                        left: x,\n                        top: y,\n                        width: width,\n                        height: height\n                    };\n                this.maxDepth = 25;\n                this.root = new QuadTreeNode(this.box);\n                this.root.isInternal = true;\n                this.root.isRoot = true;\n                this.root.divideBox();\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Calculate mass of the each QuadNode in the tree.\n             */\n            QuadTree.prototype.calculateMassAndCenter = function () {\n                this.visitNodeRecursive(null, null, function (node) {\n                    node.updateMassAndCenter();\n                });\n            };\n            /**\n             * Insert nodes into the QuadTree\n             *\n             * @param {Array<Highcharts.Point>} points\n             *        Points as nodes\n             */\n            QuadTree.prototype.insertNodes = function (points) {\n                for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n                    var point = points_1[_i];\n                    this.root.insert(point, this.maxDepth);\n                }\n            };\n            /**\n             * Depfth first treversal (DFS). Using `before` and `after` callbacks,\n             * we can get two results: preorder and postorder traversals, reminder:\n             *\n             * ```\n             *     (a)\n             *     / \\\n             *   (b) (c)\n             *   / \\\n             * (d) (e)\n             * ```\n             *\n             * DFS (preorder): `a -> b -> d -> e -> c`\n             *\n             * DFS (postorder): `d -> e -> b -> c -> a`\n             *\n             * @param {Highcharts.QuadTreeNode|null} node\n             *        QuadTree node\n             * @param {Function} [beforeCallback]\n             *        Function to be called before visiting children nodes.\n             * @param {Function} [afterCallback]\n             *        Function to be called after visiting children nodes.\n             */\n            QuadTree.prototype.visitNodeRecursive = function (node, beforeCallback, afterCallback) {\n                var goFurther;\n                if (!node) {\n                    node = this.root;\n                }\n                if (node === this.root && beforeCallback) {\n                    goFurther = beforeCallback(node);\n                }\n                if (goFurther === false) {\n                    return;\n                }\n                for (var _i = 0, _a = node.nodes; _i < _a.length; _i++) {\n                    var qtNode = _a[_i];\n                    if (qtNode.isInternal) {\n                        if (beforeCallback) {\n                            goFurther = beforeCallback(qtNode);\n                        }\n                        if (goFurther === false) {\n                            continue;\n                        }\n                        this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);\n                    }\n                    else if (qtNode.body) {\n                        if (beforeCallback) {\n                            beforeCallback(qtNode.body);\n                        }\n                    }\n                    if (afterCallback) {\n                        afterCallback(qtNode);\n                    }\n                }\n                if (node === this.root && afterCallback) {\n                    afterCallback(node);\n                }\n            };\n            return QuadTree;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return QuadTree;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/ReingoldFruchtermanLayout.js', [_modules['Series/Networkgraph/EulerIntegration.js'], _modules['Core/Globals.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Series/Networkgraph/QuadTree.js'], _modules['Core/Utilities.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function (EulerIntegration, H, GraphLayout, QuadTree, U, VerletIntegration) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var win = H.win;\n        var clamp = U.clamp,\n            defined = U.defined,\n            isFunction = U.isFunction,\n            pick = U.pick;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Reingold-Fruchterman algorithm from\n         * \"Graph Drawing by Force-directed Placement\" paper.\n         * @private\n         */\n        var ReingoldFruchtermanLayout = /** @class */ (function () {\n                function ReingoldFruchtermanLayout() {\n                    /* *\n                     *\n                     *  Static Functions\n                     *\n                     * */\n                    this.attractiveForce = void 0;\n                this.box = {};\n                this.currentStep = 0;\n                this.initialRendering = true;\n                this.integration = void 0;\n                this.links = [];\n                this.nodes = [];\n                this.options = void 0;\n                this.quadTree = void 0;\n                this.repulsiveForce = void 0;\n                this.series = [];\n                this.simulation = false;\n            }\n            ReingoldFruchtermanLayout.compose = function (ChartClass) {\n                GraphLayout.compose(ChartClass);\n                GraphLayout.integrations.euler = EulerIntegration;\n                GraphLayout.integrations.verlet = VerletIntegration;\n                GraphLayout.layouts['reingold-fruchterman'] =\n                    ReingoldFruchtermanLayout;\n            };\n            ReingoldFruchtermanLayout.prototype.init = function (options) {\n                this.options = options;\n                this.nodes = [];\n                this.links = [];\n                this.series = [];\n                this.box = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0\n                };\n                this.setInitialRendering(true);\n                this.integration =\n                    GraphLayout.integrations[options.integration];\n                this.enableSimulation = options.enableSimulation;\n                this.attractiveForce = pick(options.attractiveForce, this.integration.attractiveForceFunction);\n                this.repulsiveForce = pick(options.repulsiveForce, this.integration.repulsiveForceFunction);\n                this.approximation = options.approximation;\n            };\n            ReingoldFruchtermanLayout.prototype.updateSimulation = function (enable) {\n                this.enableSimulation = pick(enable, this.options.enableSimulation);\n            };\n            ReingoldFruchtermanLayout.prototype.start = function () {\n                var layout = this,\n                    series = this.series,\n                    options = this.options;\n                layout.currentStep = 0;\n                layout.forces = series[0] && series[0].forces || [];\n                layout.chart = series[0] && series[0].chart;\n                if (layout.initialRendering) {\n                    layout.initPositions();\n                    // Render elements in initial positions:\n                    series.forEach(function (s) {\n                        s.finishedAnimating = true; // #13169\n                        s.render();\n                    });\n                }\n                layout.setK();\n                layout.resetSimulation(options);\n                if (layout.enableSimulation) {\n                    layout.step();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.step = function () {\n                var _this = this;\n                var anyLayout = this,\n                    allSeries = this.series;\n                // Algorithm:\n                this.currentStep++;\n                if (this.approximation === 'barnes-hut') {\n                    this.createQuadTree();\n                    this.quadTree.calculateMassAndCenter();\n                }\n                for (var _i = 0, _a = this.forces || []; _i < _a.length; _i++) {\n                    var forceName = _a[_i];\n                    anyLayout[forceName + 'Forces'](this.temperature);\n                }\n                // Limit to the plotting area and cool down:\n                this.applyLimits();\n                // Cool down the system:\n                this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n                this.prevSystemTemperature = this.systemTemperature;\n                this.systemTemperature = this.getSystemTemperature();\n                if (this.enableSimulation) {\n                    for (var _b = 0, allSeries_1 = allSeries; _b < allSeries_1.length; _b++) {\n                        var series = allSeries_1[_b];\n                        // Chart could be destroyed during the simulation\n                        if (series.chart) {\n                            series.render();\n                        }\n                    }\n                    if (this.maxIterations-- &&\n                        isFinite(this.temperature) &&\n                        !this.isStable()) {\n                        if (this.simulation) {\n                            win.cancelAnimationFrame(this.simulation);\n                        }\n                        this.simulation = win.requestAnimationFrame(function () { return _this.step(); });\n                    }\n                    else {\n                        this.simulation = false;\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.stop = function () {\n                if (this.simulation) {\n                    win.cancelAnimationFrame(this.simulation);\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setArea = function (x, y, w, h) {\n                this.box = {\n                    left: x,\n                    top: y,\n                    width: w,\n                    height: h\n                };\n            };\n            ReingoldFruchtermanLayout.prototype.setK = function () {\n                // Optimal distance between nodes,\n                // available space around the node:\n                this.k = this.options.linkLength || this.integration.getK(this);\n            };\n            ReingoldFruchtermanLayout.prototype.addElementsToCollection = function (elements, collection) {\n                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n                    var element = elements_1[_i];\n                    if (collection.indexOf(element) === -1) {\n                        collection.push(element);\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.removeElementFromCollection = function (element, collection) {\n                var index = collection.indexOf(element);\n                if (index !== -1) {\n                    collection.splice(index, 1);\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.clear = function () {\n                this.nodes.length = 0;\n                this.links.length = 0;\n                this.series.length = 0;\n                this.resetSimulation();\n            };\n            ReingoldFruchtermanLayout.prototype.resetSimulation = function () {\n                this.forcedStop = false;\n                this.systemTemperature = 0;\n                this.setMaxIterations();\n                this.setTemperature();\n                this.setDiffTemperature();\n            };\n            ReingoldFruchtermanLayout.prototype.restartSimulation = function () {\n                if (!this.simulation) {\n                    // When dragging nodes, we don't need to calculate\n                    // initial positions and rendering nodes:\n                    this.setInitialRendering(false);\n                    // Start new simulation:\n                    if (!this.enableSimulation) {\n                        // Run only one iteration to speed things up:\n                        this.setMaxIterations(1);\n                    }\n                    else {\n                        this.start();\n                    }\n                    if (this.chart) {\n                        this.chart.redraw();\n                    }\n                    // Restore defaults:\n                    this.setInitialRendering(true);\n                }\n                else {\n                    // Extend current simulation:\n                    this.resetSimulation();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setMaxIterations = function (maxIterations) {\n                this.maxIterations = pick(maxIterations, this.options.maxIterations);\n            };\n            ReingoldFruchtermanLayout.prototype.setTemperature = function () {\n                this.temperature = this.startTemperature =\n                    Math.sqrt(this.nodes.length);\n            };\n            ReingoldFruchtermanLayout.prototype.setDiffTemperature = function () {\n                this.diffTemperature = this.startTemperature /\n                    (this.options.maxIterations + 1);\n            };\n            ReingoldFruchtermanLayout.prototype.setInitialRendering = function (enable) {\n                this.initialRendering = enable;\n            };\n            ReingoldFruchtermanLayout.prototype.createQuadTree = function () {\n                this.quadTree = new QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n                this.quadTree.insertNodes(this.nodes);\n            };\n            ReingoldFruchtermanLayout.prototype.initPositions = function () {\n                var initialPositions = this.options.initialPositions;\n                if (isFunction(initialPositions)) {\n                    initialPositions.call(this);\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var node = _a[_i];\n                        if (!defined(node.prevX)) {\n                            node.prevX = node.plotX;\n                        }\n                        if (!defined(node.prevY)) {\n                            node.prevY = node.plotY;\n                        }\n                        node.dispX = 0;\n                        node.dispY = 0;\n                    }\n                }\n                else if (initialPositions === 'circle') {\n                    this.setCircularPositions();\n                }\n                else {\n                    this.setRandomPositions();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setCircularPositions = function () {\n                var box = this.box,\n                    nodes = this.nodes,\n                    nodesLength = nodes.length + 1,\n                    angle = 2 * Math.PI / nodesLength,\n                    rootNodes = nodes.filter(function (node) {\n                        return node.linksTo.length === 0;\n                }), visitedNodes = {}, radius = this.options.initialPositionRadius, addToNodes = function (node) {\n                    for (var _i = 0, _a = node.linksFrom || []; _i < _a.length; _i++) {\n                        var link = _a[_i];\n                        if (!visitedNodes[link.toNode.id]) {\n                            visitedNodes[link.toNode.id] = true;\n                            sortedNodes.push(link.toNode);\n                            addToNodes(link.toNode);\n                        }\n                    }\n                };\n                var sortedNodes = [];\n                // Start with identified root nodes an sort the nodes by their\n                // hierarchy. In trees, this ensures that branches don't cross\n                // eachother.\n                for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                    var rootNode = rootNodes_1[_i];\n                    sortedNodes.push(rootNode);\n                    addToNodes(rootNode);\n                }\n                // Cyclic tree, no root node found\n                if (!sortedNodes.length) {\n                    sortedNodes = nodes;\n                    // Dangling, cyclic trees\n                }\n                else {\n                    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n                        var node_1 = nodes_1[_a];\n                        if (sortedNodes.indexOf(node_1) === -1) {\n                            sortedNodes.push(node_1);\n                        }\n                    }\n                }\n                var node;\n                // Initial positions are laid out along a small circle, appearing\n                // as a cluster in the middle\n                for (var i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {\n                    node = sortedNodes[i];\n                    node.plotX = node.prevX = pick(node.plotX, box.width / 2 + radius * Math.cos(i * angle));\n                    node.plotY = node.prevY = pick(node.plotY, box.height / 2 + radius * Math.sin(i * angle));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setRandomPositions = function () {\n                var box = this.box,\n                    nodes = this.nodes,\n                    nodesLength = nodes.length + 1, \n                    /**\n                     * Return a repeatable,\n                    quasi-random number based on an integer\n                     * input. For the initial positions\n                     * @private\n                     */\n                    unrandom = function (n) {\n                        var rand = n * n / Math.PI;\n                    rand = rand - Math.floor(rand);\n                    return rand;\n                };\n                var node;\n                // Initial positions:\n                for (var i = 0, iEnd = nodes.length; i < iEnd; ++i) {\n                    node = nodes[i];\n                    node.plotX = node.prevX = pick(node.plotX, box.width * unrandom(i));\n                    node.plotY = node.prevY = pick(node.plotY, box.height * unrandom(nodesLength + i));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.force = function (name) {\n                var args = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    args[_i - 1] = arguments[_i];\n                }\n                this.integration[name].apply(this, args);\n            };\n            ReingoldFruchtermanLayout.prototype.barycenterForces = function () {\n                this.getBarycenter();\n                this.force('barycenter');\n            };\n            ReingoldFruchtermanLayout.prototype.getBarycenter = function () {\n                var systemMass = 0,\n                    cx = 0,\n                    cy = 0;\n                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    cx += node.plotX * node.mass;\n                    cy += node.plotY * node.mass;\n                    systemMass += node.mass;\n                }\n                this.barycenter = {\n                    x: cx,\n                    y: cy,\n                    xFactor: cx / systemMass,\n                    yFactor: cy / systemMass\n                };\n                return this.barycenter;\n            };\n            ReingoldFruchtermanLayout.prototype.barnesHutApproximation = function (node, quadNode) {\n                var distanceXY = this.getDistXY(node,\n                    quadNode),\n                    distanceR = this.vectorLength(distanceXY);\n                var goDeeper,\n                    force;\n                if (node !== quadNode && distanceR !== 0) {\n                    if (quadNode.isInternal) {\n                        // Internal node:\n                        if (quadNode.boxSize / distanceR <\n                            this.options.theta &&\n                            distanceR !== 0) {\n                            // Treat as an external node:\n                            force = this.repulsiveForce(distanceR, this.k);\n                            this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n                            goDeeper = false;\n                        }\n                        else {\n                            // Go deeper:\n                            goDeeper = true;\n                        }\n                    }\n                    else {\n                        // External node, direct force:\n                        force = this.repulsiveForce(distanceR, this.k);\n                        this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n                    }\n                }\n                return goDeeper;\n            };\n            ReingoldFruchtermanLayout.prototype.repulsiveForces = function () {\n                var _this = this;\n                if (this.approximation === 'barnes-hut') {\n                    var _loop_1 = function (node) {\n                            this_1.quadTree.visitNodeRecursive(null,\n                        function (quadNode) { return (_this.barnesHutApproximation(node,\n                        quadNode)); });\n                    };\n                    var this_1 = this;\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var node = _a[_i];\n                        _loop_1(node);\n                    }\n                }\n                else {\n                    var force = void 0,\n                        distanceR = void 0,\n                        distanceXY = void 0;\n                    for (var _b = 0, _c = this.nodes; _b < _c.length; _b++) {\n                        var node = _c[_b];\n                        for (var _d = 0, _e = this.nodes; _d < _e.length; _d++) {\n                            var repNode = _e[_d];\n                            if (\n                            // Node cannot repulse itself:\n                            node !== repNode &&\n                                // Only close nodes affect each other:\n                                // layout.getDistR(node, repNode) < 2 * k &&\n                                // Not dragged:\n                                !node.fixedPosition) {\n                                distanceXY = this.getDistXY(node, repNode);\n                                distanceR = this.vectorLength(distanceXY);\n                                if (distanceR !== 0) {\n                                    force = this.repulsiveForce(distanceR, this.k);\n                                    this.force('repulsive', node, force * repNode.mass, distanceXY, distanceR);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.attractiveForces = function () {\n                var distanceXY,\n                    distanceR,\n                    force;\n                for (var _i = 0, _a = this.links; _i < _a.length; _i++) {\n                    var link = _a[_i];\n                    if (link.fromNode && link.toNode) {\n                        distanceXY = this.getDistXY(link.fromNode, link.toNode);\n                        distanceR = this.vectorLength(distanceXY);\n                        if (distanceR !== 0) {\n                            force = this.attractiveForce(distanceR, this.k);\n                            this.force('attractive', link, force, distanceXY, distanceR);\n                        }\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.applyLimits = function () {\n                var nodes = this.nodes;\n                for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n                    var node = nodes_2[_i];\n                    if (node.fixedPosition) {\n                        return;\n                    }\n                    this.integration.integrate(this, node);\n                    this.applyLimitBox(node, this.box);\n                    // Reset displacement:\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            /**\n             * External box that nodes should fall. When hitting an edge, node\n             * should stop or bounce.\n             * @private\n             */\n            ReingoldFruchtermanLayout.prototype.applyLimitBox = function (node, box) {\n                var radius = node.radius;\n                /*\n                TO DO: Consider elastic collision instead of stopping.\n                o' means end position when hitting plotting area edge:\n\n                - \"inelastic\":\n                o\n                    \\\n                ______\n                |  o'\n                |   \\\n                |    \\\n\n                - \"elastic\"/\"bounced\":\n                o\n                    \\\n                ______\n                |  ^\n                | / \\\n                |o'  \\\n\n                Euler sample:\n                if (plotX < 0) {\n                    plotX = 0;\n                    dispX *= -1;\n                }\n\n                if (plotX > box.width) {\n                    plotX = box.width;\n                    dispX *= -1;\n                }\n\n                */\n                // Limit X-coordinates:\n                node.plotX = clamp(node.plotX, box.left + radius, box.width - radius);\n                // Limit Y-coordinates:\n                node.plotY = clamp(node.plotY, box.top + radius, box.height - radius);\n            };\n            /**\n             * From \"A comparison of simulated annealing cooling strategies\" by\n             * Nourani and Andresen work.\n             * @private\n             */\n            ReingoldFruchtermanLayout.prototype.coolDown = function (temperature, temperatureStep, currentStep) {\n                // Logarithmic:\n                /*\n                return Math.sqrt(this.nodes.length) -\n                    Math.log(\n                        currentStep * layout.diffTemperature\n                    );\n                */\n                // Exponential:\n                /*\n                let alpha = 0.1;\n                layout.temperature = Math.sqrt(layout.nodes.length) *\n                    Math.pow(alpha, layout.diffTemperature);\n                */\n                // Linear:\n                return temperature - temperatureStep * currentStep;\n            };\n            ReingoldFruchtermanLayout.prototype.isStable = function () {\n                return Math.abs(this.systemTemperature -\n                    this.prevSystemTemperature) < 0.00001 || this.temperature <= 0;\n            };\n            ReingoldFruchtermanLayout.prototype.getSystemTemperature = function () {\n                var value = 0;\n                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    value += node.temperature;\n                }\n                return value;\n            };\n            ReingoldFruchtermanLayout.prototype.vectorLength = function (vector) {\n                return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n            };\n            ReingoldFruchtermanLayout.prototype.getDistR = function (nodeA, nodeB) {\n                var distance = this.getDistXY(nodeA,\n                    nodeB);\n                return this.vectorLength(distance);\n            };\n            ReingoldFruchtermanLayout.prototype.getDistXY = function (nodeA, nodeB) {\n                var xDist = nodeA.plotX - nodeB.plotX,\n                    yDist = nodeA.plotY - nodeB.plotY;\n                return {\n                    x: xDist,\n                    y: yDist,\n                    absX: Math.abs(xDist),\n                    absY: Math.abs(yDist)\n                };\n            };\n            return ReingoldFruchtermanLayout;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ReingoldFruchtermanLayout;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleLayout.js', [_modules['Series/GraphLayoutComposition.js'], _modules['Series/PackedBubble/PackedBubbleIntegration.js'], _modules['Series/Networkgraph/ReingoldFruchtermanLayout.js'], _modules['Core/Utilities.js']], function (GraphLayout, PackedBubbleIntegration, ReingoldFruchtermanLayout, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var addEvent = U.addEvent,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function chartGetSelectedParentNodes() {\n            var allSeries = this.series,\n                selectedParentsNodes = [];\n            allSeries.forEach(function (series) {\n                if (series.parentNode && series.parentNode.selected) {\n                    selectedParentsNodes.push(series.parentNode);\n                }\n            });\n            return selectedParentsNodes;\n        }\n        /**\n         * Remove accumulated data points to redistribute all of them again\n         * (i.e after hiding series by legend)\n         * @private\n         */\n        function onChartBeforeRedraw() {\n            if (this.allDataPoints) {\n                delete this.allDataPoints;\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var PackedBubbleLayout = /** @class */ (function (_super) {\n                __extends(PackedBubbleLayout, _super);\n            function PackedBubbleLayout() {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.index = NaN;\n                _this.nodes = [];\n                _this.options = void 0;\n                _this.series = [];\n                return _this;\n            }\n            PackedBubbleLayout.compose = function (ChartClass) {\n                ReingoldFruchtermanLayout.compose(ChartClass);\n                GraphLayout.integrations.packedbubble = PackedBubbleIntegration;\n                GraphLayout.layouts.packedbubble = PackedBubbleLayout;\n                if (composedClasses.indexOf(ChartClass) === -1) {\n                    composedClasses.push(ChartClass);\n                    addEvent(ChartClass, 'beforeRedraw', onChartBeforeRedraw);\n                    var chartProto = ChartClass.prototype;\n                    chartProto.getSelectedParentNodes = chartGetSelectedParentNodes;\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            PackedBubbleLayout.prototype.beforeStep = function () {\n                if (this.options.marker) {\n                    this.series.forEach(function (series) {\n                        if (series) {\n                            series.calculateParentRadius();\n                        }\n                    });\n                }\n            };\n            // #14439, new stable check.\n            PackedBubbleLayout.prototype.isStable = function () {\n                var tempDiff = Math.abs(this.prevSystemTemperature -\n                        this.systemTemperature);\n                var upScaledTemperature = 10 * this.systemTemperature /\n                        Math.sqrt(this.nodes.length);\n                return Math.abs(upScaledTemperature) < 1 &&\n                    tempDiff < 0.00001 ||\n                    this.temperature <= 0;\n            };\n            PackedBubbleLayout.prototype.setCircularPositions = function () {\n                var layout = this,\n                    box = layout.box,\n                    nodes = layout.nodes,\n                    nodesLength = nodes.length + 1,\n                    angle = 2 * Math.PI / nodesLength,\n                    radius = layout.options.initialPositionRadius;\n                var centerX,\n                    centerY,\n                    index = 0;\n                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                    var node = nodes_1[_i];\n                    if (layout.options.splitSeries &&\n                        !node.isParentNode) {\n                        centerX = node.series.parentNode.plotX;\n                        centerY = node.series.parentNode.plotY;\n                    }\n                    else {\n                        centerX = box.width / 2;\n                        centerY = box.height / 2;\n                    }\n                    node.plotX = node.prevX = pick(node.plotX, centerX +\n                        radius * Math.cos(node.index || index * angle));\n                    node.plotY = node.prevY = pick(node.plotY, centerY +\n                        radius * Math.sin(node.index || index * angle));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                    index++;\n                }\n            };\n            PackedBubbleLayout.prototype.repulsiveForces = function () {\n                var layout = this,\n                    bubblePadding = layout.options.bubblePadding;\n                var force,\n                    distanceR,\n                    distanceXY;\n                layout.nodes.forEach(function (node) {\n                    node.degree = node.mass;\n                    node.neighbours = 0;\n                    layout.nodes.forEach(function (repNode) {\n                        force = 0;\n                        if (\n                        // Node cannot repulse itself:\n                        node !== repNode &&\n                            // Only close nodes affect each other:\n                            // Not dragged:\n                            !node.fixedPosition &&\n                            (layout.options.seriesInteraction ||\n                                node.series === repNode.series)) {\n                            distanceXY = layout.getDistXY(node, repNode);\n                            distanceR = (layout.vectorLength(distanceXY) -\n                                (node.marker.radius +\n                                    repNode.marker.radius +\n                                    bubblePadding));\n                            // TODO padding configurable\n                            if (distanceR < 0) {\n                                node.degree += 0.01;\n                                node.neighbours++;\n                                force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);\n                            }\n                            layout.force('repulsive', node, force * repNode.mass, distanceXY, repNode, distanceR);\n                        }\n                    });\n                });\n            };\n            PackedBubbleLayout.prototype.applyLimitBox = function (node, box) {\n                var layout = this,\n                    factor = 0.01;\n                var distanceXY,\n                    distanceR;\n                // parentNodeLimit should be used together\n                // with seriesInteraction: false\n                if (layout.options.splitSeries &&\n                    !node.isParentNode &&\n                    layout.options.parentNodeLimit) {\n                    distanceXY = layout.getDistXY(node, node.series.parentNode);\n                    distanceR = (node.series.parentNodeRadius -\n                        node.marker.radius -\n                        layout.vectorLength(distanceXY));\n                    if (distanceR < 0 &&\n                        distanceR > -2 * node.marker.radius) {\n                        node.plotX -= distanceXY.x * factor;\n                        node.plotY -= distanceXY.y * factor;\n                    }\n                }\n                _super.prototype.applyLimitBox.call(this, node, box);\n            };\n            return PackedBubbleLayout;\n        }(ReingoldFruchtermanLayout));\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        GraphLayout.layouts.packedbubble = PackedBubbleLayout;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PackedBubbleLayout;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeries.js', [_modules['Core/Color/Color.js'], _modules['Series/DragNodesComposition.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Core/Globals.js'], _modules['Series/PackedBubble/PackedBubblePoint.js'], _modules['Series/PackedBubble/PackedBubbleSeriesDefaults.js'], _modules['Series/PackedBubble/PackedBubbleLayout.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Color, DragNodesComposition, GraphLayout, H, PackedBubblePoint, PackedBubbleSeriesDefaults, PackedBubbleLayout, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var color = Color.parse;\n        var noop = H.noop;\n        var seriesProto = SeriesRegistry.series.prototype,\n            BubbleSeries = SeriesRegistry.seriesTypes.bubble;\n        var addEvent = U.addEvent,\n            clamp = U.clamp,\n            defined = U.defined,\n            extend = U.extend,\n            fireEvent = U.fireEvent,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.packedbubble\n         *\n         * @extends Highcharts.Series\n         */\n        var PackedBubbleSeries = /** @class */ (function (_super) {\n                __extends(PackedBubbleSeries, _super);\n            function PackedBubbleSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.chart = void 0;\n                _this.data = void 0;\n                _this.layout = void 0;\n                _this.options = void 0;\n                _this.parentNodeMass = 0;\n                _this.points = void 0;\n                _this.xData = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            PackedBubbleSeries.compose = function (AxisClass, ChartClass, LegendClass, SeriesClass) {\n                BubbleSeries.compose(AxisClass, ChartClass, LegendClass, SeriesClass);\n                DragNodesComposition.compose(ChartClass);\n                PackedBubbleLayout.compose(ChartClass);\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Create a single array of all points from all series\n             * @private\n             */\n            PackedBubbleSeries.prototype.accumulateAllPoints = function () {\n                var chart = this.chart,\n                    allDataPoints = [];\n                var yData;\n                for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {\n                    var series = _a[_i];\n                    if (series.is('packedbubble') && // #13574\n                        series.visible ||\n                        !chart.options.chart.ignoreHiddenSeries) {\n                        yData = series.yData || [];\n                        // add data to array only if series is visible\n                        for (var j = 0; j < yData.length; j++) {\n                            allDataPoints.push([\n                                null, null,\n                                yData[j],\n                                series.index,\n                                j,\n                                {\n                                    id: j,\n                                    marker: {\n                                        radius: 0\n                                    }\n                                }\n                            ]);\n                        }\n                    }\n                }\n                return allDataPoints;\n            };\n            /**\n             * Adding the basic layout to series points.\n             * @private\n             */\n            PackedBubbleSeries.prototype.addLayout = function () {\n                var layoutOptions = this.options.layoutAlgorithm =\n                        this.options.layoutAlgorithm || {},\n                    layoutType = layoutOptions.type || 'packedbubble',\n                    chartOptions = this.chart.options.chart;\n                var graphLayoutsStorage = this.chart.graphLayoutsStorage,\n                    graphLayoutsLookup = this.chart.graphLayoutsLookup,\n                    layout;\n                if (!graphLayoutsStorage) {\n                    this.chart.graphLayoutsStorage = graphLayoutsStorage = {};\n                    this.chart.graphLayoutsLookup = graphLayoutsLookup = [];\n                }\n                layout = graphLayoutsStorage[layoutType];\n                if (!layout) {\n                    layoutOptions.enableSimulation =\n                        !defined(chartOptions.forExport) ?\n                            layoutOptions.enableSimulation :\n                            !chartOptions.forExport;\n                    graphLayoutsStorage[layoutType] = layout =\n                        new GraphLayout.layouts[layoutType]();\n                    layout.init(layoutOptions);\n                    graphLayoutsLookup.splice(layout.index, 0, layout);\n                }\n                this.layout = layout;\n                this.points.forEach(function (node) {\n                    node.mass = 2;\n                    node.degree = 1;\n                    node.collisionNmb = 1;\n                });\n                layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n                layout.addElementsToCollection([this], layout.series);\n                layout.addElementsToCollection(this.points, layout.nodes);\n            };\n            /**\n             * Function responsible for adding series layout, used for parent nodes.\n             * @private\n             */\n            PackedBubbleSeries.prototype.addSeriesLayout = function () {\n                var layoutOptions = this.options.layoutAlgorithm =\n                        this.options.layoutAlgorithm || {},\n                    layoutType = (layoutOptions.type || 'packedbubble'),\n                    graphLayoutsStorage = this.chart.graphLayoutsStorage,\n                    graphLayoutsLookup = this.chart.graphLayoutsLookup,\n                    parentNodeOptions = merge(layoutOptions,\n                    layoutOptions.parentNodeOptions, {\n                        enableSimulation: this.layout.options.enableSimulation\n                    });\n                var seriesLayout = graphLayoutsStorage[layoutType + '-series'];\n                if (!seriesLayout) {\n                    graphLayoutsStorage[layoutType + '-series'] = seriesLayout =\n                        new GraphLayout.layouts[layoutType]();\n                    seriesLayout.init(parentNodeOptions);\n                    graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout);\n                }\n                this.parentNodeLayout = seriesLayout;\n                this.createParentNodes();\n            };\n            /**\n             * The function responsible for calculating the parent node radius\n             * based on the total surface of iniside-bubbles and the group BBox\n             * @private\n             */\n            PackedBubbleSeries.prototype.calculateParentRadius = function () {\n                var bBox = this.seriesBox(),\n                    parentPadding = 20,\n                    minParentRadius = 20;\n                this.parentNodeRadius = clamp(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ?\n                    Math.max(Math.sqrt(Math.pow(bBox.width, 2) +\n                        Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) :\n                    Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);\n                if (this.parentNode) {\n                    this.parentNode.marker.radius =\n                        this.parentNode.radius = this.parentNodeRadius;\n                }\n            };\n            /**\n             * Calculate min and max bubble value for radius calculation.\n             * @private\n             */\n            PackedBubbleSeries.prototype.calculateZExtremes = function () {\n                var chart = this.chart,\n                    allSeries = chart.series;\n                var zMin = this.options.zMin,\n                    zMax = this.options.zMax,\n                    valMin = Infinity,\n                    valMax = -Infinity;\n                if (zMin && zMax) {\n                    return [zMin, zMax];\n                }\n                // it is needed to deal with null\n                // and undefined values\n                allSeries.forEach(function (series) {\n                    series.yData.forEach(function (y) {\n                        if (defined(y)) {\n                            if (y > valMax) {\n                                valMax = y;\n                            }\n                            if (y < valMin) {\n                                valMin = y;\n                            }\n                        }\n                    });\n                });\n                zMin = pick(zMin, valMin);\n                zMax = pick(zMax, valMax);\n                return [zMin, zMax];\n            };\n            /**\n             * Check if two bubbles overlaps.\n             * @private\n             */\n            PackedBubbleSeries.prototype.checkOverlap = function (bubble1, bubble2) {\n                var diffX = bubble1[0] - bubble2[0], // diff of X center values\n                    diffY = bubble1[1] - bubble2[1], // diff of Y center values\n                    sumRad = bubble1[2] + bubble2[2]; // sum of bubble radius\n                    return (Math.sqrt(diffX * diffX + diffY * diffY) -\n                        Math.abs(sumRad)) < -0.001;\n            };\n            /**\n             * Creating parent nodes for split series, in which all the bubbles\n             * are rendered.\n             * @private\n             */\n            PackedBubbleSeries.prototype.createParentNodes = function () {\n                var _this = this;\n                var PackedBubblePoint = this.pointClass,\n                    chart = this.chart,\n                    parentNodeLayout = this.parentNodeLayout,\n                    layoutOptions = this.layout.options;\n                var nodeAdded,\n                    parentNode = this.parentNode,\n                    parentMarkerOptions = {\n                        radius: this.parentNodeRadius,\n                        lineColor: this.color,\n                        fillColor: color(this.color).brighten(0.4).get()\n                    };\n                if (layoutOptions.parentNodeOptions) {\n                    parentMarkerOptions = merge(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions);\n                }\n                this.parentNodeMass = 0;\n                this.points.forEach(function (p) {\n                    _this.parentNodeMass +=\n                        Math.PI * Math.pow(p.marker.radius, 2);\n                });\n                this.calculateParentRadius();\n                parentNodeLayout.nodes.forEach(function (node) {\n                    if (node.seriesIndex === _this.index) {\n                        nodeAdded = true;\n                    }\n                });\n                parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);\n                if (!nodeAdded) {\n                    if (!parentNode) {\n                        parentNode = (new PackedBubblePoint()).init(this, {\n                            mass: this.parentNodeRadius / 2,\n                            marker: parentMarkerOptions,\n                            dataLabels: {\n                                inside: false\n                            },\n                            states: {\n                                normal: {\n                                    marker: parentMarkerOptions\n                                },\n                                hover: {\n                                    marker: parentMarkerOptions\n                                }\n                            },\n                            dataLabelOnNull: true,\n                            degree: this.parentNodeRadius,\n                            isParentNode: true,\n                            seriesIndex: this.index\n                        });\n                    }\n                    if (this.parentNode) {\n                        parentNode.plotX = this.parentNode.plotX;\n                        parentNode.plotY = this.parentNode.plotY;\n                    }\n                    this.parentNode = parentNode;\n                    parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);\n                    parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);\n                }\n            };\n            /**\n             * Function responsible for adding all the layouts to the chart.\n             * @private\n             */\n            PackedBubbleSeries.prototype.deferLayout = function () {\n                // TODO split layouts to independent methods\n                var layoutOptions = this.options.layoutAlgorithm;\n                if (!this.visible) {\n                    return;\n                }\n                // layout is using nodes for position calculation\n                this.addLayout();\n                if (layoutOptions.splitSeries) {\n                    this.addSeriesLayout();\n                }\n            };\n            PackedBubbleSeries.prototype.destroy = function () {\n                var _this = this;\n                // Remove the series from all layouts series collections #11469\n                if (this.chart.graphLayoutsLookup) {\n                    this.chart.graphLayoutsLookup.forEach(function (layout) {\n                        layout.removeElementFromCollection(_this, layout.series);\n                    }, this);\n                }\n                if (this.parentNode &&\n                    this.parentNodeLayout) {\n                    this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);\n                    if (this.parentNode.dataLabel) {\n                        this.parentNode.dataLabel =\n                            this.parentNode.dataLabel.destroy();\n                    }\n                }\n                seriesProto.destroy.apply(this, arguments);\n            };\n            /**\n             * Packedbubble has two separate collecions of nodes if split, render\n             * dataLabels for both sets:\n             * @private\n             */\n            PackedBubbleSeries.prototype.drawDataLabels = function () {\n                seriesProto.drawDataLabels.call(this, this.points);\n                // Render parentNode labels:\n                if (this.parentNode) {\n                    this.parentNode.formatPrefix = 'parentNode';\n                    seriesProto.drawDataLabels.call(this, [this.parentNode]);\n                }\n            };\n            /**\n             * Create Background/Parent Nodes for split series.\n             * @private\n             */\n            PackedBubbleSeries.prototype.drawGraph = function () {\n                // if the series is not using layout, don't add parent nodes\n                if (!this.layout || !this.layout.options.splitSeries) {\n                    return;\n                }\n                var chart = this.chart,\n                    nodeMarker = this.layout.options.parentNodeOptions.marker,\n                    parentOptions = {\n                        fill: (nodeMarker.fillColor ||\n                            color(this.color).brighten(0.4).get()),\n                        opacity: nodeMarker.fillOpacity,\n                        stroke: nodeMarker.lineColor || this.color,\n                        'stroke-width': pick(nodeMarker.lineWidth,\n                    this.options.lineWidth)\n                    };\n                var parentAttribs = {};\n                // create the group for parent Nodes if doesn't exist\n                if (!this.parentNodesGroup) {\n                    this.parentNodesGroup = this.plotGroup('parentNodesGroup', 'parentNode', this.visible ? 'inherit' : 'hidden', 0.1, chart.seriesGroup);\n                    this.group.attr({\n                        zIndex: 2\n                    });\n                }\n                this.calculateParentRadius();\n                parentAttribs = merge({\n                    x: this.parentNode.plotX -\n                        this.parentNodeRadius,\n                    y: this.parentNode.plotY -\n                        this.parentNodeRadius,\n                    width: this.parentNodeRadius * 2,\n                    height: this.parentNodeRadius * 2\n                }, parentOptions);\n                if (!this.parentNode.graphic) {\n                    this.graph = this.parentNode.graphic =\n                        chart.renderer.symbol(parentOptions.symbol)\n                            .add(this.parentNodesGroup);\n                }\n                this.parentNode.graphic.attr(parentAttribs);\n            };\n            PackedBubbleSeries.prototype.drawTracker = function () {\n                var parentNode = this.parentNode;\n                // chart = series.chart,\n                // pointer = chart.pointer,\n                // onMouseOver = function (e: PointerEvent): void {\n                //     const point = pointer.getPointFromEvent(e);\n                //     // undefined on graph in scatterchart\n                //     if (typeof point !== 'undefined') {\n                //         pointer.isDirectTouch = true;\n                //         point.onMouseOver(e);\n                //     }\n                // };\n                var dataLabels;\n                _super.prototype.drawTracker.call(this);\n                // Add reference to the point\n                if (parentNode) {\n                    dataLabels = (isArray(parentNode.dataLabels) ?\n                        parentNode.dataLabels :\n                        (parentNode.dataLabel ? [parentNode.dataLabel] : []));\n                    if (parentNode.graphic) {\n                        parentNode.graphic.element.point = parentNode;\n                    }\n                    dataLabels.forEach(function (dataLabel) {\n                        if (dataLabel.div) {\n                            dataLabel.div.point = parentNode;\n                        }\n                        else {\n                            dataLabel.element.point = parentNode;\n                        }\n                    });\n                }\n            };\n            /**\n             * Calculate radius of bubbles in series.\n             * @private\n             */\n            PackedBubbleSeries.prototype.getPointRadius = function () {\n                var _this = this;\n                var chart = this.chart,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    seriesOptions = this.options,\n                    useSimulation = seriesOptions.useSimulation,\n                    smallestSize = Math.min(plotWidth,\n                    plotHeight),\n                    extremes = {},\n                    radii = [],\n                    allDataPoints = chart.allDataPoints || [],\n                    allDataPointsLength = allDataPoints.length;\n                var minSize,\n                    maxSize,\n                    value,\n                    radius;\n                ['minSize', 'maxSize'].forEach(function (prop) {\n                    var length = parseInt(seriesOptions[prop], 10),\n                        isPercent = /%$/.test(seriesOptions[prop]);\n                    extremes[prop] = isPercent ?\n                        smallestSize * length / 100 :\n                        length * Math.sqrt(allDataPointsLength);\n                });\n                chart.minRadius = minSize = extremes.minSize /\n                    Math.sqrt(allDataPointsLength);\n                chart.maxRadius = maxSize = extremes.maxSize /\n                    Math.sqrt(allDataPointsLength);\n                var zExtremes = useSimulation ?\n                        this.calculateZExtremes() :\n                        [minSize,\n                    maxSize];\n                allDataPoints.forEach(function (point, i) {\n                    value = useSimulation ?\n                        clamp(point[2], zExtremes[0], zExtremes[1]) :\n                        point[2];\n                    radius = _this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);\n                    if (radius === 0) {\n                        radius = null;\n                    }\n                    allDataPoints[i][2] = radius;\n                    radii.push(radius);\n                });\n                this.radii = radii;\n            };\n            PackedBubbleSeries.prototype.init = function () {\n                seriesProto.init.apply(this, arguments);\n                /* eslint-disable no-invalid-this */\n                // When one series is modified, the others need to be recomputed\n                this.eventsToUnbind.push(addEvent(this, 'updatedData', function () {\n                    var _this = this;\n                    this.chart.series.forEach(function (s) {\n                        if (s.type === _this.type) {\n                            s.isDirty = true;\n                        }\n                    }, this);\n                }));\n                /* eslint-enable no-invalid-this */\n                return this;\n            };\n            /**\n             * Mouse up action, finalizing drag&drop.\n             * @private\n             * @param {Highcharts.Point} point The point that event occured.\n             */\n            PackedBubbleSeries.prototype.onMouseUp = function (dnPoint) {\n                var point = dnPoint;\n                if (point.fixedPosition && !point.removed) {\n                    var layout_1 = this.layout,\n                        parentNodeLayout = this.parentNodeLayout;\n                    var distanceXY_1,\n                        distanceR_1;\n                    if (parentNodeLayout && layout_1.options.dragBetweenSeries) {\n                        parentNodeLayout.nodes.forEach(function (node) {\n                            if (point && point.marker &&\n                                node !== point.series.parentNode) {\n                                distanceXY_1 = layout_1.getDistXY(point, node);\n                                distanceR_1 = (layout_1.vectorLength(distanceXY_1) -\n                                    node.marker.radius -\n                                    point.marker.radius);\n                                if (distanceR_1 < 0) {\n                                    node.series.addPoint(merge(point.options, {\n                                        plotX: point.plotX,\n                                        plotY: point.plotY\n                                    }), false);\n                                    layout_1.removeElementFromCollection(point, layout_1.nodes);\n                                    point.remove();\n                                }\n                            }\n                        });\n                    }\n                    DragNodesComposition.onMouseUp.apply(this, arguments);\n                }\n            };\n            /**\n             * This is the main function responsible\n             * for positioning all of the bubbles\n             * allDataPoints - bubble array, in format [pixel x value,\n             * pixel y value, radius,\n             * related series index, related point index]\n             * @private\n             * @param {Array<Highcharts.PackedBubbleData>} allDataPoints All points from all series\n             * @return {Array<Highcharts.PackedBubbleData>} Positions of all bubbles\n             */\n            PackedBubbleSeries.prototype.placeBubbles = function (allDataPoints) {\n                var checkOverlap = this.checkOverlap,\n                    positionBubble = this.positionBubble,\n                    bubblePos = [];\n                var stage = 1,\n                    j = 0,\n                    k = 0,\n                    calculatedBubble,\n                    arr = [],\n                    i;\n                // sort all points\n                var sortedArr = allDataPoints.sort(function (a,\n                    b) {\n                        return b[2] - a[2];\n                });\n                if (sortedArr.length) {\n                    // create first bubble in the middle of the chart\n                    bubblePos.push([\n                        [\n                            0,\n                            0,\n                            sortedArr[0][2],\n                            sortedArr[0][3],\n                            sortedArr[0][4]\n                        ] // point index\n                    ]); // 0 level bubble\n                    if (sortedArr.length > 1) {\n                        bubblePos.push([\n                            [\n                                0,\n                                (0 - sortedArr[1][2] -\n                                    sortedArr[0][2]),\n                                // move bubble above first one\n                                sortedArr[1][2],\n                                sortedArr[1][3],\n                                sortedArr[1][4]\n                            ]\n                        ]); // 1 level 1st bubble\n                        // first two already positioned so starting from 2\n                        for (i = 2; i < sortedArr.length; i++) {\n                            sortedArr[i][2] = sortedArr[i][2] || 1;\n                            // in case if radius is calculated as 0.\n                            calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]); // calculate initial bubble position\n                            if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {\n                                /* if new bubble is overlapping with first bubble\n                                    * in current level (stage)\n                                    */\n                                bubblePos.push([]);\n                                k = 0;\n                                /* reset index of bubble, used for\n                                    * positioning the bubbles around it,\n                                    * we are starting from first bubble in next\n                                    * stage because we are changing level to higher\n                                    */\n                                bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));\n                                // (last bubble, 1. from curr stage, new bubble)\n                                stage++; // the new level is created, above current\n                                j = 0; // set the index of bubble in curr level to 0\n                            }\n                            else if (stage > 1 &&\n                                bubblePos[stage - 1][k + 1] &&\n                                checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {\n                                /* if new bubble is overlapping with one of the prev\n                                    * stage bubbles, it means that - bubble, used for\n                                    * positioning the bubbles around it has changed\n                                    * so we need to recalculate it\n                                    */\n                                k++;\n                                bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));\n                                // (last bubble, prev stage bubble, new bubble)\n                                j++;\n                            }\n                            else { // simply add calculated bubble\n                                j++;\n                                bubblePos[stage].push(calculatedBubble);\n                            }\n                        }\n                    }\n                    this.chart.stages = bubblePos;\n                    // it may not be necessary but adding it just in case -\n                    // it is containing all of the bubble levels\n                    this.chart.rawPositions =\n                        []\n                            .concat.apply([], bubblePos);\n                    // bubble positions merged into one array\n                    this.resizeRadius();\n                    arr = this.chart.rawPositions;\n                }\n                return arr;\n            };\n            /**\n             * Function that checks for a parentMarker and sets the correct opacity.\n             * @private\n             * @param {Highcharts.Pack} point\n             * Candidate point for opacity correction.\n             * @param {string} [state]\n             * The point state, can be either `hover`, `select` or 'normal'. If\n             * undefined, normal state is assumed.\n             *\n             * @return {Highcharts.SVGAttributes}\n             * The presentational attributes to be set on the point.\n             */\n            PackedBubbleSeries.prototype.pointAttribs = function (point, state) {\n                var options = this.options,\n                    hasParentMarker = point && point.isParentNode;\n                var markerOptions = options.marker;\n                if (hasParentMarker &&\n                    options.layoutAlgorithm &&\n                    options.layoutAlgorithm.parentNodeOptions) {\n                    markerOptions = options.layoutAlgorithm.parentNodeOptions.marker;\n                }\n                var fillOpacity = markerOptions.fillOpacity,\n                    attr = seriesProto.pointAttribs.call(this,\n                    point,\n                    state);\n                if (fillOpacity !== 1) {\n                    attr['fill-opacity'] = fillOpacity;\n                }\n                return attr;\n            };\n            /**\n             * Function that is adding one bubble based on positions and sizes of\n             * two other bubbles, lastBubble is the last added bubble, newOrigin is\n             * the bubble for positioning new bubbles. nextBubble is the curently\n             * added bubble for which we are calculating positions\n             * @private\n             * @param {Array<number>} lastBubble The closest last bubble\n             * @param {Array<number>} newOrigin New bubble\n             * @param {Array<number>} nextBubble The closest next bubble\n             * @return {Array<number>} Bubble with correct positions\n             */\n            PackedBubbleSeries.prototype.positionBubble = function (lastBubble, newOrigin, nextBubble) {\n                var sqrt = Math.sqrt,\n                    asin = Math.asin,\n                    acos = Math.acos,\n                    pow = Math.pow,\n                    abs = Math.abs,\n                    distance = sqrt(// dist between lastBubble and newOrigin\n                    pow((lastBubble[0] - newOrigin[0]), 2) +\n                        pow((lastBubble[1] - newOrigin[1]), 2)),\n                    alfa = acos(\n                    // from cosinus theorem: alfa is an angle used for\n                    // calculating correct position\n                    (pow(distance, 2) +\n                        pow(nextBubble[2] + newOrigin[2], 2) -\n                        pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)),\n                    beta = asin(// from sinus theorem.\n                    abs(lastBubble[0] - newOrigin[0]) /\n                        distance), \n                    // providing helping variables, related to angle between\n                    // lastBubble and newOrigin\n                    gamma = (lastBubble[1] - newOrigin[1]) < 0 ? 0 : Math.PI, \n                    // if new origin y is smaller than last bubble y value\n                    // (2 and 3 quarter),\n                    // add Math.PI to final angle\n                    delta = (lastBubble[0] - newOrigin[0]) *\n                        (lastBubble[1] - newOrigin[1]) < 0 ?\n                        1 : -1, // (1st and 3rd quarter)\n                    finalAngle = gamma + alfa + beta * delta,\n                    cosA = Math.cos(finalAngle),\n                    sinA = Math.sin(finalAngle),\n                    posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, \n                    // center of new origin + (radius1 + radius2) * sinus A\n                    posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;\n                return [\n                    posX,\n                    posY,\n                    nextBubble[2],\n                    nextBubble[3],\n                    nextBubble[4]\n                ]; // the same as described before\n            };\n            PackedBubbleSeries.prototype.render = function () {\n                var dataLabels = [];\n                seriesProto.render.apply(this, arguments);\n                // #10823 - dataLabels should stay visible\n                // when enabled allowOverlap.\n                if (!this.options.dataLabels.allowOverlap) {\n                    this.data.forEach(function (point) {\n                        if (isArray(point.dataLabels)) {\n                            point.dataLabels.forEach(function (dataLabel) {\n                                dataLabels.push(dataLabel);\n                            });\n                        }\n                    });\n                    // Only hide overlapping dataLabels for layouts that\n                    // use simulation. Spiral packedbubble don't need\n                    // additional dataLabel hiding on every simulation step\n                    if (this.options.useSimulation) {\n                        this.chart.hideOverlappingLabels(dataLabels);\n                    }\n                }\n            };\n            /**\n             * The function responsible for resizing the bubble radius.\n             * In shortcut: it is taking the initially\n             * calculated positions of bubbles. Then it is calculating the min max\n             * of both dimensions, creating something in shape of bBox.\n             * The comparison of bBox and the size of plotArea\n             * (later it may be also the size set by customer) is giving the\n             * value how to recalculate the radius so it will match the size\n             * @private\n             */\n            PackedBubbleSeries.prototype.resizeRadius = function () {\n                var chart = this.chart,\n                    positions = chart.rawPositions,\n                    min = Math.min,\n                    max = Math.max,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    chartHeight = chart.plotHeight,\n                    chartWidth = chart.plotWidth;\n                var minX,\n                    maxX,\n                    minY,\n                    maxY,\n                    radius;\n                minX = minY = Number.POSITIVE_INFINITY; // set initial values\n                maxX = maxY = Number.NEGATIVE_INFINITY;\n                for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n                    var position = positions_1[_i];\n                    radius = position[2];\n                    minX = min(minX, position[0] - radius);\n                    // (x center-radius) is the min x value used by specific bubble\n                    maxX = max(maxX, position[0] + radius);\n                    minY = min(minY, position[1] - radius);\n                    maxY = max(maxY, position[1] + radius);\n                }\n                var bBox = [maxX - minX,\n                    maxY - minY],\n                    spaceRatio = [\n                        (chartWidth - plotLeft) / bBox[0],\n                        (chartHeight - plotTop) / bBox[1]\n                    ],\n                    smallerDimension = min.apply([],\n                    spaceRatio);\n                if (Math.abs(smallerDimension - 1) > 1e-10) {\n                    // if bBox is considered not the same width as possible size\n                    for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {\n                        var position = positions_2[_a];\n                        position[2] *= smallerDimension;\n                    }\n                    this.placeBubbles(positions);\n                }\n                else {\n                    /** if no radius recalculation is needed, we need to position\n                     * the whole bubbles in center of chart plotarea\n                     * for this, we are adding two parameters,\n                     * diffY and diffX, that are related to differences\n                     * between the initial center and the bounding box\n                     */\n                    chart.diffY = chartHeight / 2 +\n                        plotTop - minY - (maxY - minY) / 2;\n                    chart.diffX = chartWidth / 2 +\n                        plotLeft - minX - (maxX - minX) / 2;\n                }\n            };\n            /**\n             * The function responsible for calculating series bubble' s bBox.\n             * Needed because of exporting failure when useSimulation\n             * is set to false\n             * @private\n             */\n            PackedBubbleSeries.prototype.seriesBox = function () {\n                var chart = this.chart,\n                    data = this.data,\n                    max = Math.max,\n                    min = Math.min, \n                    // bBox = [xMin, xMax, yMin, yMax]\n                    bBox = [\n                        chart.plotLeft,\n                        chart.plotLeft + chart.plotWidth,\n                        chart.plotTop,\n                        chart.plotTop + chart.plotHeight\n                    ];\n                var radius;\n                data.forEach(function (p) {\n                    if (defined(p.plotX) &&\n                        defined(p.plotY) &&\n                        p.marker.radius) {\n                        radius = p.marker.radius;\n                        bBox[0] = min(bBox[0], p.plotX - radius);\n                        bBox[1] = max(bBox[1], p.plotX + radius);\n                        bBox[2] = min(bBox[2], p.plotY - radius);\n                        bBox[3] = max(bBox[3], p.plotY + radius);\n                    }\n                });\n                return isNumber(bBox.width / bBox.height) ?\n                    bBox :\n                    null;\n            };\n            /**\n             * Needed because of z-indexing issue if point is added in series.group\n             * @private\n             */\n            PackedBubbleSeries.prototype.setVisible = function () {\n                var series = this;\n                seriesProto.setVisible.apply(series, arguments);\n                if (series.parentNodeLayout && series.graph) {\n                    if (series.visible) {\n                        series.graph.show();\n                        if (series.parentNode.dataLabel) {\n                            series.parentNode.dataLabel.show();\n                        }\n                    }\n                    else {\n                        series.graph.hide();\n                        series.parentNodeLayout\n                            .removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);\n                        if (series.parentNode.dataLabel) {\n                            series.parentNode.dataLabel.hide();\n                        }\n                    }\n                }\n                else if (series.layout) {\n                    if (series.visible) {\n                        series.layout.addElementsToCollection(series.points, series.layout.nodes);\n                    }\n                    else {\n                        series.points.forEach(function (node) {\n                            series.layout.removeElementFromCollection(node, series.layout.nodes);\n                        });\n                    }\n                }\n            };\n            /**\n             * Extend the base translate method to handle bubble size,\n             * and correct positioning them.\n             * @private\n             */\n            PackedBubbleSeries.prototype.translate = function () {\n                var chart = this.chart,\n                    data = this.data,\n                    index = this.index,\n                    useSimulation = this.options.useSimulation;\n                var point,\n                    radius,\n                    positions;\n                this.processedXData = this.xData;\n                this.generatePoints();\n                // merged data is an array with all of the data from all series\n                if (!defined(chart.allDataPoints)) {\n                    chart.allDataPoints = this.accumulateAllPoints();\n                    // calculate radius for all added data\n                    this.getPointRadius();\n                }\n                // after getting initial radius, calculate bubble positions\n                if (useSimulation) {\n                    positions = chart.allDataPoints;\n                }\n                else {\n                    positions = this.placeBubbles(chart.allDataPoints);\n                    this.options.draggable = false;\n                }\n                // Set the shape and arguments to be picked up in drawPoints\n                for (var _i = 0, positions_3 = positions; _i < positions_3.length; _i++) {\n                    var position = positions_3[_i];\n                    if (position[3] === index) {\n                        // update the series points with the val from positions\n                        // array\n                        point = data[position[4]];\n                        radius = pick(position[2], void 0);\n                        if (!useSimulation) {\n                            point.plotX = (position[0] - chart.plotLeft +\n                                chart.diffX);\n                            point.plotY = (position[1] - chart.plotTop +\n                                chart.diffY);\n                        }\n                        if (isNumber(radius)) {\n                            point.marker = extend(point.marker, {\n                                radius: radius,\n                                width: 2 * radius,\n                                height: 2 * radius\n                            });\n                            point.radius = radius;\n                        }\n                    }\n                }\n                if (useSimulation) {\n                    this.deferLayout();\n                }\n                fireEvent(this, 'afterTranslate');\n            };\n            PackedBubbleSeries.defaultOptions = merge(BubbleSeries.defaultOptions, PackedBubbleSeriesDefaults);\n            return PackedBubbleSeries;\n        }(BubbleSeries));\n        extend(PackedBubbleSeries.prototype, {\n            pointClass: PackedBubblePoint,\n            axisTypes: [],\n            directTouch: true,\n            forces: ['barycenter', 'repulsive'],\n            hasDraggableNodes: true,\n            isCartesian: false,\n            noSharedTooltip: true,\n            pointArrayMap: ['value'],\n            pointValKey: 'value',\n            requireSorting: false,\n            trackerGroups: ['group', 'dataLabelsGroup', 'parentNodesGroup'],\n            alignDataLabel: seriesProto.alignDataLabel,\n            indexateNodes: noop,\n            onMouseDown: DragNodesComposition.onMouseDown,\n            onMouseMove: DragNodesComposition.onMouseMove,\n            redrawHalo: DragNodesComposition.redrawHalo,\n            searchPoint: noop // solving #12287\n        });\n        SeriesRegistry.registerSeriesType('packedbubble', PackedBubbleSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Formatter callback function.\n         *\n         * @callback Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction\n         *\n         * @param {Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject} this\n         *        Data label context to format\n         *\n         * @return {string}\n         *         Formatted data label text\n         */\n        /**\n         * Context for the formatter function.\n         *\n         * @interface Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject\n         * @extends Highcharts.PointLabelObject\n         * @since 7.0.0\n         */ /**\n        * The color of the node.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#color\n        * @type {Highcharts.ColorString}\n        * @since 7.0.0\n        */ /**\n        * The point (node) object. The node name, if defined, is available through\n        * `this.point.name`. Arrays: `this.point.linksFrom` and `this.point.linksTo`\n        * contains all nodes connected to this point.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#point\n        * @type {Highcharts.Point}\n        * @since 7.0.0\n        */ /**\n        * The ID of the node.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#key\n        * @type {string}\n        * @since 7.0.0\n        */\n        ''; // detach doclets above\n\n        return PackedBubbleSeries;\n    });\n    _registerModule(_modules, 'Series/Polygon/PolygonSeries.js', [_modules['Core/Globals.js'], _modules['Core/Legend/LegendSymbol.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (H, LegendSymbol, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            _a = SeriesRegistry.seriesTypes,\n            AreaSeries = _a.area,\n            LineSeries = _a.line,\n            ScatterSeries = _a.scatter;\n        var extend = U.extend,\n            merge = U.merge;\n        /* *\n         *\n         * Class\n         *\n         * */\n        var PolygonSeries = /** @class */ (function (_super) {\n                __extends(PolygonSeries, _super);\n            function PolygonSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            PolygonSeries.prototype.getGraphPath = function () {\n                var graphPath = LineSeries.prototype.getGraphPath.call(this),\n                    i = graphPath.length + 1;\n                // Close all segments\n                while (i--) {\n                    if ((i === graphPath.length || graphPath[i][0] === 'M') && i > 0) {\n                        graphPath.splice(i, 0, ['Z']);\n                    }\n                }\n                this.areaPath = graphPath;\n                return graphPath;\n            };\n            PolygonSeries.prototype.drawGraph = function () {\n                // Hack into the fill logic in area.drawGraph\n                this.options.fillColor = this.color;\n                AreaSeries.prototype.drawGraph.call(this);\n            };\n            /**\n             * A polygon series can be used to draw any freeform shape in the cartesian\n             * coordinate system. A fill is applied with the `color` option, and\n             * stroke is applied through `lineWidth` and `lineColor` options.\n             *\n             * @sample {highcharts} highcharts/demo/polygon/\n             *         Polygon\n             * @sample {highstock} highcharts/demo/polygon/\n             *         Polygon\n             *\n             * @extends      plotOptions.scatter\n             * @since        4.1.0\n             * @excluding    jitter, softThreshold, threshold, cluster, boostThreshold,\n             *               boostBlending\n             * @product      highcharts highstock\n             * @requires     highcharts-more\n             * @optionparent plotOptions.polygon\n             */\n            PolygonSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n                marker: {\n                    enabled: false,\n                    states: {\n                        hover: {\n                            enabled: false\n                        }\n                    }\n                },\n                stickyTracking: false,\n                tooltip: {\n                    followPointer: true,\n                    pointFormat: ''\n                },\n                trackByArea: true\n            });\n            return PolygonSeries;\n        }(ScatterSeries));\n        extend(PolygonSeries.prototype, {\n            type: 'polygon',\n            drawLegendSymbol: LegendSymbol.drawRectangle,\n            drawTracker: Series.prototype.drawTracker,\n            setStackedPoints: noop // No stacking points on polygons (#5310)\n        });\n        SeriesRegistry.registerSeriesType('polygon', PolygonSeries);\n        /* *\n         *\n         * Export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `polygon` series. If the [type](#series.polygon.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.polygon\n         * @excluding dataParser, dataURL, stack, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.polygon\n         */\n        /**\n         * An array of data points for the series. For the `polygon` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 10],\n         *        [1, 3],\n         *        [2, 1]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.polygon.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 1,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock\n         * @apioption series.polygon.data\n         */\n        ''; // adds doclets above to transpiled file\n\n        return PolygonSeries;\n    });\n    _registerModule(_modules, 'Core/Axis/WaterfallAxis.js', [_modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (StackItem, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent,\n            objectEach = U.objectEach;\n        /**\n         * @private\n         */\n        var WaterfallAxis;\n        (function (WaterfallAxis) {\n            /* *\n             *\n             *  Interfaces\n             *\n             * */\n            /* *\n             *\n             *  Classes\n             *\n             * */\n            /**\n             * @private\n             */\n            var Composition = /** @class */ (function () {\n                    /* eslint-disable no-invalid-this, valid-jsdoc */\n                    /* *\n                     *\n                     *  Constructors\n                     *\n                     * */\n                    /**\n                     * @private\n                     */\n                    function Composition(axis) {\n                        this.axis = axis;\n                    this.stacks = {\n                        changed: false\n                    };\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Calls StackItem.prototype.render function that creates and renders\n                 * stack total label for each waterfall stack item.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#renderWaterfallStackTotals\n                 */\n                Composition.prototype.renderStackTotals = function () {\n                    var yAxis = this.axis,\n                        waterfallStacks = yAxis.waterfall.stacks,\n                        stackTotalGroup = (yAxis.stacking && yAxis.stacking.stackTotalGroup),\n                        dummyStackItem = new StackItem(yAxis,\n                        yAxis.options.stackLabels || {},\n                        false, 0,\n                        void 0);\n                    this.dummyStackItem = dummyStackItem;\n                    // Render each waterfall stack total\n                    if (stackTotalGroup) {\n                        objectEach(waterfallStacks, function (type) {\n                            objectEach(type, function (stackItem, key) {\n                                dummyStackItem.total = stackItem.stackTotal;\n                                dummyStackItem.x = +key;\n                                if (stackItem.label) {\n                                    dummyStackItem.label = stackItem.label;\n                                }\n                                StackItem.prototype.render.call(dummyStackItem, stackTotalGroup);\n                                stackItem.label = dummyStackItem.label;\n                                delete dummyStackItem.label;\n                            });\n                        });\n                    }\n                    dummyStackItem.total = null;\n                };\n                return Composition;\n            }());\n            WaterfallAxis.Composition = Composition;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable no-invalid-this, valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(AxisClass, ChartClass) {\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterBuildStacks', onAfterBuildStacks);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(ChartClass, 'beforeRedraw', onBeforeRedraw);\n            }\n            WaterfallAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAfterBuildStacks() {\n                var axis = this;\n                var stacks = axis.waterfall.stacks;\n                if (stacks) {\n                    stacks.changed = false;\n                    delete stacks.alreadyChanged;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAfterRender() {\n                var axis = this;\n                var stackLabelOptions = axis.options.stackLabels;\n                if (stackLabelOptions && stackLabelOptions.enabled &&\n                    axis.waterfall.stacks) {\n                    axis.waterfall.renderStackTotals();\n                }\n            }\n            /**\n             * @private\n             */\n            function onBeforeRedraw() {\n                var axes = this.axes,\n                    series = this.series,\n                    i = series.length;\n                while (i--) {\n                    if (series[i].options.stacking) {\n                        axes.forEach(function (axis) {\n                            if (!axis.isXAxis) {\n                                axis.waterfall.stacks.changed = true;\n                            }\n                        });\n                        i = 0;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onInit() {\n                var axis = this;\n                if (!axis.waterfall) {\n                    axis.waterfall = new Composition(axis);\n                }\n            }\n        })(WaterfallAxis || (WaterfallAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WaterfallAxis;\n    });\n    _registerModule(_modules, 'Series/Waterfall/WaterfallPoint.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (ColumnSeries, Point, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var isNumber = U.isNumber;\n        /* *\n         *\n         * Class\n         *\n         * */\n        var WaterfallPoint = /** @class */ (function (_super) {\n                __extends(WaterfallPoint, _super);\n            function WaterfallPoint() {\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            WaterfallPoint.prototype.getClassName = function () {\n                var className = Point.prototype.getClassName.call(this);\n                if (this.isSum) {\n                    className += ' highcharts-sum';\n                }\n                else if (this.isIntermediateSum) {\n                    className += ' highcharts-intermediate-sum';\n                }\n                return className;\n            };\n            // Pass the null test in ColumnSeries.translate.\n            WaterfallPoint.prototype.isValid = function () {\n                return (isNumber(this.y) ||\n                    this.isSum ||\n                    Boolean(this.isIntermediateSum));\n            };\n            return WaterfallPoint;\n        }(ColumnSeries.prototype.pointClass));\n        /* *\n         *\n         * Export\n         *\n         * */\n\n        return WaterfallPoint;\n    });\n    _registerModule(_modules, 'Series/Waterfall/WaterfallSeries.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Core/Axis/WaterfallAxis.js'], _modules['Series/Waterfall/WaterfallPoint.js']], function (Axis, Chart, SeriesRegistry, U, WaterfallAxis, WaterfallPoint) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes,\n            ColumnSeries = _a.column,\n            LineSeries = _a.line;\n        var arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            correctFloat = U.correctFloat,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            objectEach = U.objectEach,\n            pick = U.pick;\n        /**\n         * Returns true if the key is a direct property of the object.\n         * @private\n         * @param {*} obj\n         * Object with property to test\n         * @param {string} key\n         * Property key to test\n         * @return {boolean}\n         * Whether it is a direct property\n         */\n        function ownProp(obj, key) {\n            return Object.hasOwnProperty.call(obj, key);\n        }\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * Waterfall series type.\n         *\n         * @private\n         */\n        var WaterfallSeries = /** @class */ (function (_super) {\n                __extends(WaterfallSeries, _super);\n            function WaterfallSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.chart = void 0;\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.stackedYNeg = void 0;\n                _this.stackedYPos = void 0;\n                _this.stackKey = void 0;\n                _this.xData = void 0;\n                _this.yAxis = void 0;\n                _this.yData = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            // After generating points, set y-values for all sums.\n            WaterfallSeries.prototype.generatePoints = function () {\n                // Parent call:\n                ColumnSeries.prototype.generatePoints.apply(this);\n                for (var i = 0, len = this.points.length; i < len; i++) {\n                    var point = this.points[i],\n                        y = this.processedYData[i];\n                    // Override point value for sums. #3710 Update point does not\n                    // propagate to sum\n                    if (isNumber(y) && (point.isIntermediateSum || point.isSum)) {\n                        point.y = correctFloat(y);\n                    }\n                }\n            };\n            // Translate data points from raw values\n            WaterfallSeries.prototype.translate = function () {\n                var series = this,\n                    options = series.options,\n                    yAxis = series.yAxis,\n                    minPointLength = pick(options.minPointLength, 5),\n                    halfMinPointLength = minPointLength / 2,\n                    threshold = options.threshold || 0,\n                    stacking = options.stacking,\n                    actualStack = yAxis.waterfall.stacks[series.stackKey];\n                var previousIntermediate = threshold,\n                    previousY = threshold,\n                    y,\n                    total,\n                    yPos,\n                    hPos;\n                // run column series translate\n                ColumnSeries.prototype.translate.apply(series);\n                var points = series.points;\n                for (var i = 0; i < points.length; i++) {\n                    var point = points[i],\n                        yValue = series.processedYData[i],\n                        shapeArgs = point.shapeArgs;\n                    if (!shapeArgs || !isNumber(yValue)) {\n                        continue;\n                    }\n                    var range = [0,\n                        yValue],\n                        pointY = point.y;\n                    // code responsible for correct positions of stacked points\n                    // starts here\n                    if (stacking) {\n                        if (actualStack) {\n                            var actualStackX = actualStack[i];\n                            if (stacking === 'overlap') {\n                                total =\n                                    actualStackX.stackState[actualStackX.stateIndex--];\n                                y = pointY >= 0 ? total : total - pointY;\n                                if (ownProp(actualStackX, 'absolutePos')) {\n                                    delete actualStackX.absolutePos;\n                                }\n                                if (ownProp(actualStackX, 'absoluteNeg')) {\n                                    delete actualStackX.absoluteNeg;\n                                }\n                            }\n                            else {\n                                if (pointY >= 0) {\n                                    total = actualStackX.threshold +\n                                        actualStackX.posTotal;\n                                    actualStackX.posTotal -= pointY;\n                                    y = total;\n                                }\n                                else {\n                                    total = actualStackX.threshold +\n                                        actualStackX.negTotal;\n                                    actualStackX.negTotal -= pointY;\n                                    y = total - pointY;\n                                }\n                                if (!actualStackX.posTotal) {\n                                    if (isNumber(actualStackX.absolutePos) &&\n                                        ownProp(actualStackX, 'absolutePos')) {\n                                        actualStackX.posTotal =\n                                            actualStackX.absolutePos;\n                                        delete actualStackX.absolutePos;\n                                    }\n                                }\n                                if (!actualStackX.negTotal) {\n                                    if (isNumber(actualStackX.absoluteNeg) &&\n                                        ownProp(actualStackX, 'absoluteNeg')) {\n                                        actualStackX.negTotal =\n                                            actualStackX.absoluteNeg;\n                                        delete actualStackX.absoluteNeg;\n                                    }\n                                }\n                            }\n                            if (!point.isSum) {\n                                // the connectorThreshold property is later used in\n                                // getCrispPath function to draw a connector line in a\n                                // correct place\n                                actualStackX.connectorThreshold =\n                                    actualStackX.threshold + actualStackX.stackTotal;\n                            }\n                            if (yAxis.reversed) {\n                                yPos = (pointY >= 0) ? (y - pointY) : (y + pointY);\n                                hPos = y;\n                            }\n                            else {\n                                yPos = y;\n                                hPos = y - pointY;\n                            }\n                            point.below = yPos <= threshold;\n                            shapeArgs.y = yAxis.translate(yPos, false, true, false, true);\n                            shapeArgs.height = Math.abs(shapeArgs.y -\n                                yAxis.translate(hPos, false, true, false, true));\n                            var dummyStackItem = yAxis.waterfall.dummyStackItem;\n                            if (dummyStackItem) {\n                                dummyStackItem.x = i;\n                                dummyStackItem.label = actualStack[i].label;\n                                dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis);\n                            }\n                        }\n                    }\n                    else {\n                        // up points\n                        y = Math.max(previousY, previousY + pointY) + range[0];\n                        shapeArgs.y = yAxis.translate(y, false, true, false, true);\n                        // sum points\n                        if (point.isSum) {\n                            shapeArgs.y = yAxis.translate(range[1], false, true, false, true);\n                            shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true), yAxis.len) - shapeArgs.y; // #4256\n                            point.below = range[1] <= threshold;\n                        }\n                        else if (point.isIntermediateSum) {\n                            if (pointY >= 0) {\n                                yPos = range[1] + previousIntermediate;\n                                hPos = previousIntermediate;\n                            }\n                            else {\n                                yPos = previousIntermediate;\n                                hPos = range[1] + previousIntermediate;\n                            }\n                            if (yAxis.reversed) {\n                                // swapping values\n                                yPos ^= hPos;\n                                hPos ^= yPos;\n                                yPos ^= hPos;\n                            }\n                            shapeArgs.y = yAxis.translate(yPos, false, true, false, true);\n                            shapeArgs.height = Math.abs(shapeArgs.y -\n                                Math.min(yAxis.translate(hPos, false, true, false, true), yAxis.len));\n                            previousIntermediate += range[1];\n                            point.below = yPos <= threshold;\n                            // If it's not the sum point, update previous stack end position\n                            // and get shape height (#3886)\n                        }\n                        else {\n                            shapeArgs.height = yValue > 0 ?\n                                yAxis.translate(previousY, false, true, false, true) - shapeArgs.y :\n                                yAxis.translate(previousY, false, true, false, true) - yAxis.translate(previousY - yValue, false, true, false, true);\n                            previousY += yValue;\n                            point.below = previousY < threshold;\n                        }\n                        // #3952 Negative sum or intermediate sum not rendered correctly\n                        if (shapeArgs.height < 0) {\n                            shapeArgs.y += shapeArgs.height;\n                            shapeArgs.height *= -1;\n                        }\n                    }\n                    point.plotY = shapeArgs.y =\n                        Math.round(shapeArgs.y || 0) - (series.borderWidth % 2) / 2;\n                    // #3151\n                    shapeArgs.height =\n                        Math.max(Math.round(shapeArgs.height || 0), 0.001);\n                    point.yBottom = shapeArgs.y + shapeArgs.height;\n                    if (shapeArgs.height <= minPointLength && !point.isNull) {\n                        shapeArgs.height = minPointLength;\n                        shapeArgs.y -= halfMinPointLength;\n                        point.plotY = shapeArgs.y;\n                        if (point.y < 0) {\n                            point.minPointLengthOffset = -halfMinPointLength;\n                        }\n                        else {\n                            point.minPointLengthOffset = halfMinPointLength;\n                        }\n                    }\n                    else {\n                        if (point.isNull) {\n                            shapeArgs.width = 0;\n                        }\n                        point.minPointLengthOffset = 0;\n                    }\n                    // Correct tooltip placement (#3014)\n                    var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);\n                    if (point.below) { // #15334\n                        point.plotY += shapeArgs.height;\n                    }\n                    if (point.tooltipPos) {\n                        if (series.chart.inverted) {\n                            point.tooltipPos[0] = yAxis.len - tooltipY;\n                        }\n                        else {\n                            point.tooltipPos[1] = tooltipY;\n                        }\n                    }\n                    // Check point position after recalculation (#16788)\n                    point.isInside = this.isPointInside(point);\n                }\n            };\n            // Call default processData then override yData to reflect waterfall's\n            // extremes on yAxis\n            WaterfallSeries.prototype.processData = function (force) {\n                var series = this,\n                    options = series.options,\n                    yData = series.yData, \n                    // #3710 Update point does not propagate to sum\n                    points = options.data,\n                    point,\n                    dataLength = yData.length,\n                    threshold = options.threshold || 0,\n                    subSum,\n                    sum,\n                    dataMin,\n                    dataMax,\n                    y,\n                    i;\n                sum = subSum = dataMin = dataMax = 0;\n                for (i = 0; i < dataLength; i++) {\n                    y = yData[i];\n                    point = points && points[i] ? points[i] : {};\n                    if (y === 'sum' || point.isSum) {\n                        yData[i] = correctFloat(sum);\n                    }\n                    else if (y === 'intermediateSum' ||\n                        point.isIntermediateSum) {\n                        yData[i] = correctFloat(subSum);\n                        subSum = 0;\n                    }\n                    else {\n                        sum += y;\n                        subSum += y;\n                    }\n                    dataMin = Math.min(sum, dataMin);\n                    dataMax = Math.max(sum, dataMax);\n                }\n                _super.prototype.processData.call(this, force);\n                // Record extremes only if stacking was not set:\n                if (!options.stacking) {\n                    series.dataMin = dataMin + threshold;\n                    series.dataMax = dataMax;\n                }\n                return;\n            };\n            // Return y value or string if point is sum\n            WaterfallSeries.prototype.toYData = function (pt) {\n                if (pt.isSum) {\n                    return 'sum';\n                }\n                if (pt.isIntermediateSum) {\n                    return 'intermediateSum';\n                }\n                return pt.y;\n            };\n            WaterfallSeries.prototype.updateParallelArrays = function (point, i) {\n                _super.prototype.updateParallelArrays.call(this, point, i);\n                // Prevent initial sums from triggering an error (#3245, #7559)\n                if (this.yData[0] === 'sum' || this.yData[0] === 'intermediateSum') {\n                    this.yData[0] = null;\n                }\n            };\n            // Postprocess mapping between options and SVG attributes\n            WaterfallSeries.prototype.pointAttribs = function (point, state) {\n                var upColor = this.options.upColor;\n                // Set or reset up color (#3710, update to negative)\n                if (upColor && !point.options.color) {\n                    point.color = point.y > 0 ? upColor : void 0;\n                }\n                var attr = ColumnSeries.prototype.pointAttribs.call(this,\n                    point,\n                    state);\n                // The dashStyle option in waterfall applies to the graph, not\n                // the points\n                delete attr.dashstyle;\n                return attr;\n            };\n            // Return an empty path initially, because we need to know the stroke-width\n            // in order to set the final path.\n            WaterfallSeries.prototype.getGraphPath = function () {\n                return [['M', 0, 0]];\n            };\n            // Draw columns' connector lines\n            WaterfallSeries.prototype.getCrispPath = function () {\n                var data = this.data,\n                    yAxis = this.yAxis,\n                    length = data.length,\n                    graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2,\n                    borderNormalizer = Math.round(this.borderWidth) % 2 / 2,\n                    reversedXAxis = this.xAxis.reversed,\n                    reversedYAxis = this.yAxis.reversed,\n                    stacking = this.options.stacking,\n                    path = [],\n                    connectorThreshold,\n                    prevStack,\n                    prevStackX,\n                    prevPoint,\n                    yPos,\n                    isPos,\n                    prevArgs,\n                    pointArgs,\n                    i;\n                for (i = 1; i < length; i++) {\n                    pointArgs = data[i].shapeArgs;\n                    prevPoint = data[i - 1];\n                    prevArgs = data[i - 1].shapeArgs;\n                    prevStack = yAxis.waterfall.stacks[this.stackKey];\n                    isPos = prevPoint.y > 0 ? -prevArgs.height : 0;\n                    if (prevStack && prevArgs && pointArgs) {\n                        prevStackX = prevStack[i - 1];\n                        // y position of the connector is different when series are\n                        // stacked, yAxis is reversed and it also depends on point's\n                        // value\n                        if (stacking) {\n                            connectorThreshold = prevStackX.connectorThreshold;\n                            yPos = Math.round((yAxis.translate(connectorThreshold, false, true, false, true) +\n                                (reversedYAxis ? isPos : 0))) - graphNormalizer;\n                        }\n                        else {\n                            yPos =\n                                prevArgs.y + prevPoint.minPointLengthOffset +\n                                    borderNormalizer - graphNormalizer;\n                        }\n                        path.push([\n                            'M',\n                            (prevArgs.x || 0) + (reversedXAxis ?\n                                0 :\n                                (prevArgs.width || 0)),\n                            yPos\n                        ], [\n                            'L',\n                            (pointArgs.x || 0) + (reversedXAxis ?\n                                (pointArgs.width || 0) :\n                                0),\n                            yPos\n                        ]);\n                    }\n                    if (prevArgs &&\n                        path.length &&\n                        ((!stacking && prevPoint.y < 0 && !reversedYAxis) ||\n                            (prevPoint.y > 0 && reversedYAxis))) {\n                        var nextLast = path[path.length - 2];\n                        if (nextLast && typeof nextLast[2] === 'number') {\n                            nextLast[2] += prevArgs.height || 0;\n                        }\n                        var last = path[path.length - 1];\n                        if (last && typeof last[2] === 'number') {\n                            last[2] += prevArgs.height || 0;\n                        }\n                    }\n                }\n                return path;\n            };\n            // The graph is initially drawn with an empty definition, then updated with\n            // crisp rendering.\n            WaterfallSeries.prototype.drawGraph = function () {\n                LineSeries.prototype.drawGraph.call(this);\n                if (this.graph) {\n                    this.graph.attr({\n                        d: this.getCrispPath()\n                    });\n                }\n            };\n            // Waterfall has stacking along the x-values too.\n            WaterfallSeries.prototype.setStackedPoints = function () {\n                var series = this,\n                    options = series.options,\n                    waterfallStacks = series.yAxis.waterfall.stacks,\n                    seriesThreshold = options.threshold || 0,\n                    stackThreshold = seriesThreshold,\n                    interSum = stackThreshold,\n                    stackKey = series.stackKey,\n                    xData = series.xData,\n                    xLength = xData.length,\n                    actualStackX,\n                    totalYVal,\n                    actualSum,\n                    prevSum,\n                    statesLen,\n                    posTotal,\n                    negTotal,\n                    xPoint,\n                    yVal,\n                    x,\n                    alreadyChanged,\n                    changed;\n                // Function responsible for calculating correct values for stackState\n                // array of each stack item. The arguments are: firstS - the value for\n                // the first state, nextS - the difference between the previous and the\n                // newest state, sInx - counter used in the for that updates each state\n                // when necessary, sOff - offset that must be added to each state when\n                // they need to be updated (if point isn't a total sum)\n                // eslint-disable-next-line require-jsdoc\n                function calculateStackState(firstS, nextS, sInx, sOff) {\n                    if (actualStackX) {\n                        if (!statesLen) {\n                            actualStackX.stackState[0] = firstS;\n                            statesLen = actualStackX.stackState.length;\n                        }\n                        else {\n                            for (sInx; sInx < statesLen; sInx++) {\n                                actualStackX.stackState[sInx] += sOff;\n                            }\n                        }\n                        actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);\n                    }\n                }\n                series.yAxis.stacking.usePercentage = false;\n                totalYVal = actualSum = prevSum = stackThreshold;\n                // code responsible for creating stacks for waterfall series\n                if (series.visible ||\n                    !series.chart.options.chart.ignoreHiddenSeries) {\n                    changed = waterfallStacks.changed;\n                    alreadyChanged = waterfallStacks.alreadyChanged;\n                    // In case of a redraw, stack for each x value must be emptied (only\n                    // for the first series in a specific stack) and recalculated once\n                    // more\n                    if (alreadyChanged &&\n                        alreadyChanged.indexOf(stackKey) < 0) {\n                        changed = true;\n                    }\n                    if (!waterfallStacks[stackKey]) {\n                        waterfallStacks[stackKey] = {};\n                    }\n                    var actualStack = waterfallStacks[stackKey];\n                    if (actualStack) {\n                        for (var i = 0; i < xLength; i++) {\n                            x = xData[i];\n                            if (!actualStack[x] || changed) {\n                                actualStack[x] = {\n                                    negTotal: 0,\n                                    posTotal: 0,\n                                    stackTotal: 0,\n                                    threshold: 0,\n                                    stateIndex: 0,\n                                    stackState: [],\n                                    label: ((changed &&\n                                        actualStack[x]) ?\n                                        actualStack[x].label :\n                                        void 0)\n                                };\n                            }\n                            actualStackX = actualStack[x];\n                            yVal = series.yData[i];\n                            if (yVal >= 0) {\n                                actualStackX.posTotal += yVal;\n                            }\n                            else {\n                                actualStackX.negTotal += yVal;\n                            }\n                            // points do not exist yet, so raw data is used\n                            xPoint = options.data[i];\n                            posTotal = actualStackX.absolutePos = actualStackX.posTotal;\n                            negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;\n                            actualStackX.stackTotal = posTotal + negTotal;\n                            statesLen = actualStackX.stackState.length;\n                            if (xPoint && xPoint.isIntermediateSum) {\n                                calculateStackState(prevSum, actualSum, 0, prevSum);\n                                prevSum = actualSum;\n                                actualSum = seriesThreshold;\n                                // swapping values\n                                stackThreshold ^= interSum;\n                                interSum ^= stackThreshold;\n                                stackThreshold ^= interSum;\n                            }\n                            else if (xPoint && xPoint.isSum) {\n                                calculateStackState(seriesThreshold, totalYVal, statesLen, 0);\n                                stackThreshold = seriesThreshold;\n                            }\n                            else {\n                                calculateStackState(stackThreshold, yVal, 0, totalYVal);\n                                if (xPoint) {\n                                    totalYVal += yVal;\n                                    actualSum += yVal;\n                                }\n                            }\n                            actualStackX.stateIndex++;\n                            actualStackX.threshold = stackThreshold;\n                            stackThreshold += actualStackX.stackTotal;\n                        }\n                    }\n                    waterfallStacks.changed = false;\n                    if (!waterfallStacks.alreadyChanged) {\n                        waterfallStacks.alreadyChanged = [];\n                    }\n                    waterfallStacks.alreadyChanged.push(stackKey);\n                }\n            };\n            // Extremes for a non-stacked series are recorded in processData.\n            // In case of stacking, use Series.stackedYData to calculate extremes.\n            WaterfallSeries.prototype.getExtremes = function () {\n                var stacking = this.options.stacking,\n                    yAxis,\n                    waterfallStacks,\n                    stackedYNeg,\n                    stackedYPos;\n                if (stacking) {\n                    yAxis = this.yAxis;\n                    waterfallStacks = yAxis.waterfall.stacks;\n                    stackedYNeg = this.stackedYNeg = [];\n                    stackedYPos = this.stackedYPos = [];\n                    // the visible y range can be different when stacking is set to\n                    // overlap and different when it's set to normal\n                    if (stacking === 'overlap') {\n                        objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                            stackedYNeg.push(arrayMin(stackX.stackState));\n                            stackedYPos.push(arrayMax(stackX.stackState));\n                        });\n                    }\n                    else {\n                        objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                            stackedYNeg.push(stackX.negTotal + stackX.threshold);\n                            stackedYPos.push(stackX.posTotal + stackX.threshold);\n                        });\n                    }\n                    return {\n                        dataMin: arrayMin(stackedYNeg),\n                        dataMax: arrayMax(stackedYPos)\n                    };\n                }\n                // When not stacking, data extremes have already been computed in the\n                // processData function.\n                return {\n                    dataMin: this.dataMin,\n                    dataMax: this.dataMax\n                };\n            };\n            /**\n             * A waterfall chart displays sequentially introduced positive or negative\n             * values in cumulative columns.\n             *\n             * @sample highcharts/demo/waterfall/\n             *         Waterfall chart\n             * @sample highcharts/plotoptions/waterfall-inverted/\n             *         Horizontal (inverted) waterfall\n             * @sample highcharts/plotoptions/waterfall-stacked/\n             *         Stacked waterfall chart\n             *\n             * @extends      plotOptions.column\n             * @excluding    boostThreshold, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.waterfall\n             */\n            WaterfallSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n                /**\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @apioption plotOptions.waterfall.color\n                 */\n                /**\n                 * The color used specifically for positive point columns. When not\n                 * specified, the general series color is used.\n                 *\n                 * In styled mode, the waterfall colors can be set with the\n                 * `.highcharts-point-negative`, `.highcharts-sum` and\n                 * `.highcharts-intermediate-sum` classes.\n                 *\n                 * @sample {highcharts} highcharts/demo/waterfall/\n                 *         Waterfall\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @product   highcharts\n                 * @apioption plotOptions.waterfall.upColor\n                 */\n                dataLabels: {\n                    inside: true\n                },\n                /**\n                 * The width of the line connecting waterfall columns.\n                 *\n                 * @product highcharts\n                 */\n                lineWidth: 1,\n                /**\n                 * The color of the line that connects columns in a waterfall series.\n                 *\n                 * In styled mode, the stroke can be set with the `.highcharts-graph`\n                 * class.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                lineColor: \"#333333\" /* Palette.neutralColor80 */,\n                /**\n                 * A name for the dash style to use for the line connecting the columns\n                 * of the waterfall series. Possible values: Dash, DashDot, Dot,\n                 * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,\n                 * ShortDashDotDot, ShortDot, Solid\n                 *\n                 * In styled mode, the stroke dash-array can be set with the\n                 * `.highcharts-graph` class.\n                 *\n                 * @type    {Highcharts.DashStyleValue}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                dashStyle: 'Dot',\n                /**\n                 * The color of the border of each waterfall column.\n                 *\n                 * In styled mode, the border stroke can be set with the\n                 * `.highcharts-point` class.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                borderColor: \"#333333\" /* Palette.neutralColor80 */,\n                states: {\n                    hover: {\n                        lineWidthPlus: 0 // #3126\n                    }\n                }\n            });\n            return WaterfallSeries;\n        }(ColumnSeries));\n        extend(WaterfallSeries.prototype, {\n            getZonesGraphs: LineSeries.prototype.getZonesGraphs,\n            pointValKey: 'y',\n            // Property needed to prevent lines between the columns from disappearing\n            // when negativeColor is used.\n            showLine: true,\n            pointClass: WaterfallPoint\n        });\n        SeriesRegistry.registerSeriesType('waterfall', WaterfallSeries);\n        WaterfallAxis.compose(Axis, Chart);\n        /* *\n         *\n         * Export\n         *\n         * */\n        /**\n         *\n         * API Options\n         *\n         */\n        /**\n         * A `waterfall` series. If the [type](#series.waterfall.type) option\n         * is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.waterfall\n         * @excluding dataParser, dataURL, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.waterfall\n         */\n        /**\n         * An array of data points for the series. For the `waterfall` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 7],\n         *        [1, 8],\n         *        [2, 3]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.waterfall.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts\n         * @apioption series.waterfall.data\n         */\n        /**\n         * When this property is true, the points acts as a summary column for\n         * the values added or substracted since the last intermediate sum,\n         * or since the start of the series. The `y` value is ignored.\n         *\n         * @sample {highcharts} highcharts/demo/waterfall/\n         *         Waterfall\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   highcharts\n         * @apioption series.waterfall.data.isIntermediateSum\n         */\n        /**\n         * When this property is true, the point display the total sum across\n         * the entire series. The `y` value is ignored.\n         *\n         * @sample {highcharts} highcharts/demo/waterfall/\n         *         Waterfall\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   highcharts\n         * @apioption series.waterfall.data.isSum\n         */\n        ''; // adds doclets above to transpiled file\n\n        return WaterfallSeries;\n    });\n    _registerModule(_modules, 'Core/Axis/RadialAxis.js', [_modules['Core/Axis/AxisDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (AxisDefaults, D, H, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var defaultOptions = D.defaultOptions;\n        var noop = H.noop;\n        var addEvent = U.addEvent,\n            correctFloat = U.correctFloat,\n            defined = U.defined,\n            extend = U.extend,\n            fireEvent = U.fireEvent,\n            merge = U.merge,\n            pick = U.pick,\n            relativeLength = U.relativeLength,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var RadialAxis;\n        (function (RadialAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            var composedClasses = [];\n            /**\n             * Circular axis around the perimeter of a polar chart.\n             * @private\n             */\n            var defaultCircularOptions = {\n                    gridLineWidth: 1,\n                    labels: {\n                        align: void 0,\n                        distance: 15,\n                        x: 0,\n                        y: void 0,\n                        style: {\n                            textOverflow: 'none' // wrap lines by default (#7248)\n                        }\n                    },\n                    maxPadding: 0,\n                    minPadding: 0,\n                    showLastLabel: false,\n                    tickLength: 0\n                };\n            /**\n             * The default options extend defaultYAxisOptions.\n             * @private\n             */\n            var defaultRadialGaugeOptions = {\n                    labels: {\n                        align: 'center',\n                        x: 0,\n                        y: void 0 // auto\n                    },\n                    minorGridLineWidth: 0,\n                    minorTickInterval: 'auto',\n                    minorTickLength: 10,\n                    minorTickPosition: 'inside',\n                    minorTickWidth: 1,\n                    tickLength: 10,\n                    tickPosition: 'inside',\n                    tickWidth: 2,\n                    title: {\n                        rotation: 0\n                    },\n                    zIndex: 2 // behind dials, points in the series group\n                };\n            /**\n             * Radial axis, like a spoke in a polar chart.\n             * @private\n             */\n            var defaultRadialOptions = {\n                    /**\n                     * In a polar chart, this is the angle of the Y axis in degrees, where\n                     * 0 is up and 90 is right. The angle determines the position of the\n                     * axis line and the labels, though the coordinate system is unaffected.\n                     * Since v8.0.0 this option is also applicable for X axis (inverted\n                     * polar).\n                     *\n                     * @sample {highcharts} highcharts/xaxis/angle/\n                     *         Custom X axis' angle on inverted polar chart\n                     * @sample {highcharts} highcharts/yaxis/angle/\n                     *         Dual axis polar chart\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     4.2.7\n                     * @product   highcharts\n                     * @apioption xAxis.angle\n                     */\n                    /**\n                     * Polar charts only. Whether the grid lines should draw as a polygon\n                     * with straight lines between categories, or as circles. Can be either\n                     * `circle` or `polygon`. Since v8.0.0 this option is also applicable\n                     * for X axis (inverted polar).\n                     *\n                     * @sample {highcharts} highcharts/demo/polar-spider/\n                     *         Polygon grid lines\n                     * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/\n                     *         Circle and polygon on inverted polar\n                     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/\n                     *         Circle and polygon\n                     *\n                     * @type       {string}\n                     * @product    highcharts\n                     * @validvalue [\"circle\", \"polygon\"]\n                     * @apioption  xAxis.gridLineInterpolation\n                     */\n                    gridLineInterpolation: 'circle',\n                    gridLineWidth: 1,\n                    labels: {\n                        align: 'right',\n                        x: -3,\n                        y: -2\n                    },\n                    showLastLabel: false,\n                    title: {\n                        x: 4,\n                        text: null,\n                        rotation: 90\n                    }\n                };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * In case of auto connect, add one closestPointRange to the max value\n             * right before tickPositions are computed, so that ticks will extend\n             * passed the real max.\n             * @private\n             */\n            function beforeSetTickPositions() {\n                // If autoConnect is true, polygonal grid lines are connected, and\n                // one closestPointRange is added to the X axis to prevent the last\n                // point from overlapping the first.\n                this.autoConnect = (this.isCircular &&\n                    typeof pick(this.userMax, this.options.max) === 'undefined' &&\n                    correctFloat(this.endAngleRad - this.startAngleRad) ===\n                        correctFloat(2 * Math.PI));\n                // This will lead to add an extra tick to xAxis in order to display\n                // a correct range on inverted polar\n                if (!this.isCircular && this.chart.inverted) {\n                    this.max++;\n                }\n                if (this.autoConnect) {\n                    this.max += ((this.categories && 1) ||\n                        this.pointRange ||\n                        this.closestPointRange ||\n                        0); // #1197, #2260\n                }\n            }\n            /**\n             * Augments methods for the value axis.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} AxisClass\n             * Axis class to extend.\n             *\n             * @param {Highcharts.Tick} TickClass\n             * Tick class to use.\n             *\n             * @return {Highcharts.Axis}\n             * Axis composition.\n             */\n            function compose(AxisClass, TickClass) {\n                if (composedClasses.indexOf(AxisClass) === -1) {\n                    composedClasses.push(AxisClass);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'autoLabelAlign', onAxisAutoLabelAlign);\n                    addEvent(AxisClass, 'destroy', onAxisDestroy);\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'initialAxisTranslation', onAxisInitialAxisTranslation);\n                }\n                if (composedClasses.indexOf(TickClass) === -1) {\n                    composedClasses.push(TickClass);\n                    addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                    addEvent(TickClass, 'afterGetPosition', onTickAfterGetPosition);\n                    wrap(TickClass.prototype, 'getMarkPath', wrapTickGetMarkPath);\n                }\n                return AxisClass;\n            }\n            RadialAxis.compose = compose;\n            /**\n             * Attach and return collecting function for labels in radial axis for\n             * anti-collision.\n             *\n             * @private\n             */\n            function createLabelCollector() {\n                var _this = this;\n                return function () {\n                    if (_this.isRadial &&\n                        _this.tickPositions &&\n                        // undocumented option for now, but working\n                        _this.options.labels &&\n                        _this.options.labels.allowOverlap !== true) {\n                        return _this.tickPositions\n                            .map(function (pos) {\n                            return _this.ticks[pos] && _this.ticks[pos].label;\n                        })\n                            .filter(function (label) {\n                            return Boolean(label);\n                        });\n                    }\n                };\n            }\n            /**\n             * Creates an empty collector function.\n             * @private\n             */\n            function createLabelCollectorHidden() {\n                return noop;\n            }\n            /**\n             * Find the correct end values of crosshair in polar.\n             * @private\n             */\n            function getCrosshairPosition(options, x1, y1) {\n                var center = this.pane.center;\n                var value = options.value,\n                    shapeArgs,\n                    end,\n                    x2,\n                    y2;\n                if (this.isCircular) {\n                    if (!defined(value)) {\n                        // When the snap is set to false\n                        x2 = options.chartX || 0;\n                        y2 = options.chartY || 0;\n                        value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);\n                    }\n                    else if (options.point) {\n                        // When the snap is set to true\n                        shapeArgs = options.point.shapeArgs || {};\n                        if (shapeArgs.start) {\n                            // Find a true value of the point based on the\n                            // angle\n                            value = this.chart.inverted ?\n                                this.translate(options.point.rectPlotY, true) :\n                                options.point.x;\n                        }\n                    }\n                    end = this.getPosition(value);\n                    x2 = end.x;\n                    y2 = end.y;\n                }\n                else {\n                    if (!defined(value)) {\n                        x2 = options.chartX;\n                        y2 = options.chartY;\n                    }\n                    if (defined(x2) && defined(y2)) {\n                        // Calculate radius of non-circular axis' crosshair\n                        y1 = center[1] + this.chart.plotTop;\n                        value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);\n                    }\n                }\n                return [value, x2 || 0, y2 || 0];\n            }\n            /**\n             * Get the path for the axis line. This method is also referenced in the\n             * getPlotLinePath method.\n             *\n             * @private\n             * @param {number} _lineWidth\n             * Line width is not used.\n             * @param {number} [radius]\n             * Radius of radial path.\n             * @param {number} [innerRadius]\n             * Inner radius of radial path.\n             */\n            function getLinePath(_lineWidth, radius, innerRadius) {\n                var center = this.pane.center,\n                    chart = this.chart,\n                    left = this.left || 0,\n                    top = this.top || 0;\n                var end,\n                    r = pick(radius,\n                    center[2] / 2 - this.offset),\n                    path;\n                if (typeof innerRadius === 'undefined') {\n                    innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;\n                }\n                // In case when innerSize of pane is set, it must be included\n                if (innerRadius) {\n                    r += innerRadius;\n                }\n                if (this.isCircular || typeof radius !== 'undefined') {\n                    path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {\n                        start: this.startAngleRad,\n                        end: this.endAngleRad,\n                        open: true,\n                        innerR: 0\n                    });\n                    // Bounds used to position the plotLine label next to the line\n                    // (#7117)\n                    path.xBounds = [left + center[0]];\n                    path.yBounds = [top + center[1] - r];\n                }\n                else {\n                    end = this.postTranslate(this.angleRad, r);\n                    path = [\n                        [\n                            'M',\n                            this.center[0] + chart.plotLeft,\n                            this.center[1] + chart.plotTop\n                        ],\n                        ['L', end.x, end.y]\n                    ];\n                }\n                return path;\n            }\n            /**\n             * Wrap the getOffset method to return zero offset for title or labels\n             * in a radial axis.\n             */\n            function getOffset() {\n                var axisProto = this.constructor.prototype;\n                // Call the Axis prototype method (the method we're in now is on the\n                // instance)\n                axisProto.getOffset.call(this);\n                // Title or label offsets are not counted\n                this.chart.axisOffset[this.side] = 0;\n            }\n            /**\n             * Find the path for plot bands along the radial axis.\n             *\n             * @private\n             */\n            function getPlotBandPath(from, to, options) {\n                var chart = this.chart,\n                    radiusToPixels = function (radius) {\n                        if (typeof radius === 'string') {\n                            var r = parseInt(radius, 10);\n                        if (percentRegex.test(radius)) {\n                            r = (r * fullRadius) / 100;\n                        }\n                        return r;\n                    }\n                    return radius;\n                }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular; // X axis in a polar chart\n                var start,\n                    end,\n                    angle,\n                    xOnPerimeter,\n                    open,\n                    path,\n                    outerRadius = pick(radiusToPixels(options.outerRadius),\n                    fullRadius),\n                    innerRadius = radiusToPixels(options.innerRadius),\n                    thickness = pick(radiusToPixels(options.thickness), 10);\n                // Polygonal plot bands\n                if (this.options.gridLineInterpolation === 'polygon') {\n                    path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));\n                    // Circular grid bands\n                }\n                else {\n                    // Keep within bounds\n                    from = Math.max(from, this.min);\n                    to = Math.min(to, this.max);\n                    var transFrom = this.translate(from),\n                        transTo = this.translate(to);\n                    // Plot bands on Y axis (radial axis) - inner and outer\n                    // radius depend on to and from\n                    if (!isCircular) {\n                        outerRadius = transFrom || 0;\n                        innerRadius = transTo || 0;\n                    }\n                    // Handle full circle\n                    if (options.shape === 'circle' || !isCircular) {\n                        start = -Math.PI / 2;\n                        end = Math.PI * 1.5;\n                        open = true;\n                    }\n                    else {\n                        start = startAngleRad + (transFrom || 0);\n                        end = startAngleRad + (transTo || 0);\n                    }\n                    outerRadius -= offset; // #5283\n                    thickness -= offset; // #5283\n                    path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {\n                        // Math is for reversed yAxis (#3606)\n                        start: Math.min(start, end),\n                        end: Math.max(start, end),\n                        innerR: pick(innerRadius, outerRadius - thickness),\n                        open: open\n                    });\n                    // Provide positioning boxes for the label (#6406)\n                    if (isCircular) {\n                        angle = (end + start) / 2;\n                        xOnPerimeter = (left +\n                            center[0] +\n                            (center[2] / 2) * Math.cos(angle));\n                        path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ?\n                            // Right hemisphere\n                            [xOnPerimeter, chart.plotWidth] :\n                            // Left hemisphere\n                            [0, xOnPerimeter];\n                        path.yBounds = [\n                            top + center[1] + (center[2] / 2) * Math.sin(angle)\n                        ];\n                        // Shift up or down to get the label clear of the perimeter\n                        path.yBounds[0] += ((angle > -Math.PI && angle < 0) ||\n                            (angle > Math.PI)) ? -10 : 10;\n                    }\n                }\n                return path;\n            }\n            /**\n             * Find the path for plot lines perpendicular to the radial axis.\n             */\n            function getPlotLinePath(options) {\n                var _this = this;\n                var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ?\n                        (this.pane.options.background[0] ||\n                            this.pane.options.background) :\n                        {}, innerRadius = background.innerRadius || '0%', outerRadius = background.outerRadius || '100%', x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;\n                var value = options.value,\n                    innerRatio,\n                    distance,\n                    a,\n                    b,\n                    otherAxis,\n                    xy,\n                    tickPositions,\n                    crossPos,\n                    path;\n                var end = this.getPosition(value);\n                var x2 = end.x,\n                    y2 = end.y;\n                // Crosshair logic\n                if (isCrosshair) {\n                    // Find crosshair's position and perform destructuring\n                    // assignment\n                    crossPos = this.getCrosshairPosition(options, x1, y1);\n                    value = crossPos[0];\n                    x2 = crossPos[1];\n                    y2 = crossPos[2];\n                }\n                // Spokes\n                if (this.isCircular) {\n                    distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n                    a = (typeof innerRadius === 'string') ?\n                        relativeLength(innerRadius, 1) :\n                        (innerRadius / distance);\n                    b = (typeof outerRadius === 'string') ?\n                        relativeLength(outerRadius, 1) :\n                        (outerRadius / distance);\n                    // To ensure that gridlines won't be displayed in area\n                    // defined by innerSize in case of custom radiuses of pane's\n                    // background\n                    if (center && paneInnerR) {\n                        innerRatio = paneInnerR / distance;\n                        if (a < innerRatio) {\n                            a = innerRatio;\n                        }\n                        if (b < innerRatio) {\n                            b = innerRatio;\n                        }\n                    }\n                    path = [\n                        ['M', x1 + a * (x2 - x1), y1 - a * (y1 - y2)],\n                        ['L', x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]\n                    ];\n                    // Concentric circles\n                }\n                else {\n                    // Pick the right values depending if it is grid line or\n                    // crosshair\n                    value = this.translate(value);\n                    // This is required in case when xAxis is non-circular to\n                    // prevent grid lines (or crosshairs, if enabled) from\n                    // rendering above the center after they supposed to be\n                    // displayed below the center point\n                    if (value) {\n                        if (value < 0 || value > height) {\n                            value = 0;\n                        }\n                    }\n                    if (this.options.gridLineInterpolation === 'circle') {\n                        // A value of 0 is in the center, so it won't be\n                        // visible, but draw it anyway for update and animation\n                        // (#2366)\n                        path = this.getLinePath(0, value, paneInnerR);\n                        // Concentric polygons\n                    }\n                    else {\n                        path = [];\n                        // Find the other axis (a circular one) in the same pane\n                        chart[inverted ? 'yAxis' : 'xAxis'].forEach(function (a) {\n                            if (a.pane === _this.pane) {\n                                otherAxis = a;\n                            }\n                        });\n                        if (otherAxis) {\n                            tickPositions = otherAxis.tickPositions;\n                            if (otherAxis.autoConnect) {\n                                tickPositions =\n                                    tickPositions.concat([tickPositions[0]]);\n                            }\n                            // Reverse the positions for concatenation of polygonal\n                            // plot bands\n                            if (reverse) {\n                                tickPositions = tickPositions.slice().reverse();\n                            }\n                            if (value) {\n                                value += paneInnerR;\n                            }\n                            for (var i = 0; i < tickPositions.length; i++) {\n                                xy = otherAxis.getPosition(tickPositions[i], value);\n                                path.push(i ? ['L', xy.x, xy.y] : ['M', xy.x, xy.y]);\n                            }\n                        }\n                    }\n                }\n                return path;\n            }\n            /**\n             * Returns the x, y coordinate of a point given by a value and a pixel\n             * distance from center.\n             *\n             * @private\n             * @param {number} value\n             * Point value.\n             * @param {number} [length]\n             * Distance from center.\n             */\n            function getPosition(value, length) {\n                var translatedVal = this.translate(value);\n                return this.postTranslate(this.isCircular ? translatedVal : this.angleRad, // #2848\n                // In case when translatedVal is negative, the 0 value must be\n                // used instead, in order to deal with lines and labels that\n                // fall out of the visible range near the center of a pane\n                pick(this.isCircular ?\n                    length :\n                    (translatedVal < 0 ? 0 : translatedVal), this.center[2] / 2) - this.offset);\n            }\n            /**\n             * Find the position for the axis title, by default inside the gauge.\n             */\n            function getTitlePosition() {\n                var center = this.center,\n                    chart = this.chart,\n                    titleOptions = this.options.title;\n                return {\n                    x: chart.plotLeft + center[0] + (titleOptions.x || 0),\n                    y: (chart.plotTop +\n                        center[1] -\n                        ({\n                            high: 0.5,\n                            middle: 0.25,\n                            low: 0\n                        }[titleOptions.align] *\n                            center[2]) +\n                        (titleOptions.y || 0))\n                };\n            }\n            /**\n             * Modify radial axis.\n             * @private\n             *\n             * @param {Highcharts.Axis} radialAxis\n             * Radial axis to modify.\n             */\n            function modify(axis) {\n                axis.beforeSetTickPositions = beforeSetTickPositions;\n                axis.createLabelCollector = createLabelCollector;\n                axis.getCrosshairPosition = getCrosshairPosition;\n                axis.getLinePath = getLinePath;\n                axis.getOffset = getOffset;\n                axis.getPlotBandPath = getPlotBandPath;\n                axis.getPlotLinePath = getPlotLinePath;\n                axis.getPosition = getPosition;\n                axis.getTitlePosition = getTitlePosition;\n                axis.postTranslate = postTranslate;\n                axis.setAxisSize = setAxisSize;\n                axis.setAxisTranslation = setAxisTranslation;\n                axis.setOptions = setOptions;\n            }\n            /**\n             * Modify radial axis as hidden.\n             * @private\n             *\n             * @param {Highcharts.Axis} radialAxis\n             * Radial axis to modify.\n             */\n            function modifyAsHidden(radialAxis) {\n                radialAxis.isHidden = true;\n                radialAxis.createLabelCollector = createLabelCollectorHidden;\n                radialAxis.getOffset = noop;\n                radialAxis.redraw = renderHidden;\n                radialAxis.render = renderHidden;\n                radialAxis.setScale = noop;\n                radialAxis.setCategories = noop;\n                radialAxis.setTitle = noop;\n            }\n            /**\n             * Finalize modification of axis instance with radial logic.\n             */\n            function onAxisAfterInit() {\n                var chart = this.chart,\n                    options = this.options,\n                    isHidden = chart.angular && this.isXAxis,\n                    pane = this.pane,\n                    paneOptions = pane && pane.options;\n                if (!isHidden && pane && (chart.angular || chart.polar)) {\n                    var fullCircle = Math.PI * 2, \n                        // Start and end angle options are given in degrees relative to\n                        // top, while internal computations are in radians relative to\n                        // right (like SVG).\n                        start = (pick(paneOptions.startAngle, 0) - 90) * Math.PI / 180,\n                        end = (pick(paneOptions.endAngle,\n                        pick(paneOptions.startAngle, 0) + 360) - 90) * Math.PI / 180;\n                    // Y axis in polar charts\n                    this.angleRad = (options.angle || 0) * Math.PI / 180;\n                    // Gauges\n                    this.startAngleRad = start;\n                    this.endAngleRad = end;\n                    this.offset = options.offset || 0;\n                    // Normalize Start and End to <0, 2*PI> range\n                    // (in degrees: <0,360>)\n                    var normalizedStart = (start % fullCircle + fullCircle) %\n                            fullCircle,\n                        normalizedEnd = (end % fullCircle + fullCircle) % fullCircle;\n                    // Move normalized angles to <-PI, PI> range (<-180, 180>)\n                    // to match values returned by Math.atan2()\n                    if (normalizedStart > Math.PI) {\n                        normalizedStart -= fullCircle;\n                    }\n                    if (normalizedEnd > Math.PI) {\n                        normalizedEnd -= fullCircle;\n                    }\n                    this.normalizedStartAngleRad = normalizedStart;\n                    this.normalizedEndAngleRad = normalizedEnd;\n                }\n            }\n            /**\n             * Wrap auto label align to avoid setting axis-wide rotation on radial axes.\n             * (#4920)\n             */\n            function onAxisAutoLabelAlign(e) {\n                if (this.isRadial) {\n                    e.align = void 0;\n                    e.preventDefault();\n                }\n            }\n            /**\n             * Remove label collector function on axis remove/update.\n             */\n            function onAxisDestroy() {\n                if (this.chart &&\n                    this.chart.labelCollectors) {\n                    var index = (this.labelCollector ?\n                            this.chart.labelCollectors.indexOf(this.labelCollector) :\n                            -1);\n                    if (index >= 0) {\n                        this.chart.labelCollectors.splice(index, 1);\n                    }\n                }\n            }\n            /**\n             * Modify axis instance with radial logic before common axis init.\n             */\n            function onAxisInit(e) {\n                var chart = this.chart,\n                    inverted = chart.inverted,\n                    angular = chart.angular,\n                    polar = chart.polar,\n                    isX = this.isXAxis,\n                    coll = this.coll,\n                    isHidden = angular && isX,\n                    chartOptions = chart.options,\n                    paneIndex = e.userOptions.pane || 0,\n                    pane = this.pane = chart.pane && chart.pane[paneIndex];\n                var isCircular;\n                // Prevent changes for colorAxis\n                if (coll === 'colorAxis') {\n                    this.isRadial = false;\n                    return;\n                }\n                // Before prototype.init\n                if (angular) {\n                    if (isHidden) {\n                        modifyAsHidden(this);\n                    }\n                    else {\n                        modify(this);\n                    }\n                    isCircular = !isX;\n                    if (isCircular) {\n                        this.defaultPolarOptions = defaultRadialGaugeOptions;\n                    }\n                }\n                else if (polar) {\n                    modify(this);\n                    // Check which axis is circular\n                    isCircular = this.horiz;\n                    this.defaultPolarOptions = isCircular ?\n                        defaultCircularOptions :\n                        merge(coll === 'xAxis' ?\n                            AxisDefaults.defaultXAxisOptions :\n                            AxisDefaults.defaultYAxisOptions, defaultRadialOptions);\n                    // Apply the stack labels for yAxis in case of inverted chart\n                    if (inverted && coll === 'yAxis') {\n                        this.defaultPolarOptions.stackLabels = AxisDefaults\n                            .defaultYAxisOptions.stackLabels;\n                        this.defaultPolarOptions.reversedStacks = true;\n                    }\n                }\n                // Disable certain features on angular and polar axes\n                if (angular || polar) {\n                    this.isRadial = true;\n                    if (!this.labelCollector) {\n                        this.labelCollector = this.createLabelCollector();\n                    }\n                    if (this.labelCollector) {\n                        // Prevent overlapping axis labels (#9761)\n                        chart.labelCollectors.push(this.labelCollector);\n                    }\n                }\n                else {\n                    this.isRadial = false;\n                }\n                // A pointer back to this axis to borrow geometry\n                if (pane && isCircular) {\n                    pane.axis = this;\n                }\n                this.isCircular = isCircular;\n            }\n            /**\n             * Prepare axis translation.\n             */\n            function onAxisInitialAxisTranslation() {\n                if (this.isRadial) {\n                    this.beforeSetTickPositions();\n                }\n            }\n            /**\n             * Find the center position of the label based on the distance option.\n             */\n            function onTickAfterGetLabelPosition(e) {\n                var label = this.label;\n                if (!label) {\n                    return;\n                }\n                var axis = this.axis,\n                    labelBBox = label.getBBox(),\n                    labelOptions = axis.options.labels,\n                    angle = ((axis.translate(this.pos) + axis.startAngleRad +\n                        Math.PI / 2) / Math.PI * 180) % 360,\n                    correctAngle = Math.round(angle),\n                    labelYPosCorrection = !defined(labelOptions.y) ? -labelBBox.height * 0.3 : 0;\n                var optionsY = labelOptions.y, ret, centerSlot = 20, // 20 degrees to each side at the top and bottom\n                    align = labelOptions.align, labelDir = 'end', // Direction of the label 'start' or 'end'\n                    reducedAngle1 = correctAngle < 0 ?\n                        correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;\n                if (axis.isRadial) { // Both X and Y axes in a polar chart\n                    ret = axis.getPosition(this.pos, (axis.center[2] / 2) +\n                        relativeLength(pick(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));\n                    // Automatically rotated\n                    if (labelOptions.rotation === 'auto') {\n                        label.attr({\n                            rotation: angle\n                        });\n                        // Vertically centered\n                    }\n                    else if (!defined(optionsY)) {\n                        optionsY = (axis.chart.renderer\n                            .fontMetrics(label.styles && label.styles.fontSize).b -\n                            labelBBox.height / 2);\n                    }\n                    // Automatic alignment\n                    if (!defined(align)) {\n                        if (axis.isCircular) { // Y axis\n                            if (labelBBox.width >\n                                axis.len * axis.tickInterval / (axis.max - axis.min)) { // #3506\n                                centerSlot = 0;\n                            }\n                            if (angle > centerSlot && angle < 180 - centerSlot) {\n                                align = 'left'; // right hemisphere\n                            }\n                            else if (angle > 180 + centerSlot &&\n                                angle < 360 - centerSlot) {\n                                align = 'right'; // left hemisphere\n                            }\n                            else {\n                                align = 'center'; // top or bottom\n                            }\n                        }\n                        else {\n                            align = 'center';\n                        }\n                        label.attr({\n                            align: align\n                        });\n                    }\n                    // Auto alignment for solid-gauges with two labels (#10635)\n                    if (align === 'auto' &&\n                        axis.tickPositions.length === 2 &&\n                        axis.isCircular) {\n                        // Angles reduced to 0 - 90 or 180 - 270\n                        if (reducedAngle1 > 90 && reducedAngle1 < 180) {\n                            reducedAngle1 = 180 - reducedAngle1;\n                        }\n                        else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {\n                            reducedAngle1 = 540 - reducedAngle1;\n                        }\n                        // Angles reduced to 0 - 180\n                        if (reducedAngle2 > 180 && reducedAngle2 <= 360) {\n                            reducedAngle2 = 360 - reducedAngle2;\n                        }\n                        if ((axis.pane.options.startAngle === correctAngle) ||\n                            (axis.pane.options.startAngle === correctAngle + 360) ||\n                            (axis.pane.options.startAngle === correctAngle - 360)) {\n                            labelDir = 'start';\n                        }\n                        if ((correctAngle >= -90 && correctAngle <= 90) ||\n                            (correctAngle >= -360 && correctAngle <= -270) ||\n                            (correctAngle >= 270 && correctAngle <= 360)) {\n                            align = (labelDir === 'start') ? 'right' : 'left';\n                        }\n                        else {\n                            align = (labelDir === 'start') ? 'left' : 'right';\n                        }\n                        // For angles beetwen (90 + n * 180) +- 20\n                        if (reducedAngle2 > 70 && reducedAngle2 < 110) {\n                            align = 'center';\n                        }\n                        // auto Y translation\n                        if (reducedAngle1 < 15 ||\n                            (reducedAngle1 >= 180 && reducedAngle1 < 195)) {\n                            translateY = labelBBox.height * 0.3;\n                        }\n                        else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {\n                            translateY = labelDir === 'start' ?\n                                0 : labelBBox.height * 0.75;\n                        }\n                        else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {\n                            translateY = labelDir === 'start' ?\n                                labelBBox.height * 0.75 : 0;\n                        }\n                        else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {\n                            translateY = labelDir === 'start' ?\n                                -labelBBox.height * 0.25 : labelBBox.height;\n                        }\n                        else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {\n                            translateY = labelDir === 'start' ?\n                                labelBBox.height : -labelBBox.height * 0.25;\n                        }\n                        // auto X translation\n                        if (reducedAngle2 < 15) {\n                            translateX = labelDir === 'start' ?\n                                -labelBBox.height * 0.15 : labelBBox.height * 0.15;\n                        }\n                        else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {\n                            translateX = labelDir === 'start' ?\n                                labelBBox.height * 0.15 : -labelBBox.height * 0.15;\n                        }\n                        label.attr({ align: align });\n                        label.translate(translateX, translateY + labelYPosCorrection);\n                    }\n                    e.pos.x = ret.x + (labelOptions.x || 0);\n                    e.pos.y = ret.y + (optionsY || 0);\n                }\n            }\n            /**\n             * Add special cases within the Tick class' methods for radial axes.\n             */\n            function onTickAfterGetPosition(e) {\n                if (this.axis.getPosition) {\n                    extend(e.pos, this.axis.getPosition(this.pos));\n                }\n            }\n            /**\n             * Translate from intermediate plotX (angle), plotY (axis.len - radius)\n             * to final chart coordinates.\n             *\n             * @private\n             * @param {number} angle\n             * Translation angle.\n             * @param {number} radius\n             * Translation radius.\n             */\n            function postTranslate(angle, radius) {\n                var chart = this.chart,\n                    center = this.center;\n                angle = this.startAngleRad + angle;\n                return {\n                    x: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n                    y: chart.plotTop + center[1] + Math.sin(angle) * radius\n                };\n            }\n            /**\n             * Prevent setting Y axis dirty.\n             */\n            function renderHidden() {\n                this.isDirty = false;\n            }\n            /**\n             * Override the setAxisSize method to use the arc's circumference as\n             * length. This allows tickPixelInterval to apply to pixel lengths along\n             * the perimeter.\n             * @private\n             */\n            function setAxisSize() {\n                var axisProto = this.constructor.prototype;\n                var center,\n                    start;\n                axisProto.setAxisSize.call(this);\n                if (this.isRadial) {\n                    // Set the center array\n                    this.pane.updateCenter(this);\n                    // In case when the innerSize is set in a polar chart, the axis'\n                    // center cannot be a reference to pane's center\n                    center = this.center = this.pane.center.slice();\n                    // The sector is used in Axis.translate to compute the\n                    // translation of reversed axis points (#2570)\n                    if (this.isCircular) {\n                        this.sector = this.endAngleRad - this.startAngleRad;\n                    }\n                    else {\n                        // When the pane's startAngle or the axis' angle is set then\n                        // new x and y values for vertical axis' center must be\n                        // calulated\n                        start = this.postTranslate(this.angleRad, center[3] / 2);\n                        center[0] = start.x - this.chart.plotLeft;\n                        center[1] = start.y - this.chart.plotTop;\n                    }\n                    // Axis len is used to lay out the ticks\n                    this.len = this.width = this.height =\n                        (center[2] - center[3]) * pick(this.sector, 1) / 2;\n                }\n            }\n            /**\n             * Override setAxisTranslation by setting the translation to the\n             * difference in rotation. This allows the translate method to return\n             * angle for any given value.\n             *\n             * @private\n             */\n            function setAxisTranslation() {\n                var axisProto = this.constructor.prototype;\n                // Call uber method\n                axisProto.setAxisTranslation.call(this);\n                // Set transA and minPixelPadding\n                if (this.center) { // it's not defined the first time\n                    if (this.isCircular) {\n                        this.transA = (this.endAngleRad - this.startAngleRad) /\n                            ((this.max - this.min) || 1);\n                    }\n                    else {\n                        // The transA here is the length of the axis, so in case\n                        // of inner radius, the length must be decreased by it\n                        this.transA = ((this.center[2] - this.center[3]) / 2) /\n                            ((this.max - this.min) || 1);\n                    }\n                    if (this.isXAxis) {\n                        this.minPixelPadding = this.transA * this.minPointOffset;\n                    }\n                    else {\n                        // This is a workaround for regression #2593, but categories\n                        // still don't position correctly.\n                        this.minPixelPadding = 0;\n                    }\n                }\n            }\n            /**\n             * Merge and set options.\n             */\n            function setOptions(userOptions) {\n                var options = this.options = merge(this.constructor.defaultOptions,\n                    this.defaultPolarOptions,\n                    defaultOptions[this.coll], // #16112\n                    userOptions);\n                // Make sure the plotBands array is instanciated for each Axis\n                // (#2649)\n                if (!options.plotBands) {\n                    options.plotBands = [];\n                }\n                fireEvent(this, 'afterSetOptions');\n            }\n            /**\n             * Wrap the getMarkPath function to return the path of the radial marker.\n             */\n            function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {\n                var axis = this.axis;\n                var endPoint,\n                    ret;\n                if (axis.isRadial) {\n                    endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);\n                    ret = [\n                        'M',\n                        x,\n                        y,\n                        'L',\n                        endPoint.x,\n                        endPoint.y\n                    ];\n                }\n                else {\n                    ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);\n                }\n                return ret;\n            }\n            /* eslint-enable valid-jsdoc */\n        })(RadialAxis || (RadialAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return RadialAxis;\n    });\n    _registerModule(_modules, 'Series/PolarComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Extensions/Pane.js'], _modules['Core/Axis/RadialAxis.js'], _modules['Core/Utilities.js']], function (A, H, Pane, RadialAxis, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __spreadArray = (this && this.__spreadArray) || function (to,\n            from,\n            pack) {\n                if (pack || arguments.length === 2) for (var i = 0,\n            l = from.length,\n            ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0,\n            i);\n                    ar[i] = from[i];\n                }\n            }\n            return to.concat(ar || Array.prototype.slice.call(from));\n        };\n        var animObject = A.animObject;\n        var addEvent = U.addEvent,\n            defined = U.defined,\n            find = U.find,\n            isNumber = U.isNumber,\n            pick = U.pick,\n            splat = U.splat,\n            uniqueKey = U.uniqueKey,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function clipCircle(renderer, x, y, r, innerR) {\n            var id = uniqueKey(),\n                clipPath = renderer.createElement('clipPath').attr({\n                    id: id\n                }).add(renderer.defs),\n                wrapper = innerR ?\n                    renderer.arc(x,\n                y,\n                r,\n                innerR, 0, 2 * Math.PI).add(clipPath) :\n                    renderer.circle(x,\n                y,\n                r).add(clipPath);\n            wrapper.id = id;\n            wrapper.clipPath = clipPath;\n            return wrapper;\n        }\n        /**\n         * Find correct align and vertical align based on an angle in polar chart\n         * @private\n         */\n        function findAlignments(angle, options) {\n            var align,\n                verticalAlign;\n            if (options.align === null) {\n                if (angle > 20 && angle < 160) {\n                    align = 'left'; // right hemisphere\n                }\n                else if (angle > 200 && angle < 340) {\n                    align = 'right'; // left hemisphere\n                }\n                else {\n                    align = 'center'; // top or bottom\n                }\n                options.align = align;\n            }\n            if (options.verticalAlign === null) {\n                if (angle < 45 || angle > 315) {\n                    verticalAlign = 'bottom'; // top part\n                }\n                else if (angle > 135 && angle < 225) {\n                    verticalAlign = 'top'; // bottom part\n                }\n                else {\n                    verticalAlign = 'middle'; // left or right\n                }\n                options.verticalAlign = verticalAlign;\n            }\n            return options;\n        }\n        /**\n         * #6212 Calculate connectors for spline series in polar chart.\n         * @private\n         * @param {boolean} calculateNeighbours\n         *        Check if connectors should be calculated for neighbour points as\n         *        well allows short recurence\n         */\n        function getConnectors(segment, index, calculateNeighbours, connectEnds) {\n            var smoothing = 1.5,\n                denom = smoothing + 1,\n                addedNumber = connectEnds ? 1 : 0;\n            var i,\n                leftContX,\n                leftContY,\n                rightContX,\n                rightContY,\n                jointAngle;\n            // Calculate final index of points depending on the initial index value.\n            // Because of calculating neighbours, index may be outisde segment\n            // array.\n            if (index >= 0 && index <= segment.length - 1) {\n                i = index;\n            }\n            else if (index < 0) {\n                i = segment.length - 1 + index;\n            }\n            else {\n                i = 0;\n            }\n            // 1 means control points midway between points, 2 means 1/3 from\n            // the point, 3 is 1/4 etc;\n            var prevPointInd = ((i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1),\n                nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1,\n                previousPoint = segment[prevPointInd],\n                nextPoint = segment[nextPointInd],\n                previousX = previousPoint.plotX,\n                previousY = previousPoint.plotY,\n                nextX = nextPoint.plotX,\n                nextY = nextPoint.plotY,\n                plotX = segment[i].plotX, // actual point\n                plotY = segment[i].plotY;\n            leftContX = (smoothing * plotX + previousX) / denom;\n            leftContY = (smoothing * plotY + previousY) / denom;\n            rightContX = (smoothing * plotX + nextX) / denom;\n            rightContY = (smoothing * plotY + nextY) / denom;\n            // distance left control point\n            var dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)),\n                dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)),\n                leftContAngle = Math.atan2(leftContY - plotY,\n                leftContX - plotX),\n                rightContAngle = Math.atan2(rightContY - plotY,\n                rightContX - plotX);\n            jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n            // Ensure the right direction, jointAngle should be in the same quadrant\n            // as leftContAngle\n            if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n                jointAngle -= Math.PI;\n            }\n            // Find the corrected control points for a spline straight through the\n            // point\n            leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;\n            leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;\n            rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;\n            rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;\n            // push current point's connectors into returned object\n            var ret = {\n                    rightContX: rightContX,\n                    rightContY: rightContY,\n                    leftContX: leftContX,\n                    leftContY: leftContY,\n                    plotX: plotX,\n                    plotY: plotY\n                };\n            // calculate connectors for previous and next point and push them inside\n            // returned object\n            if (calculateNeighbours) {\n                ret.prevPointCont = getConnectors(segment, prevPointInd, false, connectEnds);\n            }\n            return ret;\n        }\n        function onChartAfterDrawChartBox() {\n            (this.pane || []).forEach(function (pane) {\n                pane.render();\n            });\n        }\n        /**\n         * If polar has polygonal grid lines, force start and endOnTick on radial axis\n         * @private\n         */\n        function onChartAfterInit(event) {\n            var xAxis = event.args[0].xAxis,\n                yAxis = event.args[0].yAxis,\n                chart = event.args[0].chart;\n            if (xAxis && yAxis) {\n                if (yAxis.gridLineInterpolation === 'polygon') {\n                    xAxis.startOnTick = true;\n                    xAxis.endOnTick = true;\n                }\n                else if (xAxis.gridLineInterpolation === 'polygon' &&\n                    chart.inverted) {\n                    yAxis.startOnTick = true;\n                    yAxis.endOnTick = true;\n                }\n            }\n        }\n        function onChartGetAxes() {\n            var _this = this;\n            if (!this.pane) {\n                this.pane = [];\n            }\n            this.options.pane = splat(this.options.pane);\n            this.options.pane.forEach(function (paneOptions) {\n                new Pane(// eslint-disable-line no-new\n                paneOptions, _this);\n            }, this);\n        }\n        /**\n         * Get selection dimensions\n         * @private\n         */\n        function onPointerGetSelectionBox(event) {\n            var marker = event.args.marker,\n                xAxis = this.chart.xAxis[0],\n                yAxis = this.chart.yAxis[0],\n                inverted = this.chart.inverted,\n                radialAxis = inverted ? yAxis : xAxis,\n                linearAxis = inverted ? xAxis : yAxis;\n            if (this.chart.polar) {\n                event.preventDefault();\n                var start = (marker.attr ? marker.attr('start') : marker.start) - radialAxis.startAngleRad;\n                var r = (marker.attr ? marker.attr('r') : marker.r);\n                var end = (marker.attr ? marker.attr('end') : marker.end) - radialAxis.startAngleRad;\n                var innerR = (marker.attr ? marker.attr('innerR') : marker.innerR);\n                event.result.x = start + radialAxis.pos;\n                event.result.width = end - start;\n                // innerR goes from pane's center but toValue computes values from top\n                event.result.y = linearAxis.len + linearAxis.pos - innerR;\n                event.result.height = innerR - r;\n            }\n        }\n        /**\n         * Get attrs for Polar selection marker\n         * @private\n         */\n        function onPointerGetSelectionMarkerAttrs(event) {\n            var chart = this.chart;\n            if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {\n                event.preventDefault();\n                var center = chart.hoverPane.center,\n                    mouseDownX = (this.mouseDownX || 0),\n                    mouseDownY = (this.mouseDownY || 0),\n                    chartY = event.args.chartY,\n                    chartX = event.args.chartX,\n                    fullCircle = Math.PI * 2,\n                    startAngleRad = chart.hoverPane.axis.startAngleRad,\n                    endAngleRad = chart.hoverPane.axis.endAngleRad,\n                    linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0],\n                    attrs = {};\n                var shapeType = 'arc';\n                attrs.x = center[0] + chart.plotLeft;\n                attrs.y = center[1] + chart.plotTop;\n                // Adjust the width of the selection marker\n                if (this.zoomHor) {\n                    var paneRadRange = startAngleRad > 0 ?\n                            endAngleRad - startAngleRad :\n                            Math.abs(startAngleRad) + Math.abs(endAngleRad);\n                    var startAngle = Math.atan2(mouseDownY - chart.plotTop - center[1],\n                        mouseDownX - chart.plotLeft - center[0]) - startAngleRad,\n                        endAngle = Math.atan2(chartY - chart.plotTop - center[1],\n                        chartX - chart.plotLeft - center[0]) - startAngleRad;\n                    attrs.r = center[2] / 2;\n                    attrs.innerR = center[3] / 2;\n                    if (startAngle <= 0) {\n                        startAngle += fullCircle;\n                    }\n                    if (endAngle <= 0) {\n                        endAngle += fullCircle;\n                    }\n                    if (endAngle < startAngle) {\n                        // Swapping angles\n                        endAngle = [startAngle, startAngle = endAngle][0];\n                    }\n                    // If pane is not a full circle we need to let users zoom to the min\n                    // We do this by swapping angles after pointer crosses\n                    // middle angle (swapAngle) of the missing slice of the pane\n                    if (paneRadRange < fullCircle) {\n                        var swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;\n                        if (startAngleRad + endAngle > swapAngle) {\n                            endAngle = startAngle;\n                            startAngle = startAngleRad <= 0 ? startAngleRad : 0;\n                        }\n                    }\n                    var start = attrs.start =\n                            Math.max(startAngle + startAngleRad,\n                        startAngleRad),\n                        end = attrs.end =\n                            Math.min(endAngle + startAngleRad,\n                        endAngleRad);\n                    // Adjust the selection shape for polygon grid lines\n                    if (linearAxis.options.gridLineInterpolation === 'polygon') {\n                        var radialAxis = chart.hoverPane.axis,\n                            tickInterval = radialAxis.tickInterval,\n                            min = start - radialAxis.startAngleRad + radialAxis.pos,\n                            max = end - start;\n                        var path = linearAxis.getPlotLinePath({\n                                value: linearAxis.max\n                            }),\n                            pathStart = radialAxis.toValue(min),\n                            pathEnd = radialAxis.toValue(min + max);\n                        if (pathStart < radialAxis.getExtremes().min) {\n                            var _a = radialAxis.getExtremes(),\n                                min_1 = _a.min,\n                                max_1 = _a.max;\n                            pathStart = max_1 - (min_1 - pathStart);\n                        }\n                        if (pathEnd < radialAxis.getExtremes().min) {\n                            var _b = radialAxis.getExtremes(),\n                                min_2 = _b.min,\n                                max_2 = _b.max;\n                            pathEnd = max_2 - (min_2 - pathEnd);\n                        }\n                        if (pathEnd < pathStart) {\n                            // Swapping angles\n                            pathEnd = [pathStart, pathStart = pathEnd][0];\n                        }\n                        // Get trimmed path\n                        path = trimPath(path, pathStart, pathEnd, radialAxis);\n                        // Add center to the path\n                        path.push([\n                            'L', center[0] + chart.plotLeft,\n                            chart.plotTop + center[1]\n                        ]);\n                        attrs.d = path;\n                        shapeType = 'path';\n                    }\n                }\n                // Adjust the height of the selection marker\n                if (this.zoomVert) {\n                    var linearAxis_1 = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];\n                    var innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) +\n                            Math.pow(mouseDownY - chart.plotTop - center[1], 2)),\n                        r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) +\n                            Math.pow(chartY - chart.plotTop - center[1], 2));\n                    if (r < innerR) {\n                        // Swapping angles\n                        innerR = [r, r = innerR][0];\n                    }\n                    if (r > center[2] / 2) {\n                        r = center[2] / 2;\n                    }\n                    if (innerR < center[3] / 2) {\n                        innerR = center[3] / 2;\n                    }\n                    if (!this.zoomHor) {\n                        attrs.start = startAngleRad;\n                        attrs.end = endAngleRad;\n                    }\n                    attrs.r = r;\n                    attrs.innerR = innerR;\n                    if (linearAxis_1.options.gridLineInterpolation === 'polygon') {\n                        var end = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - innerR),\n                            start = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - r),\n                            path = linearAxis_1.getPlotLinePath({\n                                value: start\n                            }).concat(linearAxis_1.getPlotLinePath({\n                                value: end,\n                                reverse: true\n                            }));\n                        attrs.d = path;\n                        shapeType = 'path';\n                    }\n                }\n                if (this.zoomHor &&\n                    this.zoomVert &&\n                    linearAxis.options.gridLineInterpolation === 'polygon') {\n                    var radialAxis = chart.hoverPane.axis,\n                        start = attrs.start || 0,\n                        end = attrs.end || 0,\n                        min = start - radialAxis.startAngleRad + radialAxis.pos,\n                        max = end - start,\n                        pathStart = radialAxis.toValue(min),\n                        pathEnd = radialAxis.toValue(min + max);\n                    // Trim path\n                    if (attrs.d instanceof Array) {\n                        var innerPath = attrs.d.slice(0,\n                            attrs.d.length / 2),\n                            outerPath = attrs.d.slice(attrs.d.length / 2,\n                            attrs.d.length);\n                        outerPath = __spreadArray([], outerPath, true).reverse();\n                        var radialAxis_1 = chart.hoverPane.axis;\n                        innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis_1);\n                        outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis_1);\n                        if (outerPath) {\n                            (outerPath[0][0]) = 'L';\n                        }\n                        outerPath = __spreadArray([], outerPath, true).reverse();\n                        attrs.d = innerPath.concat(outerPath);\n                        shapeType = 'path';\n                    }\n                }\n                event.attrs = attrs;\n                event.shapeType = shapeType;\n            }\n        }\n        /**\n         * @private\n         */\n        function onSeriesAfterInit() {\n            var chart = this.chart;\n            if (chart.polar) {\n                this.polar = new PolarAdditions(this);\n                // Add flags that identifies radial inverted series\n                if (chart.inverted) {\n                    this.isRadialSeries = true;\n                    if (this.is('column')) {\n                        this.isRadialBar = true;\n                    }\n                }\n            }\n        }\n        /**\n         * Extend translate. The plotX and plotY values are computed as if the polar\n         * chart were a cartesian plane, where plotX denotes the angle in radians\n         * and (yAxis.len - plotY) is the pixel distance from center.\n         * @private\n         */\n        function onSeriesAfterTranslate() {\n            if (this.chart.polar && this.xAxis) {\n                var series = this,\n                    chart_1 = series.chart;\n                // Prepare k-d-tree handling. It searches by angle (clientX) in\n                // case of shared tooltip, and by two dimensional distance in case\n                // of non-shared.\n                series.kdByAngle = chart_1.tooltip && chart_1.tooltip.shared;\n                if (series.kdByAngle) {\n                    series.searchPoint = searchPointByAngle;\n                }\n                else {\n                    series.options.findNearestPointBy = 'xy';\n                }\n                var points = series.points;\n                var i = points.length;\n                while (i--) {\n                    // Translate plotX, plotY from angle and radius to true plot\n                    // coordinates\n                    if (!series.preventPostTranslate) {\n                        series.polar.toXY(points[i]);\n                    }\n                    // Treat points below Y axis min as null (#10082)\n                    if (!chart_1.hasParallelCoordinates &&\n                        !series.yAxis.reversed) {\n                        if (pick(points[i].y, Number.MIN_VALUE) < series.yAxis.min ||\n                            points[i].x < series.xAxis.min ||\n                            points[i].x > series.xAxis.max) {\n                            // Destroy markers\n                            points[i].isNull = true;\n                            // Destroy column's graphic\n                            points[i].plotY = NaN;\n                        }\n                        else {\n                            // Restore isNull flag\n                            points[i].isNull =\n                                points[i].isValid && !points[i].isValid();\n                        }\n                    }\n                }\n                // Perform clip after render\n                if (!this.hasClipCircleSetter) {\n                    this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent(series, 'afterRender', function () {\n                        var circ;\n                        if (chart_1.polar) {\n                            // For clipping purposes there is a need for\n                            // coordinates from the absolute center\n                            circ = this.yAxis.pane.center;\n                            if (!this.clipCircle) {\n                                this.clipCircle = clipCircle(chart_1.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2);\n                            }\n                            else {\n                                this.clipCircle.animate({\n                                    x: circ[0],\n                                    y: circ[1],\n                                    r: circ[2] / 2,\n                                    innerR: circ[3] / 2\n                                });\n                            }\n                            this.group.clip(this.clipCircle);\n                            this.setClip = H.noop;\n                        }\n                    }));\n                }\n            }\n        }\n        /**\n         * Search a k-d tree by the point angle, used for shared tooltips in polar\n         * charts\n         * @private\n         */\n        function searchPointByAngle(e) {\n            var series = this,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                center = xAxis.pane && xAxis.pane.center,\n                plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft,\n                plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;\n            return series.searchKDTree({\n                clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n            });\n        }\n        /**\n         * Trim polygonal path\n         * @private\n         */\n        function trimPath(path, start, end, radialAxis) {\n            var tickInterval = radialAxis.tickInterval,\n                ticks = radialAxis.tickPositions;\n            var lastTick = find(ticks,\n                function (tick) { return tick >= end; }),\n                firstTick = find(__spreadArray([],\n                ticks,\n                true).reverse(),\n                function (tick) { return tick <= start; });\n            if (!defined(lastTick)) {\n                lastTick = ticks[ticks.length - 1];\n            }\n            if (!defined(firstTick)) {\n                firstTick = ticks[0];\n                lastTick += tickInterval;\n                path[0][0] = 'L';\n                // To do: figure out why -3 or -2\n                path.unshift(path[path.length - 3]);\n            }\n            path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);\n            path[0][0] = 'M';\n            return path;\n        }\n        /**\n         * Extend chart.get to also search in panes. Used internally in\n         * responsiveness and chart.update.\n         * @private\n         */\n        function wrapChartGet(proceed, id) {\n            return find(this.pane || [], function (pane) {\n                // @todo remove id or define id type:\n                return pane.options.id === id;\n            }) || proceed.call(this, id);\n        }\n        /**\n         * Align column data labels outside the columns. #1199.\n         * @private\n         */\n        function wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options, alignTo, isNew) {\n            var chart = this.chart,\n                inside = pick(options.inside, !!this.options.stacking);\n            var angle,\n                shapeArgs,\n                labelPos;\n            if (chart.polar) {\n                angle = point.rectPlotX / Math.PI * 180;\n                if (!chart.inverted) {\n                    // Align nicely outside the perimeter of the columns\n                    options = findAlignments(angle, options);\n                }\n                else { // Required corrections for data labels of inverted bars\n                    // The plotX and plotY are correctly set therefore they\n                    // don't need to be swapped (inverted argument is false)\n                    this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);\n                    // Checks if labels should be positioned inside\n                    if (inside && point.shapeArgs) {\n                        shapeArgs = point.shapeArgs;\n                        // Calculates pixel positions for a data label to be\n                        // inside\n                        labelPos =\n                            this.yAxis.postTranslate(\n                            // angle\n                            ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 -\n                                this\n                                    .xAxis.startAngleRad, \n                            // radius\n                            point.barX +\n                                point.pointWidth / 2);\n                        alignTo = {\n                            x: labelPos.x - chart.plotLeft,\n                            y: labelPos.y - chart.plotTop\n                        };\n                    }\n                    else if (point.tooltipPos) {\n                        alignTo = {\n                            x: point.tooltipPos[0],\n                            y: point.tooltipPos[1]\n                        };\n                    }\n                    options.align = pick(options.align, 'center');\n                    options.verticalAlign =\n                        pick(options.verticalAlign, 'middle');\n                }\n                Object\n                    .getPrototypeOf(Object.getPrototypeOf(this))\n                    .alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n                // Hide label of a point (only inverted) that is outside the\n                // visible y range\n                if (this.isRadialBar && point.shapeArgs &&\n                    point.shapeArgs.start === point.shapeArgs.end) {\n                    dataLabel.hide();\n                }\n                else {\n                    dataLabel.show();\n                }\n            }\n            else {\n                proceed.call(this, point, dataLabel, options, alignTo, isNew);\n            }\n        }\n        /**\n         * Extend the column prototype's translate method\n         * @private\n         */\n        function wrapColumnSeriesTranslate(proceed) {\n            var series = this,\n                options = series.options,\n                stacking = options.stacking,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                reversed = yAxis.reversed,\n                center = yAxis.center,\n                startAngleRad = xAxis.startAngleRad,\n                endAngleRad = xAxis.endAngleRad,\n                visibleRange = endAngleRad - startAngleRad;\n            var threshold = options.threshold,\n                thresholdAngleRad = 0,\n                points,\n                point,\n                i,\n                yMin,\n                yMax,\n                start = 0,\n                end = 0,\n                tooltipPos,\n                pointX,\n                pointY,\n                stackValues,\n                stack,\n                barX,\n                innerR,\n                r;\n            series.preventPostTranslate = true;\n            // Run uber method\n            proceed.call(series);\n            // Postprocess plot coordinates\n            if (xAxis.isRadial) {\n                points = series.points;\n                i = points.length;\n                yMin = yAxis.translate(yAxis.min);\n                yMax = yAxis.translate(yAxis.max);\n                threshold = options.threshold || 0;\n                if (chart.inverted) {\n                    // Finding a correct threshold\n                    if (isNumber(threshold)) {\n                        thresholdAngleRad = yAxis.translate(threshold);\n                        // Checks if threshold is outside the visible range\n                        if (defined(thresholdAngleRad)) {\n                            if (thresholdAngleRad < 0) {\n                                thresholdAngleRad = 0;\n                            }\n                            else if (thresholdAngleRad > visibleRange) {\n                                thresholdAngleRad = visibleRange;\n                            }\n                            // Adding start angle offset\n                            series.translatedThreshold =\n                                thresholdAngleRad + startAngleRad;\n                        }\n                    }\n                }\n                while (i--) {\n                    point = points[i];\n                    barX = point.barX;\n                    pointX = point.x;\n                    pointY = point.y;\n                    point.shapeType = 'arc';\n                    if (chart.inverted) {\n                        point.plotY = yAxis.translate(pointY);\n                        if (stacking && yAxis.stacking) {\n                            stack = yAxis.stacking.stacks[(pointY < 0 ? '-' : '') +\n                                series.stackKey];\n                            if (series.visible && stack && stack[pointX]) {\n                                if (!point.isNull) {\n                                    stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];\n                                    // Translating to radial values\n                                    start = yAxis.translate(stackValues[0]);\n                                    end = yAxis.translate(stackValues[1]);\n                                    // If starting point is beyond the\n                                    // range, set it to 0\n                                    if (defined(start)) {\n                                        start = U.clamp(start, 0, visibleRange);\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            // Initial start and end angles for radial bar\n                            start = thresholdAngleRad;\n                            end = point.plotY;\n                        }\n                        if (start > end) {\n                            // Swapping start and end\n                            end = [start, start = end][0];\n                        }\n                        // Prevent from rendering point outside the\n                        // acceptable circular range\n                        if (!reversed) {\n                            if (start < yMin) {\n                                start = yMin;\n                            }\n                            else if (end > yMax) {\n                                end = yMax;\n                            }\n                            else if (end < yMin || start > yMax) {\n                                start = end = 0;\n                            }\n                        }\n                        else {\n                            if (end > yMin) {\n                                end = yMin;\n                            }\n                            else if (start < yMax) {\n                                start = yMax;\n                            }\n                            else if (start > yMin || end < yMax) {\n                                start = end = visibleRange;\n                            }\n                        }\n                        if (yAxis.min > yAxis.max) {\n                            start = end = reversed ? visibleRange : 0;\n                        }\n                        start += startAngleRad;\n                        end += startAngleRad;\n                        if (center) {\n                            point.barX = barX += center[3] / 2;\n                        }\n                        // In case when radius, inner radius or both are\n                        // negative, a point is rendered but partially or as\n                        // a center point\n                        innerR = Math.max(barX, 0);\n                        r = Math.max(barX + point.pointWidth, 0);\n                        point.shapeArgs = {\n                            x: center && center[0],\n                            y: center && center[1],\n                            r: r,\n                            innerR: innerR,\n                            start: start,\n                            end: end\n                        };\n                        // Fade out the points if not inside the polar \"plot area\"\n                        point.opacity = start === end ? 0 : void 0;\n                        // A correct value for stacked or not fully visible\n                        // point\n                        point.plotY = (defined(series.translatedThreshold) &&\n                            (start < series.translatedThreshold ? start : end)) -\n                            startAngleRad;\n                    }\n                    else {\n                        start = barX + startAngleRad;\n                        // Changed the way polar columns are drawn in order to make\n                        // it more consistent with the drawing of inverted columns\n                        // (they are using the same function now). Also, it was\n                        // essential to make the animation work correctly (the\n                        // scaling of the group) is replaced by animating each\n                        // element separately.\n                        point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start, start + point.pointWidth);\n                    }\n                    // Provided a correct coordinates for the tooltip\n                    series.polar.toXY(point);\n                    if (chart.inverted) {\n                        tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);\n                        point.tooltipPos = [\n                            tooltipPos.x - chart.plotLeft,\n                            tooltipPos.y - chart.plotTop\n                        ];\n                    }\n                    else {\n                        point.tooltipPos = [point.plotX, point.plotY];\n                    }\n                    if (center) {\n                        point.ttBelow = point.plotY > center[1];\n                    }\n                }\n            }\n        }\n        /**\n         * Extend getSegmentPath to allow connecting ends across 0 to provide a\n         * closed circle in line-like series.\n         * @private\n         */\n        function wrapLineSeriesGetGraphPath(proceed, points) {\n            var series = this;\n            var firstValid,\n                popLastPoint;\n            // Connect the path\n            if (this.chart.polar) {\n                points = points || this.points;\n                // Append first valid point in order to connect the ends\n                for (var i = 0; i < points.length; i++) {\n                    if (!points[i].isNull) {\n                        firstValid = i;\n                        break;\n                    }\n                }\n                /**\n                 * Polar charts only. Whether to connect the ends of a line series\n                 * plot across the extremes.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/line-connectends-false/\n                 *         Do not connect\n                 *\n                 * @type      {boolean}\n                 * @since     2.3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.series.connectEnds\n                 */\n                if (this.options.connectEnds !== false &&\n                    typeof firstValid !== 'undefined') {\n                    this.connectEnds = true; // re-used in splines\n                    points.splice(points.length, 0, points[firstValid]);\n                    popLastPoint = true;\n                }\n                // For area charts, pseudo points are added to the graph, now we\n                // need to translate these\n                points.forEach(function (point) {\n                    if (typeof point.polarPlotY === 'undefined') {\n                        series.polar.toXY(point);\n                    }\n                });\n            }\n            // Run uber method\n            var ret = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            // #6212 points.splice method is adding points to an array. In case of\n            // areaspline getGraphPath method is used two times and in both times\n            // points are added to an array. That is why points.pop is used, to get\n            // unmodified points.\n            if (popLastPoint) {\n                points.pop();\n            }\n            return ret;\n        }\n        /**\n         * Extend getCoordinates to prepare for polar axis values\n         * @private\n         */\n        function wrapPointerGetCoordinates(proceed, e) {\n            var chart = this.chart;\n            var ret = {\n                    xAxis: [],\n                    yAxis: []\n                };\n            if (chart.polar) {\n                chart.axes.forEach(function (axis) {\n                    // Skip colorAxis\n                    if (axis.coll === 'colorAxis') {\n                        return;\n                    }\n                    var isXAxis = axis.isXAxis,\n                        center = axis.center,\n                        x = e.chartX - center[0] - chart.plotLeft,\n                        y = e.chartY - center[1] - chart.plotTop;\n                    ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.translate(isXAxis ?\n                            Math.PI - Math.atan2(x, y) : // angle\n                            // distance from center\n                            Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), true)\n                    });\n                });\n            }\n            else {\n                ret = proceed.call(this, e);\n            }\n            return ret;\n        }\n        /**\n         * Prevent zooming on mobile devices\n         * @private\n         */\n        function wrapPointerPinch(proceed, e) {\n            if (this.chart.polar) {\n                return;\n            }\n            proceed.call(this, e);\n        }\n        /**\n         * Define the animate method for regular series\n         * @private\n         */\n        function wrapSeriesAnimate(proceed, init) {\n            var series = this,\n                chart = this.chart,\n                group = this.group,\n                markerGroup = this.markerGroup,\n                center = this.xAxis && this.xAxis.center,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop;\n            var animation = this.options.animation,\n                attribs,\n                paneInnerR,\n                graphic,\n                shapeArgs,\n                r,\n                innerR;\n            // Specific animation for polar charts\n            if (chart.polar) {\n                if (series.isRadialBar) {\n                    if (!init) {\n                        // Run the pie animation for radial bars\n                        series.startAngleRad = pick(series.translatedThreshold, series.xAxis.startAngleRad);\n                        H.seriesTypes.pie.prototype.animate.call(series, init);\n                    }\n                }\n                else {\n                    // Enable animation on polar charts only in SVG. In VML, the scaling\n                    // is different, plus animation would be so slow it would't matter.\n                    if (chart.renderer.isSVG) {\n                        animation = animObject(animation);\n                        // A different animation needed for column like series\n                        if (series.is('column')) {\n                            if (!init) {\n                                paneInnerR = center[3] / 2;\n                                series.points.forEach(function (point) {\n                                    graphic = point.graphic;\n                                    shapeArgs = point.shapeArgs;\n                                    r = shapeArgs && shapeArgs.r;\n                                    innerR = shapeArgs && shapeArgs.innerR;\n                                    if (graphic && shapeArgs) {\n                                        // start values\n                                        graphic.attr({\n                                            r: paneInnerR,\n                                            innerR: paneInnerR\n                                        });\n                                        // animate\n                                        graphic.animate({\n                                            r: r,\n                                            innerR: innerR\n                                        }, series.options.animation);\n                                    }\n                                });\n                            }\n                        }\n                        else {\n                            // Initialize the animation\n                            if (init) {\n                                // Scale down the group and place it in the center\n                                attribs = {\n                                    translateX: center[0] + plotLeft,\n                                    translateY: center[1] + plotTop,\n                                    scaleX: 0.001,\n                                    scaleY: 0.001\n                                };\n                                group.attr(attribs);\n                                if (markerGroup) {\n                                    markerGroup.attr(attribs);\n                                }\n                                // Run the animation\n                            }\n                            else {\n                                attribs = {\n                                    translateX: plotLeft,\n                                    translateY: plotTop,\n                                    scaleX: 1,\n                                    scaleY: 1\n                                };\n                                group.animate(attribs, animation);\n                                if (markerGroup) {\n                                    markerGroup.animate(attribs, animation);\n                                }\n                            }\n                        }\n                    }\n                }\n                // For non-polar charts, revert to the basic animation\n            }\n            else {\n                proceed.call(this, init);\n            }\n        }\n        /**\n         * Overridden method for calculating a spline from one point to the next\n         * @private\n         */\n        function wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {\n            var ret,\n                connectors;\n            if (this.chart.polar) {\n                // moveTo or lineTo\n                if (!i) {\n                    ret = ['M', point.plotX, point.plotY];\n                }\n                else { // curve from last point to this\n                    connectors = getConnectors(segment, i, true, this.connectEnds);\n                    var rightContX = connectors.prevPointCont &&\n                            connectors.prevPointCont.rightContX;\n                    var rightContY = connectors.prevPointCont &&\n                            connectors.prevPointCont.rightContY;\n                    ret = [\n                        'C',\n                        isNumber(rightContX) ? rightContX : connectors.plotX,\n                        isNumber(rightContY) ? rightContY : connectors.plotY,\n                        isNumber(connectors.leftContX) ?\n                            connectors.leftContX :\n                            connectors.plotX,\n                        isNumber(connectors.leftContY) ?\n                            connectors.leftContY :\n                            connectors.plotY,\n                        connectors.plotX,\n                        connectors.plotY\n                    ];\n                }\n            }\n            else {\n                ret = proceed.call(this, segment, point, i);\n            }\n            return ret;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Extensions for polar charts. Additionally, much of the geometry required\n         * for polar charts is gathered in RadialAxes.js.\n         * @private\n         */\n        var PolarAdditions = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function PolarAdditions(series) {\n                    this.series = series;\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            PolarAdditions.compose = function (AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {\n                RadialAxis.compose(AxisClass, TickClass);\n                if (composedClasses.indexOf(ChartClass) === -1) {\n                    composedClasses.push(ChartClass);\n                    addEvent(ChartClass, 'afterDrawChartBox', onChartAfterDrawChartBox);\n                    addEvent(ChartClass, 'getAxes', onChartGetAxes);\n                    addEvent(ChartClass, 'init', onChartAfterInit);\n                    var chartProto = ChartClass.prototype;\n                    wrap(chartProto, 'get', wrapChartGet);\n                }\n                if (composedClasses.indexOf(PointerClass) === -1) {\n                    composedClasses.push(PointerClass);\n                    var pointerProto = PointerClass.prototype;\n                    wrap(pointerProto, 'getCoordinates', wrapPointerGetCoordinates);\n                    wrap(pointerProto, 'pinch', wrapPointerPinch);\n                    addEvent(PointerClass, 'getSelectionMarkerAttrs', onPointerGetSelectionMarkerAttrs);\n                    addEvent(PointerClass, 'getSelectionBox', onPointerGetSelectionBox);\n                }\n                if (composedClasses.indexOf(SeriesClass) === -1) {\n                    composedClasses.push(SeriesClass);\n                    addEvent(SeriesClass, 'afterInit', onSeriesAfterInit);\n                    addEvent(SeriesClass, 'afterTranslate', onSeriesAfterTranslate, { order: 2 } // Run after translation of ||-coords\n                    );\n                    var seriesProto = SeriesClass.prototype;\n                    wrap(seriesProto, 'animate', wrapSeriesAnimate);\n                }\n                if (ColumnSeriesClass &&\n                    composedClasses.indexOf(ColumnSeriesClass) === -1) {\n                    composedClasses.push(ColumnSeriesClass);\n                    var columnProto = ColumnSeriesClass.prototype;\n                    wrap(columnProto, 'alignDataLabel', wrapColumnSeriesAlignDataLabel);\n                    wrap(columnProto, 'animate', wrapSeriesAnimate);\n                    wrap(columnProto, 'translate', wrapColumnSeriesTranslate);\n                }\n                if (LineSeriesClass &&\n                    composedClasses.indexOf(LineSeriesClass) === -1) {\n                    composedClasses.push(LineSeriesClass);\n                    var lineProto = LineSeriesClass.prototype;\n                    wrap(lineProto, 'getGraphPath', wrapLineSeriesGetGraphPath);\n                }\n                if (SplineSeriesClass &&\n                    composedClasses.indexOf(SplineSeriesClass) === -1) {\n                    composedClasses.push(SplineSeriesClass);\n                    var splineProto = SplineSeriesClass.prototype;\n                    wrap(splineProto, 'getPointSpline', wrapSplineSeriesGetPointSpline);\n                    if (AreaSplineRangeSeriesClass &&\n                        composedClasses.indexOf(AreaSplineRangeSeriesClass) === -1) {\n                        composedClasses.push(AreaSplineRangeSeriesClass);\n                        var areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;\n                        // #6430 Areasplinerange series use unwrapped getPointSpline\n                        // method, so we need to set this method again.\n                        areaSplineRangeProto.getPointSpline =\n                            splineProto.getPointSpline;\n                    }\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            PolarAdditions.prototype.arc = function (low, high, start, end) {\n                var series = this.series,\n                    center = series.xAxis.center,\n                    len = series.yAxis.len,\n                    paneInnerR = center[3] / 2;\n                var r = len - high + paneInnerR,\n                    innerR = len - pick(low,\n                    len) + paneInnerR;\n                // Prevent columns from shooting through the pane's center\n                if (series.yAxis.reversed) {\n                    if (r < 0) {\n                        r = paneInnerR;\n                    }\n                    if (innerR < 0) {\n                        innerR = paneInnerR;\n                    }\n                }\n                // Return a new shapeArgs\n                return {\n                    x: center[0],\n                    y: center[1],\n                    r: r,\n                    innerR: innerR,\n                    start: start,\n                    end: end\n                };\n            };\n            /**\n             * Translate a point's plotX and plotY from the internal angle and radius\n             * measures to true plotX, plotY coordinates\n             * @private\n             */\n            PolarAdditions.prototype.toXY = function (point) {\n                var series = this.series,\n                    chart = series.chart,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    plotX = point.plotX,\n                    inverted = chart.inverted,\n                    pointY = point.y;\n                var plotY = point.plotY,\n                    radius = inverted ? plotX : yAxis.len - plotY,\n                    clientX;\n                // Corrected y position of inverted series other than column\n                if (inverted && series && !series.isRadialBar) {\n                    point.plotY = plotY =\n                        isNumber(pointY) ? yAxis.translate(pointY) : 0;\n                }\n                // Save rectangular plotX, plotY for later computation\n                point.rectPlotX = plotX;\n                point.rectPlotY = plotY;\n                if (yAxis.center) {\n                    radius += yAxis.center[3] / 2;\n                }\n                // Find the polar plotX and plotY. Avoid setting plotX and plotY to NaN\n                // when plotY is undefined (#15438)\n                if (isNumber(plotY)) {\n                    var xy = inverted ? yAxis.postTranslate(plotY,\n                        radius) :\n                            xAxis.postTranslate(plotX,\n                        radius);\n                    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n                    point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n                }\n                // If shared tooltip, record the angle in degrees in order to align X\n                // points. Otherwise, use a standard k-d tree to get the nearest point\n                // in two dimensions.\n                if (series.kdByAngle) {\n                    clientX = ((plotX / Math.PI * 180) + xAxis.pane.options.startAngle) % 360;\n                    if (clientX < 0) { // #2665\n                        clientX += 360;\n                    }\n                    point.clientX = clientX;\n                }\n                else {\n                    point.clientX = point.plotX;\n                }\n            };\n            return PolarAdditions;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PolarAdditions;\n    });\n    _registerModule(_modules, 'masters/highcharts-more.src.js', [_modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Bubble/BubbleSeries.js'], _modules['Series/PackedBubble/PackedBubbleSeries.js'], _modules['Series/PolarComposition.js']], function (Highcharts, SeriesRegistry, BubbleSeries, PackedBubbleSeries, PolarAdditions) {\n\n        var G = Highcharts;\n        BubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);\n        PackedBubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);\n        PolarAdditions.compose(G.Axis, G.Chart, G.Pointer, G.Series, G.Tick, SeriesRegistry.seriesTypes.areasplinerange, SeriesRegistry.seriesTypes.column, SeriesRegistry.seriesTypes.line, SeriesRegistry.seriesTypes.spline);\n\n    });\n}));","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}"],"names":["d","D","b","c","h","a","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","path","module","_modules","f","w","g","k","e","G","m","E","v","Math","sqrt","pow","q","atan2","r","PI","ceil","addEvent","correctFloat","defined","F","extend","p","merge","l","pick","splat","prototype","collectionsWithUpdate","push","this","options","chart","center","background","coll","defaultOptions","size","innerSize","startAngle","defaultBackgroundOptions","shape","borderWidth","borderColor","backgroundColor","linearGradient","x1","y1","x2","y2","stops","from","Number","MAX_VALUE","innerRadius","to","outerRadius","init","pane","setOptions","angular","render","renderer","group","attr","zIndex","add","updateCenter","max","length","axis","renderBackground","destroy","splice","className","styledMode","fill","stroke","getPlotBandPath","getCenter","call","update","axes","forEach","getHoverPane","chartX","plotLeft","chartY","plotTop","polar","inverted","y","x","isInsidePlot","some","normalizedStartAngleRad","normalizedEndAngleRad","hoverPane","filter","visible","shared","directTouch","enableMouseTracking","xAxis","hoverPoint","plotX","plotY","Pane","__extends","Object","setPrototypeOf","__proto__","Array","constructor","create","seriesTypes","area","pointClass","isNumber","arguments","high","low","series","setState","state","plotHigh","yAxis","toPixels","plotLow","stateMarkerGraphic","lowerStateMarkerGraphic","upperStateMarkerGraphic","graphic","graphics","plotHighX","plotLowX","haloPath","isInside","isTopInside","concat","isValid","noop","n","column","isArray","lineWidth","threshold","tooltip","pointFormat","trackByArea","dataLabels","align","verticalAlign","xLow","xHigh","yLow","yHigh","data","points","toYData","highToXY","postTranslate","rectPlotX","len","getGraphPath","connectEnds","B","connectNulls","step","t","yBottom","doCurve","isNull","polarPlotY","left","right","graphPath","areaPath","isArea","xMap","drawDataLabels","enabled","_hasPointLabels","inside","_plotY","dataLabel","dataLabelUpper","below","alignDataLabel","drawPoints","origProps","negative","zone","zones","getZone","pointArrayMap","join","translate","dataModify","modifyValue","order","tooltipPos","pos","deferTranslatePolar","pointValKey","setStackedPoints","registerSeriesType","spline","getPointSpline","pointAttribs","highPlot","I","K","doQuartiles","H","whiskerLength","N","shapeArgs","L","u","C","color","round","width","floor","q1Plot","lowPlot","q3Plot","stem","addClass","whiskers","box","medianShape","stemColor","stemWidth","dashstyle","stemDashStyle","dashStyle","whiskerColor","whiskerWidth","whiskerDashStyle","fillColor","lineColor","boxDashStyle","medianColor","medianWidth","medianDashStyle","strokeWidth","test","parseFloat","medianPlot","q1","median","q3","connectorClassName","connectorColor","connectorDistance","connectorWidth","labels","allowOverlap","format","formatter","style","fontSize","maxSize","minSize","legendIndex","ranges","value","sizeBy","sizeByAbsoluteValue","zThreshold","parse","arrayMax","arrayMin","stableSort","symbols","selected","movementX","maxLabel","legend","fontMetrics","addToLegend","drawLegendSymbol","itemDistance","legendItem","getMaxLabelSize","radius","labelWidth","labelHeight","bubbleLegend","autoRanges","seriesIndex","baseline","rtl","marker","fillOpacity","setOpacity","get","getRangeRadius","bubbleAttribs","connectorAttribs","labelAttribs","getRadius","connectors","bubbleItems","symbol","label","translateX","translateY","renderRange","hideOverlappingLabels","abs","circle","colorIndex","crispLine","text","formatLabel","css","placed","alignAttr","getBBox","numberFormatter","newOpacity","oldOpacity","show","hide","getRanges","isBubble","ignoreSeries","zData","zMin","min","displayNegative","zMax","reverse","predictBubbleSizes","floating","layout","lastLineHeight","plotSizeX","plotSizeY","getPxExtremes","minPxSize","maxPxSize","updateRanges","correctSizes","allItems","getMargins","setScale","updateNames","ticks","isNew","isNewLabel","itemHeight","height","destroyItem","objectEach","wrap","compose","indexOf","scatter","ttBelow","isXAxis","bubblePadding","ignoreHiddenSeries","allowZoomOutside","onPoint","getRadii","radii","dataMin","logarithmic","clamp","yData","beforePadding","animate","animationLimit","hasRendered","markerAttribs","animation","bubbleZExtremes","getZExtremes","hasData","processedXData","translateBubble","dlBox","plotWidth","plotHeight","parseInt","point","z","states","hover","radiusPlus","softThreshold","halo","turboThreshold","zoneAxis","applyZones","buildKDTree","parallelArrays","trackerGroups","specialGroup","target","arearange","pointRange","stacking","startAngleRad","isRadial","chartWidth","chartHeight","minPointLength","rectPlotY","barX","shapeType","arc","pointWidth","translate3dPoints","translate3dShapes","adjustForMissingColumns","crispCol","drawGraph","getSymbol","drawTracker","getColumnMetrics","dense","closestPointRange","transA","translatedThreshold","getThreshold","barW","pointXOffset","offset","pointPadding","total","J","A","grouping","linkedTo","linkedParent","columnMetrics","pInt","generatePoints","dial","baseLength","rearLength","baseWidth","topWidth","overshoot","endAngleRad","rotation","pivot","plotGroup","seriesGroup","clip","clipRect","setData","processData","redraw","borderRadius","crop","defer","headerFormat","showInLegend","fixedBox","forceDL","noSharedTooltip","container","hasDraggableNodes","draggable","onMouseDown","onMouseMove","ownerDocument","onMouseUp","pointer","normalize","fixedPosition","inDragMode","graphLayoutsLookup","hasDragged","redrawHalo","restartSimulation","enableSimulation","start","fixedDraggable","updateSimulation","stop","maxIterations","isFinite","temperature","isStable","beforeStep","setAnimation","integrations","layouts","degree","NaN","mass","removeElementFromCollection","nodes","firePointEvent","isParentNode","parentNode","allowPointSelect","select","getSelectedPoints","getSelectedParentNodes","bubble","crisp","useSimulation","parentNodeFormatter","name","parentNodeTextPath","padding","transition","layoutAlgorithm","initialPositions","initialPositionRadius","parentNodeLimit","seriesInteraction","dragBetweenSeries","parentNodeOptions","gravitationalConstant","maxSpeed","type","integration","splitSeries","friction","attractive","getMass","diffTemperature","fromNode","toNode","attractiveForceFunction","barycenter","xFactor","yFactor","top","getK","integrate","dispX","prevX","dispY","prevY","vectorLength","repulsive","repulsiveForceFunction","getDegree","isInternal","isEmpty","body","boxSize","divideBox","getBoxPosition","insert","updateMassAndCenter","maxDepth","root","isRoot","calculateMassAndCenter","visitNodeRecursive","insertNodes","win","isFunction","attractiveForce","currentStep","initialRendering","links","repulsiveForce","quadTree","simulation","euler","verlet","setInitialRendering","approximation","forces","initPositions","finishedAnimating","setK","resetSimulation","createQuadTree","applyLimits","coolDown","startTemperature","prevSystemTemperature","systemTemperature","getSystemTemperature","cancelAnimationFrame","requestAnimationFrame","setArea","linkLength","addElementsToCollection","clear","forcedStop","setMaxIterations","setTemperature","setDiffTemperature","setCircularPositions","setRandomPositions","linksTo","linksFrom","id","cos","sin","force","barycenterForces","getBarycenter","barnesHutApproximation","getDistXY","theta","repulsiveForces","attractiveForces","applyLimitBox","getDistR","absX","absY","allDataPoints","index","packedbubble","calculateParentRadius","neighbours","parentNodeRadius","fireEvent","Q","parentNodeMass","xData","accumulateAllPoints","is","addLayout","graphLayoutsStorage","forExport","collisionNmb","addSeriesLayout","parentNodeLayout","createParentNodes","seriesBox","calculateZExtremes","Infinity","checkOverlap","brighten","normal","dataLabelOnNull","deferLayout","formatPrefix","opacity","parentNodesGroup","graph","element","div","getPointRadius","minRadius","maxRadius","eventsToUnbind","isDirty","removed","addPoint","remove","placeBubbles","positionBubble","sort","stages","rawPositions","resizeRadius","asin","acos","POSITIVE_INFINITY","NEGATIVE_INFINITY","diffY","diffX","setVisible","axisTypes","isCartesian","requireSorting","indexateNodes","searchPoint","line","stickyTracking","followPointer","drawRectangle","waterfall","stacks","changed","alreadyChanged","stackLabels","renderStackTotals","stackTotalGroup","dummyStackItem","stackTotal","Composition","getClassName","isSum","isIntermediateSum","stackedYNeg","stackedYPos","stackKey","processedYData","stackState","stateIndex","absolutePos","absoluteNeg","posTotal","negTotal","connectorThreshold","reversed","setOffset","minPointLengthOffset","isPointInside","dataMax","updateParallelArrays","upColor","getCrispPath","R","usePercentage","O","getExtremes","lineWidthPlus","getZonesGraphs","showLine","relativeLength","autoConnect","isCircular","userMax","categories","tickPositions","map","getPosition","horiz","end","open","innerR","xBounds","yBounds","angleRad","getOffset","axisOffset","side","P","thickness","gridLineInterpolation","getPlotLinePath","isCrosshair","getCrosshairPosition","getLinePath","slice","title","middle","beforeSetTickPositions","createLabelCollector","getTitlePosition","setAxisSize","setAxisTranslation","endAngle","angle","preventDefault","labelCollectors","labelCollector","U","userOptions","isHidden","setTitle","setCategories","defaultPolarOptions","Y","X","defaultXAxisOptions","defaultYAxisOptions","Z","reversedStacks","M","distance","styles","tickInterval","S","sector","minPixelPadding","minPointOffset","plotBands","W","T","gridLineWidth","textOverflow","maxPadding","minPadding","showLastLabel","tickLength","minorGridLineWidth","minorTickInterval","minorTickLength","minorTickPosition","minorTickWidth","tickPosition","tickWidth","rightContX","rightContY","leftContX","leftContY","prevPointCont","args","startOnTick","endOnTick","V","result","mouseDownX","mouseDownY","zoomHor","toValue","zoomVert","attrs","isRadialSeries","isRadialBar","kdByAngle","findNearestPointBy","preventPostTranslate","toXY","hasParallelCoordinates","MIN_VALUE","hasClipCircleSetter","clipCircle","createElement","defs","clipPath","setClip","searchKDTree","clientX","unshift","getPrototypeOf","getStackIndicator","key","pop","markerGroup","pie","isSVG","scaleX","scaleY","__spreadArray","animObject","find","uniqueKey","polarPlotX","Axis","Chart","Legend","Series","Pointer","Tick","areasplinerange","exports","define","Highcharts","_objectWithoutProperties","source","excluded","i","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable"],"sourceRoot":""}